// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: amp.ski.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Ski {

  /// <summary>Holder for reflection information generated from amp.ski.proto</summary>
  public static partial class AmpSkiReflection {

    #region Descriptor
    /// <summary>File descriptor for amp.ski.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static AmpSkiReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg1hbXAuc2tpLnByb3RvEgNza2kisgEKC0NyeXB0T3BBcmdzEh0KB0NyeXB0",
            "T3AYASABKA4yDC5za2kuQ3J5cHRPcBIqChBEZWZhdWx0Q3J5cHRvS2l0GAIg",
            "ASgOMhAuc2tpLkNyeXB0b0tpdElEEg0KBUJ1ZkluGAMgASgMEhoKBU9wS2V5",
            "GAQgASgLMgsuc2tpLktleVJlZhIPCgdQZWVyS2V5GAUgASgMEhwKBlRvbWVJ",
            "bhgGIAEoCzIMLnNraS5LZXlUb21lIi4KCkNyeXB0T3BPdXQSDgoGQnVmT3V0",
            "GAEgASgMEhAKCE9wUHViS2V5GAIgASgMInQKB0tleUluZm8SHQoHS2V5VHlw",
            "ZRgBIAEoDjIMLnNraS5LZXlUeXBlEiUKC0NyeXB0b0tpdElEGAIgASgOMhAu",
            "c2tpLkNyeXB0b0tpdElEEhMKC1RpbWVDcmVhdGVkGAMgASgDEg4KBlB1Yktl",
            "eRgEIAEoDCItCgZLZXlSZWYSEwoLS2V5cmluZ05hbWUYASABKAwSDgoGUHVi",
            "S2V5GAIgASgMIjoKCEtleUVudHJ5Eh0KB0tleUluZm8YASABKAsyDC5za2ku",
            "S2V5SW5mbxIPCgdQcml2S2V5GAYgASgMImIKB0tleXJpbmcSDAoETmFtZRgB",
            "IAEoDBIbCgRLZXlzGAIgAygLMg0uc2tpLktleUVudHJ5EhYKDlNvcnRlZEJ5",
            "UHViS2V5GAMgASgIEhQKDE5ld2VzdFB1YktleRgEIAEoDCJMCgdLZXlUb21l",
            "EgsKA1JldhgBIAEoAxIeCghLZXlyaW5ncxgCIAMoCzIMLnNraS5LZXlyaW5n",
            "EhQKDFNvcnRlZEJ5TmFtZRgDIAEoCCKmAQoJU2lnSGVhZGVyEikKD1NpZ25l",
            "ckNyeXB0b0tpdBgBIAEoDjIQLnNraS5DcnlwdG9LaXRJRBIUCgxTaWduZXJQ",
            "dWJLZXkYAiABKAwSIQoJSGFzaEtpdElEGAYgASgOMg4uc2tpLkhhc2hLaXRJ",
            "RBIQCghIZWFkZXJTehgHIAEoDRITCgtIZWFkZXJDb2RlYxgIIAEoDRIOCgZC",
            "b2R5U3oYCSABKAQiWAoMS2V5VG9tZUNyeXB0EgwKBFRvbWUYASABKAwSGwoG",
            "S2V5UmVmGAogASgLMgsuc2tpLktleVJlZhIdCgdLZXlJbmZvGAsgASgLMgwu",
            "c2tpLktleUluZm8qbwoHS2V5VHlwZRIXChNLZXlUeXBlX1Vuc3BlY2lmaWVk",
            "EAASGAoUS2V5VHlwZV9TeW1tZXRyaWNLZXkQARIZChVLZXlUeXBlX0FzeW1t",
            "ZXRyaWNLZXkQAhIWChJLZXlUeXBlX1NpZ25pbmdLZXkQAypfCgtDcnlwdG9L",
            "aXRJRBIhCh1DcnlwdG9LaXRJRF9VbnNwZWNpZmllZENyeXB0bxAAEhQKEENy",
            "eXB0b0tpdElEX05hQ2wQARIXChNDcnlwdG9LaXRJRF9FRDI1NTE5EAIq0wEK",
            "CUhhc2hLaXRJRBIgChxIYXNoS2l0SURfVW5zcGVjaWZpZWRIYXNoS2l0EAAS",
            "HgoaSGFzaEtpdElEX0xlZ2FjeUtlY2Nha18yNTYQARIeChpIYXNoS2l0SURf",
            "TGVnYWN5S2VjY2FrXzUxMhACEhYKEkhhc2hLaXRJRF9TSEEzXzI1NhADEhYK",
            "Ekhhc2hLaXRJRF9TSEEzXzUxMhAEEhkKFUhhc2hLaXRJRF9CbGFrZTJiXzI1",
            "NhAFEhkKFUhhc2hLaXRJRF9CbGFrZTJiXzUxMhAGKu8BCgdDcnlwdE9wEhAK",
            "DENyeXB0T3BfU2lnbhAAEhYKEkNyeXB0T3BfRW5jcnlwdFN5bRABEhYKEkNy",
            "eXB0T3BfRGVjcnlwdFN5bRACEhkKFUNyeXB0T3BfRW5jcnlwdFRvUGVlchAD",
            "EhsKF0NyeXB0T3BfRGVjcnlwdEZyb21QZWVyEAQSGQoVQ3J5cHRPcF9JbXBv",
            "cnRVc2luZ1B3EAUSGQoVQ3J5cHRPcF9FeHBvcnRVc2luZ1B3EAYSGgoWQ3J5",
            "cHRPcF9JbXBvcnRGcm9tUGVlchAHEhgKFENyeXB0T3BfRXhwb3J0VG9QZWVy",
            "EAhiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Ski.KeyType), typeof(global::Ski.CryptoKitID), typeof(global::Ski.HashKitID), typeof(global::Ski.CryptOp), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Ski.CryptOpArgs), global::Ski.CryptOpArgs.Parser, new[]{ "CryptOp", "DefaultCryptoKit", "BufIn", "OpKey", "PeerKey", "TomeIn" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ski.CryptOpOut), global::Ski.CryptOpOut.Parser, new[]{ "BufOut", "OpPubKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ski.KeyInfo), global::Ski.KeyInfo.Parser, new[]{ "KeyType", "CryptoKitID", "TimeCreated", "PubKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ski.KeyRef), global::Ski.KeyRef.Parser, new[]{ "KeyringName", "PubKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ski.KeyEntry), global::Ski.KeyEntry.Parser, new[]{ "KeyInfo", "PrivKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ski.Keyring), global::Ski.Keyring.Parser, new[]{ "Name", "Keys", "SortedByPubKey", "NewestPubKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ski.KeyTome), global::Ski.KeyTome.Parser, new[]{ "Rev", "Keyrings", "SortedByName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ski.SigHeader), global::Ski.SigHeader.Parser, new[]{ "SignerCryptoKit", "SignerPubKey", "HashKitID", "HeaderSz", "HeaderCodec", "BodySz" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ski.KeyTomeCrypt), global::Ski.KeyTomeCrypt.Parser, new[]{ "Tome", "KeyRef", "KeyInfo" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// KeyType identifies how a key operates
  /// </summary>
  public enum KeyType {
    [pbr::OriginalName("KeyType_Unspecified")] Unspecified = 0,
    [pbr::OriginalName("KeyType_SymmetricKey")] SymmetricKey = 1,
    [pbr::OriginalName("KeyType_AsymmetricKey")] AsymmetricKey = 2,
    [pbr::OriginalName("KeyType_SigningKey")] SigningKey = 3,
  }

  /// <summary>
  /// CryptoKitID identifies an encryption suite that implements ski.CryptoKit
  /// </summary>
  public enum CryptoKitID {
    [pbr::OriginalName("CryptoKitID_UnspecifiedCrypto")] UnspecifiedCrypto = 0,
    [pbr::OriginalName("CryptoKitID_NaCl")] NaCl = 1,
    [pbr::OriginalName("CryptoKitID_ED25519")] Ed25519 = 2,
  }

  /// <summary>
  /// CryptoKitID identifies a hash algorithm that implements ski.HaskKit
  /// </summary>
  public enum HashKitID {
    [pbr::OriginalName("HashKitID_UnspecifiedHashKit")] UnspecifiedHashKit = 0,
    [pbr::OriginalName("HashKitID_LegacyKeccak_256")] LegacyKeccak256 = 1,
    [pbr::OriginalName("HashKitID_LegacyKeccak_512")] LegacyKeccak512 = 2,
    [pbr::OriginalName("HashKitID_SHA3_256")] Sha3256 = 3,
    [pbr::OriginalName("HashKitID_SHA3_512")] Sha3512 = 4,
    [pbr::OriginalName("HashKitID_Blake2b_256")] Blake2B256 = 5,
    [pbr::OriginalName("HashKitID_Blake2b_512")] Blake2B512 = 6,
  }

  public enum CryptOp {
    /// <summary>
    /// Generates a signature for BufIn using the referenced signing key, placing the signature into BufOut.
    /// </summary>
    [pbr::OriginalName("CryptOp_Sign")] Sign = 0,
    /// <summary>
    /// Inverse of DecryptSym
    /// Encrypts BufIn using the symmetric key referenced by OpKey.
    /// </summary>
    [pbr::OriginalName("CryptOp_EncryptSym")] EncryptSym = 1,
    /// <summary>
    /// Inverse of EncryptSym
    /// Decrypts BufIn using the symmetric key referenced by OpKey.
    /// </summary>
    [pbr::OriginalName("CryptOp_DecryptSym")] DecryptSym = 2,
    /// <summary>
    /// Encrypts BufIn for a recipient holding the private key associated with the pub key contained in PeerKey,
    ///    encrypting using the referenced asymmetric key and placing the encrypted result into BufOut.
    /// </summary>
    [pbr::OriginalName("CryptOp_EncryptToPeer")] EncryptToPeer = 3,
    /// <summary>
    /// Decrypts BufIn from a sender holding the private key associated with the pub key contained in PeerKey,
    ///    decrypting using the referenced asymmetric key and placing the decrypted result into BufOut.
    /// </summary>
    [pbr::OriginalName("CryptOp_DecryptFromPeer")] DecryptFromPeer = 4,
    /// <summary>
    /// Inverse of ExportUsingPw
    /// Identical to ImportFromPeer except that BufIn is instead decrypted via CryptoKit.DecryptUsingPassword(),
    ///    using CryptOp.PeerKey as a the password.  The CryptoKit invoked is determined by CryptOpArgs.DefaultCryptoKit.
    /// </summary>
    [pbr::OriginalName("CryptOp_ImportUsingPw")] ImportUsingPw = 5,
    /// <summary>
    /// Inverse of ImportUsingPw
    /// Identical to ExportToPeer except the output serialized KeyTome is encrypted via CryptoKit.EncryptUsingPassword(),
    ///    using CryptOp.PeerKey as a the password.  The CryptoKit invoked is determined by CryptOpArgs.DefaultCryptoKit.
    /// </summary>
    [pbr::OriginalName("CryptOp_ExportUsingPw")] ExportUsingPw = 6,
    /// <summary>
    /// Inverse of ExportToPeer
    /// First, performs as DecryptFromPeer.
    /// The result/output buf is then unmarshalled (assumed to be a ski.KeyTome protobuf) and is merged into the host KeyTome.
    /// See ski.ImportKeys() for how the incoming KeyTome is merged into the host KeyTome.
    /// </summary>
    [pbr::OriginalName("CryptOp_ImportFromPeer")] ImportFromPeer = 7,
    /// <summary>
    /// Inverse of ImportFromPeer
    /// For each entry in CryptOpArgs.TomeIn, PubKey is used to lookup a corresponding KeyEntry in the host KeyTome.
    /// Each KeyEntry with a matching PubKey is copied into a new temp KeyTome, into the appropriate Keyring,
    ///    creating a Keyring if it does not yet exist.
    /// If a Keyring appears in CryptOpArgs.TomeIn but contains no entries, the entire Keyring will be exported.
    /// If a Keyring or KeyEntry from TomeIn isn't found, an error is returned.
    /// See KeyTome.ExportUsingGuide() for how TomeIn is handled.
    /// On completion, the temp KeyTome is serialized, assigned to CryptOpArgs.BufIn, and EncryptToPeer is executed.
    /// </summary>
    [pbr::OriginalName("CryptOp_ExportToPeer")] ExportToPeer = 8,
  }

  #endregion

  #region Messages
  public sealed partial class CryptOpArgs : pb::IMessage<CryptOpArgs>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CryptOpArgs> _parser = new pb::MessageParser<CryptOpArgs>(() => new CryptOpArgs());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CryptOpArgs> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ski.AmpSkiReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptOpArgs() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptOpArgs(CryptOpArgs other) : this() {
      cryptOp_ = other.cryptOp_;
      defaultCryptoKit_ = other.defaultCryptoKit_;
      bufIn_ = other.bufIn_;
      opKey_ = other.opKey_ != null ? other.opKey_.Clone() : null;
      peerKey_ = other.peerKey_;
      tomeIn_ = other.tomeIn_ != null ? other.tomeIn_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptOpArgs Clone() {
      return new CryptOpArgs(this);
    }

    /// <summary>Field number for the "CryptOp" field.</summary>
    public const int CryptOpFieldNumber = 1;
    private global::Ski.CryptOp cryptOp_ = global::Ski.CryptOp.Sign;
    /// <summary>
    /// Specifies which op to invoke for these given set of args
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ski.CryptOp CryptOp {
      get { return cryptOp_; }
      set {
        cryptOp_ = value;
      }
    }

    /// <summary>Field number for the "DefaultCryptoKit" field.</summary>
    public const int DefaultCryptoKitFieldNumber = 2;
    private global::Ski.CryptoKitID defaultCryptoKit_ = global::Ski.CryptoKitID.UnspecifiedCrypto;
    /// <summary>
    /// Specifies the default CryptoKit for ops when not specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ski.CryptoKitID DefaultCryptoKit {
      get { return defaultCryptoKit_; }
      set {
        defaultCryptoKit_ = value;
      }
    }

    /// <summary>Field number for the "BufIn" field.</summary>
    public const int BufInFieldNumber = 3;
    private pb::ByteString bufIn_ = pb::ByteString.Empty;
    /// <summary>
    /// The source/input buffer that is signed/encrypted/decrypted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString BufIn {
      get { return bufIn_; }
      set {
        bufIn_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "OpKey" field.</summary>
    public const int OpKeyFieldNumber = 4;
    private global::Ski.KeyRef opKey_;
    /// <summary>
    /// A reference to an existing KeyEntry in the host's KeyTome used as the key for this op's encryption/decryption.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ski.KeyRef OpKey {
      get { return opKey_; }
      set {
        opKey_ = value;
      }
    }

    /// <summary>Field number for the "PeerKey" field.</summary>
    public const int PeerKeyFieldNumber = 5;
    private pb::ByteString peerKey_ = pb::ByteString.Empty;
    /// <summary>
    /// For EncryptToPeer and ExportToPeer, this is what the recipient will use for OpKey.PubKey.
    /// For DecryptFromPeer and ImportFromPeer, this is what the sender used for OpKey.PubKey.
    /// For ImportUsingPw and ExportUsingPw, this is the password.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PeerKey {
      get { return peerKey_; }
      set {
        peerKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "TomeIn" field.</summary>
    public const int TomeInFieldNumber = 6;
    private global::Ski.KeyTome tomeIn_;
    /// <summary>
    /// Keyring and key info used to identify existing (or to-be-created) keys in the host's KeyTome.
    /// Used for ExportToPeer and GenerateKeys().
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ski.KeyTome TomeIn {
      get { return tomeIn_; }
      set {
        tomeIn_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CryptOpArgs);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CryptOpArgs other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CryptOp != other.CryptOp) return false;
      if (DefaultCryptoKit != other.DefaultCryptoKit) return false;
      if (BufIn != other.BufIn) return false;
      if (!object.Equals(OpKey, other.OpKey)) return false;
      if (PeerKey != other.PeerKey) return false;
      if (!object.Equals(TomeIn, other.TomeIn)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (CryptOp != global::Ski.CryptOp.Sign) hash ^= CryptOp.GetHashCode();
      if (DefaultCryptoKit != global::Ski.CryptoKitID.UnspecifiedCrypto) hash ^= DefaultCryptoKit.GetHashCode();
      if (BufIn.Length != 0) hash ^= BufIn.GetHashCode();
      if (opKey_ != null) hash ^= OpKey.GetHashCode();
      if (PeerKey.Length != 0) hash ^= PeerKey.GetHashCode();
      if (tomeIn_ != null) hash ^= TomeIn.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (CryptOp != global::Ski.CryptOp.Sign) {
        output.WriteRawTag(8);
        output.WriteEnum((int) CryptOp);
      }
      if (DefaultCryptoKit != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DefaultCryptoKit);
      }
      if (BufIn.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(BufIn);
      }
      if (opKey_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(OpKey);
      }
      if (PeerKey.Length != 0) {
        output.WriteRawTag(42);
        output.WriteBytes(PeerKey);
      }
      if (tomeIn_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(TomeIn);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (CryptOp != global::Ski.CryptOp.Sign) {
        output.WriteRawTag(8);
        output.WriteEnum((int) CryptOp);
      }
      if (DefaultCryptoKit != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DefaultCryptoKit);
      }
      if (BufIn.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(BufIn);
      }
      if (opKey_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(OpKey);
      }
      if (PeerKey.Length != 0) {
        output.WriteRawTag(42);
        output.WriteBytes(PeerKey);
      }
      if (tomeIn_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(TomeIn);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (CryptOp != global::Ski.CryptOp.Sign) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CryptOp);
      }
      if (DefaultCryptoKit != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DefaultCryptoKit);
      }
      if (BufIn.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(BufIn);
      }
      if (opKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OpKey);
      }
      if (PeerKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerKey);
      }
      if (tomeIn_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TomeIn);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CryptOpArgs other) {
      if (other == null) {
        return;
      }
      if (other.CryptOp != global::Ski.CryptOp.Sign) {
        CryptOp = other.CryptOp;
      }
      if (other.DefaultCryptoKit != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        DefaultCryptoKit = other.DefaultCryptoKit;
      }
      if (other.BufIn.Length != 0) {
        BufIn = other.BufIn;
      }
      if (other.opKey_ != null) {
        if (opKey_ == null) {
          OpKey = new global::Ski.KeyRef();
        }
        OpKey.MergeFrom(other.OpKey);
      }
      if (other.PeerKey.Length != 0) {
        PeerKey = other.PeerKey;
      }
      if (other.tomeIn_ != null) {
        if (tomeIn_ == null) {
          TomeIn = new global::Ski.KeyTome();
        }
        TomeIn.MergeFrom(other.TomeIn);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            CryptOp = (global::Ski.CryptOp) input.ReadEnum();
            break;
          }
          case 16: {
            DefaultCryptoKit = (global::Ski.CryptoKitID) input.ReadEnum();
            break;
          }
          case 26: {
            BufIn = input.ReadBytes();
            break;
          }
          case 34: {
            if (opKey_ == null) {
              OpKey = new global::Ski.KeyRef();
            }
            input.ReadMessage(OpKey);
            break;
          }
          case 42: {
            PeerKey = input.ReadBytes();
            break;
          }
          case 50: {
            if (tomeIn_ == null) {
              TomeIn = new global::Ski.KeyTome();
            }
            input.ReadMessage(TomeIn);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            CryptOp = (global::Ski.CryptOp) input.ReadEnum();
            break;
          }
          case 16: {
            DefaultCryptoKit = (global::Ski.CryptoKitID) input.ReadEnum();
            break;
          }
          case 26: {
            BufIn = input.ReadBytes();
            break;
          }
          case 34: {
            if (opKey_ == null) {
              OpKey = new global::Ski.KeyRef();
            }
            input.ReadMessage(OpKey);
            break;
          }
          case 42: {
            PeerKey = input.ReadBytes();
            break;
          }
          case 50: {
            if (tomeIn_ == null) {
              TomeIn = new global::Ski.KeyTome();
            }
            input.ReadMessage(TomeIn);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class CryptOpOut : pb::IMessage<CryptOpOut>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CryptOpOut> _parser = new pb::MessageParser<CryptOpOut>(() => new CryptOpOut());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CryptOpOut> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ski.AmpSkiReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptOpOut() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptOpOut(CryptOpOut other) : this() {
      bufOut_ = other.bufOut_;
      opPubKey_ = other.opPubKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptOpOut Clone() {
      return new CryptOpOut(this);
    }

    /// <summary>Field number for the "BufOut" field.</summary>
    public const int BufOutFieldNumber = 1;
    private pb::ByteString bufOut_ = pb::ByteString.Empty;
    /// <summary>
    /// Output buf from the given crypto op (and depends on the given CryptOp)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString BufOut {
      get { return bufOut_; }
      set {
        bufOut_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "OpPubKey" field.</summary>
    public const int OpPubKeyFieldNumber = 2;
    private pb::ByteString opPubKey_ = pb::ByteString.Empty;
    /// <summary>
    /// Returns the pub key used in the op (needed when CryptOpArgs.OpKey.PubKey wasn't specified)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString OpPubKey {
      get { return opPubKey_; }
      set {
        opPubKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CryptOpOut);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CryptOpOut other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BufOut != other.BufOut) return false;
      if (OpPubKey != other.OpPubKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (BufOut.Length != 0) hash ^= BufOut.GetHashCode();
      if (OpPubKey.Length != 0) hash ^= OpPubKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BufOut.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(BufOut);
      }
      if (OpPubKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(OpPubKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BufOut.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(BufOut);
      }
      if (OpPubKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(OpPubKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (BufOut.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(BufOut);
      }
      if (OpPubKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(OpPubKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CryptOpOut other) {
      if (other == null) {
        return;
      }
      if (other.BufOut.Length != 0) {
        BufOut = other.BufOut;
      }
      if (other.OpPubKey.Length != 0) {
        OpPubKey = other.OpPubKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            BufOut = input.ReadBytes();
            break;
          }
          case 18: {
            OpPubKey = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            BufOut = input.ReadBytes();
            break;
          }
          case 18: {
            OpPubKey = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// KeyInfo specifies info an existing KeyEntry or and KeyEntry this is to be created.
  ///
  /// KeyInfo exists in two modes/uses:
  ///    1) Generated/copied from an existing KeyEntry
  ///    2) Key gen mode: used as a guide to generate a new key
  ///         a) Fields used: KeyType and CryptoKitID (other fields ignored)
  /// </summary>
  public sealed partial class KeyInfo : pb::IMessage<KeyInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeyInfo> _parser = new pb::MessageParser<KeyInfo>(() => new KeyInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<KeyInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ski.AmpSkiReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyInfo(KeyInfo other) : this() {
      keyType_ = other.keyType_;
      cryptoKitID_ = other.cryptoKitID_;
      timeCreated_ = other.timeCreated_;
      pubKey_ = other.pubKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyInfo Clone() {
      return new KeyInfo(this);
    }

    /// <summary>Field number for the "KeyType" field.</summary>
    public const int KeyTypeFieldNumber = 1;
    private global::Ski.KeyType keyType_ = global::Ski.KeyType.Unspecified;
    /// <summary>
    /// Specifies the type of key this is (optional)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ski.KeyType KeyType {
      get { return keyType_; }
      set {
        keyType_ = value;
      }
    }

    /// <summary>Field number for the "CryptoKitID" field.</summary>
    public const int CryptoKitIDFieldNumber = 2;
    private global::Ski.CryptoKitID cryptoKitID_ = global::Ski.CryptoKitID.UnspecifiedCrypto;
    /// <summary>
    /// Specifies which crypto suite to invoke.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ski.CryptoKitID CryptoKitID {
      get { return cryptoKitID_; }
      set {
        cryptoKitID_ = value;
      }
    }

    /// <summary>Field number for the "TimeCreated" field.</summary>
    public const int TimeCreatedFieldNumber = 3;
    private long timeCreated_;
    /// <summary>
    /// Unix timestamp &lt;&lt; 16 ("UTC16") when this key was created (or 0 if not set)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TimeCreated {
      get { return timeCreated_; }
      set {
        timeCreated_ = value;
      }
    }

    /// <summary>Field number for the "PubKey" field.</summary>
    public const int PubKeyFieldNumber = 4;
    private pb::ByteString pubKey_ = pb::ByteString.Empty;
    /// <summary>
    /// Public part of the key; how this key is also referenced publicly (in base-256 form)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PubKey {
      get { return pubKey_; }
      set {
        pubKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as KeyInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(KeyInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (KeyType != other.KeyType) return false;
      if (CryptoKitID != other.CryptoKitID) return false;
      if (TimeCreated != other.TimeCreated) return false;
      if (PubKey != other.PubKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (KeyType != global::Ski.KeyType.Unspecified) hash ^= KeyType.GetHashCode();
      if (CryptoKitID != global::Ski.CryptoKitID.UnspecifiedCrypto) hash ^= CryptoKitID.GetHashCode();
      if (TimeCreated != 0L) hash ^= TimeCreated.GetHashCode();
      if (PubKey.Length != 0) hash ^= PubKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (KeyType != global::Ski.KeyType.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) KeyType);
      }
      if (CryptoKitID != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        output.WriteRawTag(16);
        output.WriteEnum((int) CryptoKitID);
      }
      if (TimeCreated != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TimeCreated);
      }
      if (PubKey.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(PubKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (KeyType != global::Ski.KeyType.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) KeyType);
      }
      if (CryptoKitID != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        output.WriteRawTag(16);
        output.WriteEnum((int) CryptoKitID);
      }
      if (TimeCreated != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TimeCreated);
      }
      if (PubKey.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(PubKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (KeyType != global::Ski.KeyType.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) KeyType);
      }
      if (CryptoKitID != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CryptoKitID);
      }
      if (TimeCreated != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TimeCreated);
      }
      if (PubKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PubKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(KeyInfo other) {
      if (other == null) {
        return;
      }
      if (other.KeyType != global::Ski.KeyType.Unspecified) {
        KeyType = other.KeyType;
      }
      if (other.CryptoKitID != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        CryptoKitID = other.CryptoKitID;
      }
      if (other.TimeCreated != 0L) {
        TimeCreated = other.TimeCreated;
      }
      if (other.PubKey.Length != 0) {
        PubKey = other.PubKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            KeyType = (global::Ski.KeyType) input.ReadEnum();
            break;
          }
          case 16: {
            CryptoKitID = (global::Ski.CryptoKitID) input.ReadEnum();
            break;
          }
          case 24: {
            TimeCreated = input.ReadInt64();
            break;
          }
          case 34: {
            PubKey = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            KeyType = (global::Ski.KeyType) input.ReadEnum();
            break;
          }
          case 16: {
            CryptoKitID = (global::Ski.CryptoKitID) input.ReadEnum();
            break;
          }
          case 24: {
            TimeCreated = input.ReadInt64();
            break;
          }
          case 34: {
            PubKey = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class KeyRef : pb::IMessage<KeyRef>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeyRef> _parser = new pb::MessageParser<KeyRef>(() => new KeyRef());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<KeyRef> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ski.AmpSkiReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyRef() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyRef(KeyRef other) : this() {
      keyringName_ = other.keyringName_;
      pubKey_ = other.pubKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyRef Clone() {
      return new KeyRef(this);
    }

    /// <summary>Field number for the "KeyringName" field.</summary>
    public const int KeyringNameFieldNumber = 1;
    private pb::ByteString keyringName_ = pb::ByteString.Empty;
    /// <summary>
    /// Specifies the Keyring that the key resides on (required when referencing a KeyEntry in a KeyTome).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString KeyringName {
      get { return keyringName_; }
      set {
        keyringName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "PubKey" field.</summary>
    public const int PubKeyFieldNumber = 2;
    private pb::ByteString pubKey_ = pb::ByteString.Empty;
    /// <summary>
    /// The pub key of the key being referenced (or len()==0 to imply the newest key in the cited keyring).
    /// Note that the complete pub key isn't required, just a sufficiently long matching prefix (typically 16-64 bytes).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PubKey {
      get { return pubKey_; }
      set {
        pubKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as KeyRef);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(KeyRef other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (KeyringName != other.KeyringName) return false;
      if (PubKey != other.PubKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (KeyringName.Length != 0) hash ^= KeyringName.GetHashCode();
      if (PubKey.Length != 0) hash ^= PubKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (KeyringName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(KeyringName);
      }
      if (PubKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(PubKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (KeyringName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(KeyringName);
      }
      if (PubKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(PubKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (KeyringName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(KeyringName);
      }
      if (PubKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PubKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(KeyRef other) {
      if (other == null) {
        return;
      }
      if (other.KeyringName.Length != 0) {
        KeyringName = other.KeyringName;
      }
      if (other.PubKey.Length != 0) {
        PubKey = other.PubKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            KeyringName = input.ReadBytes();
            break;
          }
          case 18: {
            PubKey = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            KeyringName = input.ReadBytes();
            break;
          }
          case 18: {
            PubKey = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// KeyEntry is used in 3 ways:
  ///    1) Storage/Export mode: used to store all fields of a fully generated key
  ///         - KeyEntry.PrivKey != nil
  ///    2) Ref/Spec mode: used to reference an existing key somewhere else
  ///         - KeyEntry.PrivKey == nil
  ///         - Fields used: KeyInfo.PubKey (other fields ignored)
  ///    3) GenerateKeys "guide" mode: KeyInfo used as a guide to generate a new key
  ///         - Fields used: KeyInfo.KeyType and KeyInfo.CryptoKitID (other fields ignored)
  /// </summary>
  public sealed partial class KeyEntry : pb::IMessage<KeyEntry>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeyEntry> _parser = new pb::MessageParser<KeyEntry>(() => new KeyEntry());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<KeyEntry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ski.AmpSkiReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyEntry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyEntry(KeyEntry other) : this() {
      keyInfo_ = other.keyInfo_ != null ? other.keyInfo_.Clone() : null;
      privKey_ = other.privKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyEntry Clone() {
      return new KeyEntry(this);
    }

    /// <summary>Field number for the "KeyInfo" field.</summary>
    public const int KeyInfoFieldNumber = 1;
    private global::Ski.KeyInfo keyInfo_;
    /// <summary>
    /// Info about this key
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ski.KeyInfo KeyInfo {
      get { return keyInfo_; }
      set {
        keyInfo_ = value;
      }
    }

    /// <summary>Field number for the "PrivKey" field.</summary>
    public const int PrivKeyFieldNumber = 6;
    private pb::ByteString privKey_ = pb::ByteString.Empty;
    /// <summary>
    /// Private part of the key -- should be used and copied carefully.
    /// When a KeyEntry is used to reference/specify an existing key, this field is not set and/or is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PrivKey {
      get { return privKey_; }
      set {
        privKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as KeyEntry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(KeyEntry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(KeyInfo, other.KeyInfo)) return false;
      if (PrivKey != other.PrivKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (keyInfo_ != null) hash ^= KeyInfo.GetHashCode();
      if (PrivKey.Length != 0) hash ^= PrivKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (keyInfo_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(KeyInfo);
      }
      if (PrivKey.Length != 0) {
        output.WriteRawTag(50);
        output.WriteBytes(PrivKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (keyInfo_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(KeyInfo);
      }
      if (PrivKey.Length != 0) {
        output.WriteRawTag(50);
        output.WriteBytes(PrivKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (keyInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeyInfo);
      }
      if (PrivKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PrivKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(KeyEntry other) {
      if (other == null) {
        return;
      }
      if (other.keyInfo_ != null) {
        if (keyInfo_ == null) {
          KeyInfo = new global::Ski.KeyInfo();
        }
        KeyInfo.MergeFrom(other.KeyInfo);
      }
      if (other.PrivKey.Length != 0) {
        PrivKey = other.PrivKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (keyInfo_ == null) {
              KeyInfo = new global::Ski.KeyInfo();
            }
            input.ReadMessage(KeyInfo);
            break;
          }
          case 50: {
            PrivKey = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (keyInfo_ == null) {
              KeyInfo = new global::Ski.KeyInfo();
            }
            input.ReadMessage(KeyInfo);
            break;
          }
          case 50: {
            PrivKey = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Keyring : pb::IMessage<Keyring>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Keyring> _parser = new pb::MessageParser<Keyring>(() => new Keyring());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Keyring> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ski.AmpSkiReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Keyring() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Keyring(Keyring other) : this() {
      name_ = other.name_;
      keys_ = other.keys_.Clone();
      sortedByPubKey_ = other.sortedByPubKey_;
      newestPubKey_ = other.newestPubKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Keyring Clone() {
      return new Keyring(this);
    }

    /// <summary>Field number for the "Name" field.</summary>
    public const int NameFieldNumber = 1;
    private pb::ByteString name_ = pb::ByteString.Empty;
    /// <summary>
    /// Any binary name for this Keyring (except a zero-length name).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "Keys" field.</summary>
    public const int KeysFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Ski.KeyEntry> _repeated_keys_codec
        = pb::FieldCodec.ForMessage(18, global::Ski.KeyEntry.Parser);
    private readonly pbc::RepeatedField<global::Ski.KeyEntry> keys_ = new pbc::RepeatedField<global::Ski.KeyEntry>();
    /// <summary>
    /// Ordered list of KeyEntry (potentially sorted by KeyInfo.PubKey)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Ski.KeyEntry> Keys {
      get { return keys_; }
    }

    /// <summary>Field number for the "SortedByPubKey" field.</summary>
    public const int SortedByPubKeyFieldNumber = 3;
    private bool sortedByPubKey_;
    /// <summary>
    /// If set, []Keys is sorted by KeyInfo.PubKey via ski.CompareEntries()
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SortedByPubKey {
      get { return sortedByPubKey_; }
      set {
        sortedByPubKey_ = value;
      }
    }

    /// <summary>Field number for the "NewestPubKey" field.</summary>
    public const int NewestPubKeyFieldNumber = 4;
    private pb::ByteString newestPubKey_ = pb::ByteString.Empty;
    /// <summary>
    /// PubKey of the KeyEntry in this keyring that has the largest TimeCreated (or nil if not known/determined)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString NewestPubKey {
      get { return newestPubKey_; }
      set {
        newestPubKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Keyring);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Keyring other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if(!keys_.Equals(other.keys_)) return false;
      if (SortedByPubKey != other.SortedByPubKey) return false;
      if (NewestPubKey != other.NewestPubKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= keys_.GetHashCode();
      if (SortedByPubKey != false) hash ^= SortedByPubKey.GetHashCode();
      if (NewestPubKey.Length != 0) hash ^= NewestPubKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Name);
      }
      keys_.WriteTo(output, _repeated_keys_codec);
      if (SortedByPubKey != false) {
        output.WriteRawTag(24);
        output.WriteBool(SortedByPubKey);
      }
      if (NewestPubKey.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(NewestPubKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Name);
      }
      keys_.WriteTo(ref output, _repeated_keys_codec);
      if (SortedByPubKey != false) {
        output.WriteRawTag(24);
        output.WriteBool(SortedByPubKey);
      }
      if (NewestPubKey.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(NewestPubKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Name);
      }
      size += keys_.CalculateSize(_repeated_keys_codec);
      if (SortedByPubKey != false) {
        size += 1 + 1;
      }
      if (NewestPubKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(NewestPubKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Keyring other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      keys_.Add(other.keys_);
      if (other.SortedByPubKey != false) {
        SortedByPubKey = other.SortedByPubKey;
      }
      if (other.NewestPubKey.Length != 0) {
        NewestPubKey = other.NewestPubKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadBytes();
            break;
          }
          case 18: {
            keys_.AddEntriesFrom(input, _repeated_keys_codec);
            break;
          }
          case 24: {
            SortedByPubKey = input.ReadBool();
            break;
          }
          case 34: {
            NewestPubKey = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadBytes();
            break;
          }
          case 18: {
            keys_.AddEntriesFrom(ref input, _repeated_keys_codec);
            break;
          }
          case 24: {
            SortedByPubKey = input.ReadBool();
            break;
          }
          case 34: {
            NewestPubKey = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class KeyTome : pb::IMessage<KeyTome>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeyTome> _parser = new pb::MessageParser<KeyTome>(() => new KeyTome());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<KeyTome> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ski.AmpSkiReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyTome() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyTome(KeyTome other) : this() {
      rev_ = other.rev_;
      keyrings_ = other.keyrings_.Clone();
      sortedByName_ = other.sortedByName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyTome Clone() {
      return new KeyTome(this);
    }

    /// <summary>Field number for the "Rev" field.</summary>
    public const int RevFieldNumber = 1;
    private long rev_;
    /// <summary>
    /// Incremented each time this KeyTome is altered.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Rev {
      get { return rev_; }
      set {
        rev_ = value;
      }
    }

    /// <summary>Field number for the "Keyrings" field.</summary>
    public const int KeyringsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Ski.Keyring> _repeated_keyrings_codec
        = pb::FieldCodec.ForMessage(18, global::Ski.Keyring.Parser);
    private readonly pbc::RepeatedField<global::Ski.Keyring> keyrings_ = new pbc::RepeatedField<global::Ski.Keyring>();
    /// <summary>
    /// Ordered list of Keyrings (potentially sorted by Keyring.Name)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Ski.Keyring> Keyrings {
      get { return keyrings_; }
    }

    /// <summary>Field number for the "SortedByName" field.</summary>
    public const int SortedByNameFieldNumber = 3;
    private bool sortedByName_;
    /// <summary>
    /// If set, []Keyrings is sorted by Keyring.Name via bytes.Compare()
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SortedByName {
      get { return sortedByName_; }
      set {
        sortedByName_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as KeyTome);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(KeyTome other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Rev != other.Rev) return false;
      if(!keyrings_.Equals(other.keyrings_)) return false;
      if (SortedByName != other.SortedByName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Rev != 0L) hash ^= Rev.GetHashCode();
      hash ^= keyrings_.GetHashCode();
      if (SortedByName != false) hash ^= SortedByName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Rev != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Rev);
      }
      keyrings_.WriteTo(output, _repeated_keyrings_codec);
      if (SortedByName != false) {
        output.WriteRawTag(24);
        output.WriteBool(SortedByName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Rev != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Rev);
      }
      keyrings_.WriteTo(ref output, _repeated_keyrings_codec);
      if (SortedByName != false) {
        output.WriteRawTag(24);
        output.WriteBool(SortedByName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Rev != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Rev);
      }
      size += keyrings_.CalculateSize(_repeated_keyrings_codec);
      if (SortedByName != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(KeyTome other) {
      if (other == null) {
        return;
      }
      if (other.Rev != 0L) {
        Rev = other.Rev;
      }
      keyrings_.Add(other.keyrings_);
      if (other.SortedByName != false) {
        SortedByName = other.SortedByName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Rev = input.ReadInt64();
            break;
          }
          case 18: {
            keyrings_.AddEntriesFrom(input, _repeated_keyrings_codec);
            break;
          }
          case 24: {
            SortedByName = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Rev = input.ReadInt64();
            break;
          }
          case 18: {
            keyrings_.AddEntriesFrom(ref input, _repeated_keyrings_codec);
            break;
          }
          case 24: {
            SortedByName = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class SigHeader : pb::IMessage<SigHeader>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SigHeader> _parser = new pb::MessageParser<SigHeader>(() => new SigHeader());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SigHeader> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ski.AmpSkiReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SigHeader() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SigHeader(SigHeader other) : this() {
      signerCryptoKit_ = other.signerCryptoKit_;
      signerPubKey_ = other.signerPubKey_;
      hashKitID_ = other.hashKitID_;
      headerSz_ = other.headerSz_;
      headerCodec_ = other.headerCodec_;
      bodySz_ = other.bodySz_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SigHeader Clone() {
      return new SigHeader(this);
    }

    /// <summary>Field number for the "SignerCryptoKit" field.</summary>
    public const int SignerCryptoKitFieldNumber = 1;
    private global::Ski.CryptoKitID signerCryptoKit_ = global::Ski.CryptoKitID.UnspecifiedCrypto;
    /// <summary>
    /// References a signing key -- who and what crypto kit signed the payload header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ski.CryptoKitID SignerCryptoKit {
      get { return signerCryptoKit_; }
      set {
        signerCryptoKit_ = value;
      }
    }

    /// <summary>Field number for the "SignerPubKey" field.</summary>
    public const int SignerPubKeyFieldNumber = 2;
    private pb::ByteString signerPubKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString SignerPubKey {
      get { return signerPubKey_; }
      set {
        signerPubKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "HashKitID" field.</summary>
    public const int HashKitIDFieldNumber = 6;
    private global::Ski.HashKitID hashKitID_ = global::Ski.HashKitID.UnspecifiedHashKit;
    /// <summary>
    /// Specifies which hash kit to use to perform payload hashing
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ski.HashKitID HashKitID {
      get { return hashKitID_; }
      set {
        hashKitID_ = value;
      }
    }

    /// <summary>Field number for the "HeaderSz" field.</summary>
    public const int HeaderSzFieldNumber = 7;
    private uint headerSz_;
    /// <summary>
    /// Size of the "header" payload (i.e. the payload that is also hashed and signed)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint HeaderSz {
      get { return headerSz_; }
      set {
        headerSz_ = value;
      }
    }

    /// <summary>Field number for the "HeaderCodec" field.</summary>
    public const int HeaderCodecFieldNumber = 8;
    private uint headerCodec_;
    /// <summary>
    /// HeaderCodec allows the client store/signal how it should be unmarshalled or handled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint HeaderCodec {
      get { return headerCodec_; }
      set {
        headerCodec_ = value;
      }
    }

    /// <summary>Field number for the "BodySz" field.</summary>
    public const int BodySzFieldNumber = 9;
    private ulong bodySz_;
    /// <summary>
    /// Size of the "body" payload (i.e. the payload that is NOT hashed signed)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong BodySz {
      get { return bodySz_; }
      set {
        bodySz_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SigHeader);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SigHeader other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SignerCryptoKit != other.SignerCryptoKit) return false;
      if (SignerPubKey != other.SignerPubKey) return false;
      if (HashKitID != other.HashKitID) return false;
      if (HeaderSz != other.HeaderSz) return false;
      if (HeaderCodec != other.HeaderCodec) return false;
      if (BodySz != other.BodySz) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (SignerCryptoKit != global::Ski.CryptoKitID.UnspecifiedCrypto) hash ^= SignerCryptoKit.GetHashCode();
      if (SignerPubKey.Length != 0) hash ^= SignerPubKey.GetHashCode();
      if (HashKitID != global::Ski.HashKitID.UnspecifiedHashKit) hash ^= HashKitID.GetHashCode();
      if (HeaderSz != 0) hash ^= HeaderSz.GetHashCode();
      if (HeaderCodec != 0) hash ^= HeaderCodec.GetHashCode();
      if (BodySz != 0UL) hash ^= BodySz.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (SignerCryptoKit != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        output.WriteRawTag(8);
        output.WriteEnum((int) SignerCryptoKit);
      }
      if (SignerPubKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(SignerPubKey);
      }
      if (HashKitID != global::Ski.HashKitID.UnspecifiedHashKit) {
        output.WriteRawTag(48);
        output.WriteEnum((int) HashKitID);
      }
      if (HeaderSz != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(HeaderSz);
      }
      if (HeaderCodec != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(HeaderCodec);
      }
      if (BodySz != 0UL) {
        output.WriteRawTag(72);
        output.WriteUInt64(BodySz);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (SignerCryptoKit != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        output.WriteRawTag(8);
        output.WriteEnum((int) SignerCryptoKit);
      }
      if (SignerPubKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(SignerPubKey);
      }
      if (HashKitID != global::Ski.HashKitID.UnspecifiedHashKit) {
        output.WriteRawTag(48);
        output.WriteEnum((int) HashKitID);
      }
      if (HeaderSz != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(HeaderSz);
      }
      if (HeaderCodec != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(HeaderCodec);
      }
      if (BodySz != 0UL) {
        output.WriteRawTag(72);
        output.WriteUInt64(BodySz);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (SignerCryptoKit != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SignerCryptoKit);
      }
      if (SignerPubKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SignerPubKey);
      }
      if (HashKitID != global::Ski.HashKitID.UnspecifiedHashKit) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HashKitID);
      }
      if (HeaderSz != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HeaderSz);
      }
      if (HeaderCodec != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HeaderCodec);
      }
      if (BodySz != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(BodySz);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SigHeader other) {
      if (other == null) {
        return;
      }
      if (other.SignerCryptoKit != global::Ski.CryptoKitID.UnspecifiedCrypto) {
        SignerCryptoKit = other.SignerCryptoKit;
      }
      if (other.SignerPubKey.Length != 0) {
        SignerPubKey = other.SignerPubKey;
      }
      if (other.HashKitID != global::Ski.HashKitID.UnspecifiedHashKit) {
        HashKitID = other.HashKitID;
      }
      if (other.HeaderSz != 0) {
        HeaderSz = other.HeaderSz;
      }
      if (other.HeaderCodec != 0) {
        HeaderCodec = other.HeaderCodec;
      }
      if (other.BodySz != 0UL) {
        BodySz = other.BodySz;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SignerCryptoKit = (global::Ski.CryptoKitID) input.ReadEnum();
            break;
          }
          case 18: {
            SignerPubKey = input.ReadBytes();
            break;
          }
          case 48: {
            HashKitID = (global::Ski.HashKitID) input.ReadEnum();
            break;
          }
          case 56: {
            HeaderSz = input.ReadUInt32();
            break;
          }
          case 64: {
            HeaderCodec = input.ReadUInt32();
            break;
          }
          case 72: {
            BodySz = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            SignerCryptoKit = (global::Ski.CryptoKitID) input.ReadEnum();
            break;
          }
          case 18: {
            SignerPubKey = input.ReadBytes();
            break;
          }
          case 48: {
            HashKitID = (global::Ski.HashKitID) input.ReadEnum();
            break;
          }
          case 56: {
            HeaderSz = input.ReadUInt32();
            break;
          }
          case 64: {
            HeaderCodec = input.ReadUInt32();
            break;
          }
          case 72: {
            BodySz = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class KeyTomeCrypt : pb::IMessage<KeyTomeCrypt>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeyTomeCrypt> _parser = new pb::MessageParser<KeyTomeCrypt>(() => new KeyTomeCrypt());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<KeyTomeCrypt> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ski.AmpSkiReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyTomeCrypt() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyTomeCrypt(KeyTomeCrypt other) : this() {
      tome_ = other.tome_;
      keyRef_ = other.keyRef_ != null ? other.keyRef_.Clone() : null;
      keyInfo_ = other.keyInfo_ != null ? other.keyInfo_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyTomeCrypt Clone() {
      return new KeyTomeCrypt(this);
    }

    /// <summary>Field number for the "Tome" field.</summary>
    public const int TomeFieldNumber = 1;
    private pb::ByteString tome_ = pb::ByteString.Empty;
    /// <summary>
    /// A serialized ski.KeyTome encrypted in accordance with the accompanying key params
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Tome {
      get { return tome_; }
      set {
        tome_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "KeyRef" field.</summary>
    public const int KeyRefFieldNumber = 10;
    private global::Ski.KeyRef keyRef_;
    /// <summary>
    /// Optional -- used to identify how (or with what key) the KeyTome in KeyTomeCrypt.Tpme is encrypted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ski.KeyRef KeyRef {
      get { return keyRef_; }
      set {
        keyRef_ = value;
      }
    }

    /// <summary>Field number for the "KeyInfo" field.</summary>
    public const int KeyInfoFieldNumber = 11;
    private global::Ski.KeyInfo keyInfo_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ski.KeyInfo KeyInfo {
      get { return keyInfo_; }
      set {
        keyInfo_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as KeyTomeCrypt);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(KeyTomeCrypt other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Tome != other.Tome) return false;
      if (!object.Equals(KeyRef, other.KeyRef)) return false;
      if (!object.Equals(KeyInfo, other.KeyInfo)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Tome.Length != 0) hash ^= Tome.GetHashCode();
      if (keyRef_ != null) hash ^= KeyRef.GetHashCode();
      if (keyInfo_ != null) hash ^= KeyInfo.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Tome.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Tome);
      }
      if (keyRef_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(KeyRef);
      }
      if (keyInfo_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(KeyInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Tome.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Tome);
      }
      if (keyRef_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(KeyRef);
      }
      if (keyInfo_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(KeyInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Tome.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Tome);
      }
      if (keyRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeyRef);
      }
      if (keyInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeyInfo);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(KeyTomeCrypt other) {
      if (other == null) {
        return;
      }
      if (other.Tome.Length != 0) {
        Tome = other.Tome;
      }
      if (other.keyRef_ != null) {
        if (keyRef_ == null) {
          KeyRef = new global::Ski.KeyRef();
        }
        KeyRef.MergeFrom(other.KeyRef);
      }
      if (other.keyInfo_ != null) {
        if (keyInfo_ == null) {
          KeyInfo = new global::Ski.KeyInfo();
        }
        KeyInfo.MergeFrom(other.KeyInfo);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Tome = input.ReadBytes();
            break;
          }
          case 82: {
            if (keyRef_ == null) {
              KeyRef = new global::Ski.KeyRef();
            }
            input.ReadMessage(KeyRef);
            break;
          }
          case 90: {
            if (keyInfo_ == null) {
              KeyInfo = new global::Ski.KeyInfo();
            }
            input.ReadMessage(KeyInfo);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Tome = input.ReadBytes();
            break;
          }
          case 82: {
            if (keyRef_ == null) {
              KeyRef = new global::Ski.KeyRef();
            }
            input.ReadMessage(KeyRef);
            break;
          }
          case 90: {
            if (keyInfo_ == null) {
              KeyInfo = new global::Ski.KeyInfo();
            }
            input.ReadMessage(KeyInfo);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
