// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: amp.ski.proto

package ski

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// KeyForm identifies how a key operates
type KeyForm int32

const (
	KeyForm_Unspecified   KeyForm = 0
	KeyForm_SymmetricKey  KeyForm = 1
	KeyForm_AsymmetricKey KeyForm = 2
	KeyForm_SigningKey    KeyForm = 3
)

var KeyForm_name = map[int32]string{
	0: "KeyForm_Unspecified",
	1: "KeyForm_SymmetricKey",
	2: "KeyForm_AsymmetricKey",
	3: "KeyForm_SigningKey",
}

var KeyForm_value = map[string]int32{
	"KeyForm_Unspecified":   0,
	"KeyForm_SymmetricKey":  1,
	"KeyForm_AsymmetricKey": 2,
	"KeyForm_SigningKey":    3,
}

func (KeyForm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{0}
}

// CryptoKitID identifies an encryption suite that implements ski.CryptoKit
type CryptoKitID int32

const (
	CryptoKitID_UnspecifiedCrypto CryptoKitID = 0
	CryptoKitID_NaCl              CryptoKitID = 1
	CryptoKitID_ED25519           CryptoKitID = 2
)

var CryptoKitID_name = map[int32]string{
	0: "CryptoKitID_UnspecifiedCrypto",
	1: "CryptoKitID_NaCl",
	2: "CryptoKitID_ED25519",
}

var CryptoKitID_value = map[string]int32{
	"CryptoKitID_UnspecifiedCrypto": 0,
	"CryptoKitID_NaCl":              1,
	"CryptoKitID_ED25519":           2,
}

func (CryptoKitID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{1}
}

// CryptoKitID identifies a hash algorithm that implements ski.HaskKit
type HashKitID int32

const (
	HashKitID_UnspecifiedHashKit HashKitID = 0
	HashKitID_LegacyKeccak_256   HashKitID = 1
	HashKitID_LegacyKeccak_512   HashKitID = 2
	HashKitID_SHA3_256           HashKitID = 3
	HashKitID_SHA3_512           HashKitID = 4
	HashKitID_Blake2b_256        HashKitID = 5
	HashKitID_Blake2b_512        HashKitID = 6
)

var HashKitID_name = map[int32]string{
	0: "HashKitID_UnspecifiedHashKit",
	1: "HashKitID_LegacyKeccak_256",
	2: "HashKitID_LegacyKeccak_512",
	3: "HashKitID_SHA3_256",
	4: "HashKitID_SHA3_512",
	5: "HashKitID_Blake2b_256",
	6: "HashKitID_Blake2b_512",
}

var HashKitID_value = map[string]int32{
	"HashKitID_UnspecifiedHashKit": 0,
	"HashKitID_LegacyKeccak_256":   1,
	"HashKitID_LegacyKeccak_512":   2,
	"HashKitID_SHA3_256":           3,
	"HashKitID_SHA3_512":           4,
	"HashKitID_Blake2b_256":        5,
	"HashKitID_Blake2b_512":        6,
}

func (HashKitID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{2}
}

type CryptOp int32

const (
	// Generates a signature for BufIn using the referenced signing key, placing the signature into BufOut.
	CryptOp_Sign CryptOp = 0
	// Inverse of DecryptSym
	// Encrypts BufIn using the symmetric key referenced by OpKey.
	CryptOp_EncryptSym CryptOp = 1
	// Inverse of EncryptSym
	// Decrypts BufIn using the symmetric key referenced by OpKey.
	CryptOp_DecryptSym CryptOp = 2
	// Encrypts BufIn for a recipient holding the private key associated with the pub key contained in PeerKey,
	//    encrypting using the referenced asymmetric key and placing the encrypted result into BufOut.
	CryptOp_EncryptToPeer CryptOp = 3
	// Decrypts BufIn from a sender holding the private key associated with the pub key contained in PeerKey,
	//    decrypting using the referenced asymmetric key and placing the decrypted result into BufOut.
	CryptOp_DecryptFromPeer CryptOp = 4
	// Inverse of ExportUsingPw
	// Identical to ImportFromPeer except that BufIn is instead decrypted via CryptoKit.DecryptUsingPassword(),
	//    using CryptOp.PeerKey as a the password.  The CryptoKit invoked is determined by CryptOpArgs.DefaultCryptoKit.
	CryptOp_ImportUsingPw CryptOp = 5
	// Inverse of ImportUsingPw
	// Identical to ExportToPeer except the output serialized KeyTome is encrypted via CryptoKit.EncryptUsingPassword(),
	//    using CryptOp.PeerKey as a the password.  The CryptoKit invoked is determined by CryptOpArgs.DefaultCryptoKit.
	CryptOp_ExportUsingPw CryptOp = 6
	// Inverse of ExportToPeer
	// First, performs as DecryptFromPeer.
	// The result/output buf is then unmarshalled (assumed to be a ski.KeyTome protobuf) and is merged into the host KeyTome.
	// See ski.ImportKeys() for how the incoming KeyTome is merged into the host KeyTome.
	CryptOp_ImportFromPeer CryptOp = 7
	// Inverse of ImportFromPeer
	// For each entry in CryptOpArgs.TomeIn, PubKey is used to lookup a corresponding KeyEntry in the host KeyTome.
	// Each KeyEntry with a matching PubKey is copied into a new temp KeyTome, into the appropriate Keyring,
	//    creating a Keyring if it does not yet exist.
	// If a Keyring appears in CryptOpArgs.TomeIn but contains no entries, the entire Keyring will be exported.
	// If a Keyring or KeyEntry from TomeIn isn't found, an error is returned.
	// See KeyTome.ExportUsingGuide() for how TomeIn is handled.
	// On completion, the temp KeyTome is serialized, assigned to CryptOpArgs.BufIn, and EncryptToPeer is executed.
	CryptOp_ExportToPeer CryptOp = 8
)

var CryptOp_name = map[int32]string{
	0: "CryptOp_Sign",
	1: "CryptOp_EncryptSym",
	2: "CryptOp_DecryptSym",
	3: "CryptOp_EncryptToPeer",
	4: "CryptOp_DecryptFromPeer",
	5: "CryptOp_ImportUsingPw",
	6: "CryptOp_ExportUsingPw",
	7: "CryptOp_ImportFromPeer",
	8: "CryptOp_ExportToPeer",
}

var CryptOp_value = map[string]int32{
	"CryptOp_Sign":            0,
	"CryptOp_EncryptSym":      1,
	"CryptOp_DecryptSym":      2,
	"CryptOp_EncryptToPeer":   3,
	"CryptOp_DecryptFromPeer": 4,
	"CryptOp_ImportUsingPw":   5,
	"CryptOp_ExportUsingPw":   6,
	"CryptOp_ImportFromPeer":  7,
	"CryptOp_ExportToPeer":    8,
}

func (CryptOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{3}
}

type CryptOpArgs struct {
	// Specifies which op to invoke for these given set of args
	CryptOp CryptOp `protobuf:"varint,1,opt,name=CryptOp,proto3,enum=ski.CryptOp" json:"CryptOp,omitempty"`
	// Specifies the default CryptoKit for ops when not specified.
	DefaultCryptoKit CryptoKitID `protobuf:"varint,2,opt,name=DefaultCryptoKit,proto3,enum=ski.CryptoKitID" json:"DefaultCryptoKit,omitempty"`
	// The source/input buffer that is signed/encrypted/decrypted.
	BufIn []byte `protobuf:"bytes,3,opt,name=BufIn,proto3" json:"BufIn,omitempty"`
	// A reference to an existing KeyEntry in the host's KeyTome used as the key for this op's encryption/decryption.
	OpKey *KeyRef `protobuf:"bytes,4,opt,name=OpKey,proto3" json:"OpKey,omitempty"`
	// For EncryptToPeer and ExportToPeer, this is what the recipient will use for OpKey.PubKey.
	// For DecryptFromPeer and ImportFromPeer, this is what the sender used for OpKey.PubKey.
	// For ImportUsingPw and ExportUsingPw, this is the password.
	PeerKey []byte `protobuf:"bytes,5,opt,name=PeerKey,proto3" json:"PeerKey,omitempty"`
	// Keyring and key info used to identify existing (or to-be-created) keys in the host's KeyTome.
	// Used for ExportToPeer and GenerateKeys().
	TomeIn *KeyTome `protobuf:"bytes,6,opt,name=TomeIn,proto3" json:"TomeIn,omitempty"`
}

func (m *CryptOpArgs) Reset()      { *m = CryptOpArgs{} }
func (*CryptOpArgs) ProtoMessage() {}
func (*CryptOpArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{0}
}
func (m *CryptOpArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptOpArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptOpArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptOpArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptOpArgs.Merge(m, src)
}
func (m *CryptOpArgs) XXX_Size() int {
	return m.Size()
}
func (m *CryptOpArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptOpArgs.DiscardUnknown(m)
}

var xxx_messageInfo_CryptOpArgs proto.InternalMessageInfo

func (m *CryptOpArgs) GetCryptOp() CryptOp {
	if m != nil {
		return m.CryptOp
	}
	return CryptOp_Sign
}

func (m *CryptOpArgs) GetDefaultCryptoKit() CryptoKitID {
	if m != nil {
		return m.DefaultCryptoKit
	}
	return CryptoKitID_UnspecifiedCrypto
}

func (m *CryptOpArgs) GetBufIn() []byte {
	if m != nil {
		return m.BufIn
	}
	return nil
}

func (m *CryptOpArgs) GetOpKey() *KeyRef {
	if m != nil {
		return m.OpKey
	}
	return nil
}

func (m *CryptOpArgs) GetPeerKey() []byte {
	if m != nil {
		return m.PeerKey
	}
	return nil
}

func (m *CryptOpArgs) GetTomeIn() *KeyTome {
	if m != nil {
		return m.TomeIn
	}
	return nil
}

type CryptOpOut struct {
	// Output buf from the given crypto op (and depends on the given CryptOp)
	BufOut []byte `protobuf:"bytes,1,opt,name=BufOut,proto3" json:"BufOut,omitempty"`
	// Returns the pub key used in the op (needed when CryptOpArgs.OpKey.PubKey wasn't specified)
	OpPubKey []byte `protobuf:"bytes,2,opt,name=OpPubKey,proto3" json:"OpPubKey,omitempty"`
}

func (m *CryptOpOut) Reset()      { *m = CryptOpOut{} }
func (*CryptOpOut) ProtoMessage() {}
func (*CryptOpOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{1}
}
func (m *CryptOpOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptOpOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptOpOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptOpOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptOpOut.Merge(m, src)
}
func (m *CryptOpOut) XXX_Size() int {
	return m.Size()
}
func (m *CryptOpOut) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptOpOut.DiscardUnknown(m)
}

var xxx_messageInfo_CryptOpOut proto.InternalMessageInfo

func (m *CryptOpOut) GetBufOut() []byte {
	if m != nil {
		return m.BufOut
	}
	return nil
}

func (m *CryptOpOut) GetOpPubKey() []byte {
	if m != nil {
		return m.OpPubKey
	}
	return nil
}

// KeyInfo specifies info an existing KeyEntry or and KeyEntry this is to be created.
//
// KeyInfo exists in two modes/uses:
//  1. Generated/copied from an existing KeyEntry
//  2. Key gen mode: used as a guide to generate a new key
//     a) Fields used: KeyForm and CryptoKitID (other fields ignored)
type KeyInfo struct {
	// Specifies the type of key this is (optional)
	KeyForm KeyForm `protobuf:"varint,1,opt,name=KeyForm,proto3,enum=ski.KeyForm" json:"KeyForm,omitempty"`
	// Specifies which crypto suite to invoke.
	CryptoKitID CryptoKitID `protobuf:"varint,2,opt,name=CryptoKitID,proto3,enum=ski.CryptoKitID" json:"CryptoKitID,omitempty"`
	// Unix timestamp << 16 ("UTC16") when this key was created (or 0 if not set)
	TimeCreated int64 `protobuf:"varint,3,opt,name=TimeCreated,proto3" json:"TimeCreated,omitempty"`
	// Public part of the key; how this key is also referenced publicly (in base-256 form)
	PubKey []byte `protobuf:"bytes,4,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
}

func (m *KeyInfo) Reset()      { *m = KeyInfo{} }
func (*KeyInfo) ProtoMessage() {}
func (*KeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{2}
}
func (m *KeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyInfo.Merge(m, src)
}
func (m *KeyInfo) XXX_Size() int {
	return m.Size()
}
func (m *KeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_KeyInfo proto.InternalMessageInfo

func (m *KeyInfo) GetKeyForm() KeyForm {
	if m != nil {
		return m.KeyForm
	}
	return KeyForm_Unspecified
}

func (m *KeyInfo) GetCryptoKitID() CryptoKitID {
	if m != nil {
		return m.CryptoKitID
	}
	return CryptoKitID_UnspecifiedCrypto
}

func (m *KeyInfo) GetTimeCreated() int64 {
	if m != nil {
		return m.TimeCreated
	}
	return 0
}

func (m *KeyInfo) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

type KeyRef struct {
	// Specifies the Keyring that the key resides on (required when referencing a KeyEntry in a KeyTome).
	KeyringName []byte `protobuf:"bytes,1,opt,name=KeyringName,proto3" json:"KeyringName,omitempty"`
	// The pub key of the key being referenced (or len()==0 to imply the newest key in the cited keyring).
	// Note that the complete pub key isn't required, just a sufficiently long matching prefix (typically 16-64 bytes).
	PubKey []byte `protobuf:"bytes,2,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
}

func (m *KeyRef) Reset()      { *m = KeyRef{} }
func (*KeyRef) ProtoMessage() {}
func (*KeyRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{3}
}
func (m *KeyRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRef.Merge(m, src)
}
func (m *KeyRef) XXX_Size() int {
	return m.Size()
}
func (m *KeyRef) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRef.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRef proto.InternalMessageInfo

func (m *KeyRef) GetKeyringName() []byte {
	if m != nil {
		return m.KeyringName
	}
	return nil
}

func (m *KeyRef) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

// KeyEntry is used in 3 ways:
//  1. Storage/Export mode: used to store all fields of a fully generated key
//     - KeyEntry.PrivKey != nil
//  2. Ref/Spec mode: used to reference an existing key somewhere else
//     - KeyEntry.PrivKey == nil
//     - Fields used: KeyInfo.PubKey (other fields ignored)
//  3. GenerateKeys "guide" mode: KeyInfo used as a guide to generate a new key
//     - Fields used: KeyInfo.KeyForm and KeyInfo.CryptoKitID (other fields ignored)
type KeyEntry struct {
	// Info about this key
	KeyInfo *KeyInfo `protobuf:"bytes,1,opt,name=KeyInfo,proto3" json:"KeyInfo,omitempty"`
	// Private part of the key -- should be used and copied carefully.
	// When a KeyEntry is used to reference/specify an existing key, this field is not set and/or is ignored.
	PrivKey []byte `protobuf:"bytes,6,opt,name=PrivKey,proto3" json:"PrivKey,omitempty"`
}

func (m *KeyEntry) Reset()      { *m = KeyEntry{} }
func (*KeyEntry) ProtoMessage() {}
func (*KeyEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{4}
}
func (m *KeyEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyEntry.Merge(m, src)
}
func (m *KeyEntry) XXX_Size() int {
	return m.Size()
}
func (m *KeyEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyEntry.DiscardUnknown(m)
}

var xxx_messageInfo_KeyEntry proto.InternalMessageInfo

func (m *KeyEntry) GetKeyInfo() *KeyInfo {
	if m != nil {
		return m.KeyInfo
	}
	return nil
}

func (m *KeyEntry) GetPrivKey() []byte {
	if m != nil {
		return m.PrivKey
	}
	return nil
}

type Keyring struct {
	// Any binary name for this Keyring (except a zero-length name).
	Name []byte `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// Ordered list of KeyEntry (potentially sorted by KeyInfo.PubKey)
	Keys []*KeyEntry `protobuf:"bytes,2,rep,name=Keys,proto3" json:"Keys,omitempty"`
	// If set, []Keys is sorted by KeyInfo.PubKey via ski.CompareEntries()
	SortedByPubKey bool `protobuf:"varint,3,opt,name=SortedByPubKey,proto3" json:"SortedByPubKey,omitempty"`
	// PubKey of the KeyEntry in this keyring that has the largest TimeCreated (or nil if not known/determined)
	NewestPubKey []byte `protobuf:"bytes,4,opt,name=NewestPubKey,proto3" json:"NewestPubKey,omitempty"`
}

func (m *Keyring) Reset()      { *m = Keyring{} }
func (*Keyring) ProtoMessage() {}
func (*Keyring) Descriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{5}
}
func (m *Keyring) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Keyring) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Keyring.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Keyring) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Keyring.Merge(m, src)
}
func (m *Keyring) XXX_Size() int {
	return m.Size()
}
func (m *Keyring) XXX_DiscardUnknown() {
	xxx_messageInfo_Keyring.DiscardUnknown(m)
}

var xxx_messageInfo_Keyring proto.InternalMessageInfo

func (m *Keyring) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *Keyring) GetKeys() []*KeyEntry {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Keyring) GetSortedByPubKey() bool {
	if m != nil {
		return m.SortedByPubKey
	}
	return false
}

func (m *Keyring) GetNewestPubKey() []byte {
	if m != nil {
		return m.NewestPubKey
	}
	return nil
}

type KeyTome struct {
	// Incremented each time this KeyTome is altered.
	Rev int64 `protobuf:"varint,1,opt,name=Rev,proto3" json:"Rev,omitempty"`
	// Ordered list of Keyrings (potentially sorted by Keyring.Name)
	Keyrings []*Keyring `protobuf:"bytes,2,rep,name=Keyrings,proto3" json:"Keyrings,omitempty"`
	// If set, []Keyrings is sorted by Keyring.Name via bytes.Compare()
	SortedByName bool `protobuf:"varint,3,opt,name=SortedByName,proto3" json:"SortedByName,omitempty"`
}

func (m *KeyTome) Reset()      { *m = KeyTome{} }
func (*KeyTome) ProtoMessage() {}
func (*KeyTome) Descriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{6}
}
func (m *KeyTome) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyTome) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyTome.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyTome) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyTome.Merge(m, src)
}
func (m *KeyTome) XXX_Size() int {
	return m.Size()
}
func (m *KeyTome) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyTome.DiscardUnknown(m)
}

var xxx_messageInfo_KeyTome proto.InternalMessageInfo

func (m *KeyTome) GetRev() int64 {
	if m != nil {
		return m.Rev
	}
	return 0
}

func (m *KeyTome) GetKeyrings() []*Keyring {
	if m != nil {
		return m.Keyrings
	}
	return nil
}

func (m *KeyTome) GetSortedByName() bool {
	if m != nil {
		return m.SortedByName
	}
	return false
}

type SigHeader struct {
	// References a signing key -- who and what crypto kit signed the payload header.
	SignerCryptoKit CryptoKitID `protobuf:"varint,1,opt,name=SignerCryptoKit,proto3,enum=ski.CryptoKitID" json:"SignerCryptoKit,omitempty"`
	SignerPubKey    []byte      `protobuf:"bytes,2,opt,name=SignerPubKey,proto3" json:"SignerPubKey,omitempty"`
	// Specifies which hash kit to use to perform payload hashing
	HashKitID HashKitID `protobuf:"varint,6,opt,name=HashKitID,proto3,enum=ski.HashKitID" json:"HashKitID,omitempty"`
	// Size of the "header" payload (i.e. the payload that is also hashed and signed)
	HeaderSz uint32 `protobuf:"varint,7,opt,name=HeaderSz,proto3" json:"HeaderSz,omitempty"`
	// HeaderCodec allows the client store/signal how it should be unmarshalled or handled.
	HeaderCodec uint32 `protobuf:"varint,8,opt,name=HeaderCodec,proto3" json:"HeaderCodec,omitempty"`
	// Size of the "body" payload (i.e. the payload that is NOT hashed signed)
	BodySz uint64 `protobuf:"varint,9,opt,name=BodySz,proto3" json:"BodySz,omitempty"`
}

func (m *SigHeader) Reset()      { *m = SigHeader{} }
func (*SigHeader) ProtoMessage() {}
func (*SigHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{7}
}
func (m *SigHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigHeader.Merge(m, src)
}
func (m *SigHeader) XXX_Size() int {
	return m.Size()
}
func (m *SigHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_SigHeader.DiscardUnknown(m)
}

var xxx_messageInfo_SigHeader proto.InternalMessageInfo

func (m *SigHeader) GetSignerCryptoKit() CryptoKitID {
	if m != nil {
		return m.SignerCryptoKit
	}
	return CryptoKitID_UnspecifiedCrypto
}

func (m *SigHeader) GetSignerPubKey() []byte {
	if m != nil {
		return m.SignerPubKey
	}
	return nil
}

func (m *SigHeader) GetHashKitID() HashKitID {
	if m != nil {
		return m.HashKitID
	}
	return HashKitID_UnspecifiedHashKit
}

func (m *SigHeader) GetHeaderSz() uint32 {
	if m != nil {
		return m.HeaderSz
	}
	return 0
}

func (m *SigHeader) GetHeaderCodec() uint32 {
	if m != nil {
		return m.HeaderCodec
	}
	return 0
}

func (m *SigHeader) GetBodySz() uint64 {
	if m != nil {
		return m.BodySz
	}
	return 0
}

type KeyTomeCrypt struct {
	// A serialized ski.KeyTome encrypted in accordance with the accompanying key params
	Tome []byte `protobuf:"bytes,1,opt,name=Tome,proto3" json:"Tome,omitempty"`
	// Optional -- used to identify how (or with what key) the KeyTome in KeyTomeCrypt.Tpme is encrypted.
	KeyRef  *KeyRef  `protobuf:"bytes,10,opt,name=KeyRef,proto3" json:"KeyRef,omitempty"`
	KeyInfo *KeyInfo `protobuf:"bytes,11,opt,name=KeyInfo,proto3" json:"KeyInfo,omitempty"`
}

func (m *KeyTomeCrypt) Reset()      { *m = KeyTomeCrypt{} }
func (*KeyTomeCrypt) ProtoMessage() {}
func (*KeyTomeCrypt) Descriptor() ([]byte, []int) {
	return fileDescriptor_3fbac0f28ceb772b, []int{8}
}
func (m *KeyTomeCrypt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyTomeCrypt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyTomeCrypt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyTomeCrypt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyTomeCrypt.Merge(m, src)
}
func (m *KeyTomeCrypt) XXX_Size() int {
	return m.Size()
}
func (m *KeyTomeCrypt) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyTomeCrypt.DiscardUnknown(m)
}

var xxx_messageInfo_KeyTomeCrypt proto.InternalMessageInfo

func (m *KeyTomeCrypt) GetTome() []byte {
	if m != nil {
		return m.Tome
	}
	return nil
}

func (m *KeyTomeCrypt) GetKeyRef() *KeyRef {
	if m != nil {
		return m.KeyRef
	}
	return nil
}

func (m *KeyTomeCrypt) GetKeyInfo() *KeyInfo {
	if m != nil {
		return m.KeyInfo
	}
	return nil
}

func init() {
	proto.RegisterEnum("ski.KeyForm", KeyForm_name, KeyForm_value)
	proto.RegisterEnum("ski.CryptoKitID", CryptoKitID_name, CryptoKitID_value)
	proto.RegisterEnum("ski.HashKitID", HashKitID_name, HashKitID_value)
	proto.RegisterEnum("ski.CryptOp", CryptOp_name, CryptOp_value)
	proto.RegisterType((*CryptOpArgs)(nil), "ski.CryptOpArgs")
	proto.RegisterType((*CryptOpOut)(nil), "ski.CryptOpOut")
	proto.RegisterType((*KeyInfo)(nil), "ski.KeyInfo")
	proto.RegisterType((*KeyRef)(nil), "ski.KeyRef")
	proto.RegisterType((*KeyEntry)(nil), "ski.KeyEntry")
	proto.RegisterType((*Keyring)(nil), "ski.Keyring")
	proto.RegisterType((*KeyTome)(nil), "ski.KeyTome")
	proto.RegisterType((*SigHeader)(nil), "ski.SigHeader")
	proto.RegisterType((*KeyTomeCrypt)(nil), "ski.KeyTomeCrypt")
}

func init() { proto.RegisterFile("amp.ski.proto", fileDescriptor_3fbac0f28ceb772b) }

var fileDescriptor_3fbac0f28ceb772b = []byte{
	// 906 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0xe6, 0x8a, 0x32, 0x25, 0x8f, 0x64, 0x97, 0xd8, 0xba, 0x0e, 0xeb, 0xb6, 0x84, 0xac, 0x16,
	0x81, 0x60, 0x14, 0x01, 0xa2, 0xd4, 0x05, 0x5a, 0xf4, 0x50, 0xcb, 0x76, 0x60, 0x81, 0x81, 0x65,
	0xac, 0x9c, 0xb3, 0x41, 0x4b, 0x2b, 0x95, 0xb0, 0x49, 0x0a, 0x24, 0x95, 0x94, 0x39, 0xf5, 0x01,
	0x7a, 0xe8, 0x1b, 0xf4, 0xda, 0x47, 0xe9, 0xd1, 0x40, 0x2f, 0x39, 0xd6, 0xf2, 0xa5, 0x87, 0x02,
	0xc9, 0x23, 0x04, 0xb3, 0x5c, 0x52, 0x4b, 0x25, 0xf1, 0x6d, 0xe7, 0x9b, 0xbf, 0x6f, 0xbe, 0x9d,
	0xc5, 0xc2, 0x86, 0xeb, 0xcf, 0x1e, 0xc5, 0x57, 0xde, 0xa3, 0x59, 0x14, 0x26, 0x21, 0xd5, 0xe3,
	0x2b, 0xaf, 0xfd, 0x3f, 0x81, 0xc6, 0x61, 0x94, 0xce, 0x92, 0xc1, 0xec, 0x20, 0x9a, 0xc6, 0xf4,
	0x21, 0xd4, 0xa4, 0x69, 0x91, 0x16, 0xe9, 0x6c, 0x76, 0x9b, 0x22, 0x43, 0x62, 0x2c, 0x77, 0xd2,
	0x9f, 0xc0, 0x3c, 0xe2, 0x13, 0x77, 0x7e, 0x9d, 0x08, 0x24, 0x74, 0xbc, 0xc4, 0xaa, 0x88, 0x04,
	0x73, 0x99, 0x80, 0x68, 0xff, 0x88, 0xbd, 0x17, 0x49, 0xb7, 0x60, 0xad, 0x37, 0x9f, 0xf4, 0x03,
	0x4b, 0x6f, 0x91, 0x4e, 0x93, 0x65, 0x06, 0xdd, 0x85, 0xb5, 0xc1, 0xcc, 0xe1, 0xa9, 0x55, 0x6d,
	0x91, 0x4e, 0xa3, 0xdb, 0x10, 0x85, 0x1c, 0x9e, 0x32, 0x3e, 0x61, 0x99, 0x87, 0x5a, 0x50, 0x3b,
	0xe3, 0x3c, 0xc2, 0xa0, 0x35, 0x91, 0x9a, 0x9b, 0xf4, 0x1b, 0x30, 0xce, 0x43, 0x9f, 0xf7, 0x03,
	0xcb, 0x10, 0xd9, 0xcd, 0x3c, 0x1b, 0x51, 0x26, 0x7d, 0xed, 0x9f, 0x01, 0xe4, 0x04, 0x83, 0x79,
	0x42, 0xb7, 0xc1, 0xe8, 0xcd, 0x27, 0x83, 0x79, 0x22, 0x66, 0x6d, 0x32, 0x69, 0xd1, 0x1d, 0xa8,
	0x0f, 0x66, 0x67, 0xf3, 0x4b, 0x6c, 0x53, 0x11, 0x9e, 0xc2, 0x6e, 0xff, 0x49, 0xa0, 0xe6, 0xf0,
	0xb4, 0x1f, 0x4c, 0x42, 0x14, 0xcb, 0xe1, 0xe9, 0xd3, 0x30, 0xf2, 0x4b, 0x62, 0x49, 0x8c, 0xe5,
	0x4e, 0xda, 0x95, 0x1a, 0x67, 0x7a, 0x7c, 0x54, 0x27, 0x35, 0x88, 0xb6, 0xa0, 0x71, 0xee, 0xf9,
	0xfc, 0x30, 0xe2, 0x6e, 0xc2, 0xc7, 0x42, 0x28, 0x9d, 0xa9, 0x10, 0xb2, 0x97, 0x1c, 0xab, 0x19,
	0x7b, 0xc9, 0xb0, 0x07, 0x46, 0x26, 0x1a, 0xd6, 0x70, 0x78, 0x1a, 0x79, 0xc1, 0xf4, 0xd4, 0xf5,
	0xb9, 0x1c, 0x52, 0x85, 0x94, 0x1a, 0x95, 0x52, 0x8d, 0x67, 0x50, 0x77, 0x78, 0x7a, 0x1c, 0x24,
	0x51, 0x2a, 0xa7, 0xc4, 0x81, 0x45, 0x05, 0x45, 0x5a, 0xc4, 0x58, 0xa1, 0x06, 0xde, 0x4d, 0xe4,
	0xbd, 0xc0, 0x62, 0x86, 0xbc, 0x9b, 0xcc, 0x6c, 0xff, 0x9e, 0x69, 0x86, 0x5d, 0x29, 0x85, 0xaa,
	0x42, 0x46, 0x9c, 0xe9, 0x2e, 0x54, 0x1d, 0x9e, 0xc6, 0x56, 0xa5, 0xa5, 0x77, 0x1a, 0xdd, 0x8d,
	0xbc, 0xbc, 0x68, 0xcf, 0x84, 0x8b, 0x3e, 0x84, 0xcd, 0x61, 0x18, 0x25, 0x7c, 0xdc, 0x4b, 0x25,
	0x61, 0x54, 0xa4, 0xce, 0x56, 0x50, 0xda, 0x86, 0xe6, 0x29, 0x7f, 0xc9, 0xe3, 0xa4, 0x24, 0x4d,
	0x09, 0x6b, 0x7b, 0x82, 0x0d, 0x6e, 0x04, 0x35, 0x41, 0x67, 0xfc, 0x85, 0x20, 0xa3, 0x33, 0x3c,
	0xd2, 0x8e, 0x98, 0x1c, 0xa9, 0xe6, 0x7c, 0x8a, 0x71, 0x11, 0x64, 0x85, 0x17, 0x5b, 0xe5, 0xcd,
	0xc5, 0x44, 0x19, 0xa1, 0x12, 0xd6, 0x7e, 0x43, 0x60, 0x7d, 0xe8, 0x4d, 0x4f, 0xb8, 0x3b, 0xe6,
	0x11, 0xfd, 0x11, 0x3e, 0x19, 0x7a, 0xd3, 0x80, 0x47, 0xcb, 0x37, 0x43, 0x3e, 0xb2, 0x0b, 0xab,
	0x81, 0xa2, 0x9b, 0x80, 0x4a, 0xf7, 0x55, 0xc2, 0xe8, 0xb7, 0xb0, 0x7e, 0xe2, 0xc6, 0xbf, 0x64,
	0x5b, 0x66, 0x88, 0xca, 0x9b, 0xa2, 0x72, 0x81, 0xb2, 0x65, 0x00, 0x6e, 0x79, 0xc6, 0x6b, 0xf8,
	0xca, 0xaa, 0xb5, 0x48, 0x67, 0x83, 0x15, 0x36, 0x6e, 0x4e, 0x76, 0x3e, 0x0c, 0xc7, 0x7c, 0x64,
	0xd5, 0x85, 0x5b, 0x85, 0xc4, 0xdb, 0x09, 0xc7, 0xe9, 0xf0, 0x95, 0xb5, 0xde, 0x22, 0x9d, 0x2a,
	0x93, 0x56, 0x3b, 0x84, 0xa6, 0x14, 0x57, 0x70, 0xc7, 0xfb, 0x46, 0x23, 0xbf, 0x6f, 0xa1, 0xfa,
	0xd7, 0xf9, 0x86, 0x5a, 0xf0, 0xfe, 0x4b, 0xcf, 0x97, 0x57, 0x59, 0xbb, 0xc6, 0x3d, 0x6b, 0xb7,
	0x17, 0x16, 0x8f, 0x90, 0x3e, 0x80, 0x4f, 0xe5, 0xf1, 0xe2, 0x79, 0x10, 0xcf, 0xf8, 0xc8, 0x9b,
	0x78, 0x7c, 0x6c, 0x6a, 0xd4, 0x82, 0xad, 0xdc, 0x31, 0x4c, 0x7d, 0x9f, 0x27, 0x91, 0x37, 0x72,
	0x78, 0x6a, 0x12, 0xfa, 0x39, 0x7c, 0x96, 0x7b, 0x0e, 0x62, 0xd5, 0x55, 0xa1, 0xdb, 0x40, 0x8b,
	0x24, 0x6f, 0x1a, 0x78, 0xc1, 0x14, 0x71, 0x7d, 0xef, 0xa2, 0xf4, 0x9a, 0xe9, 0x2e, 0x7c, 0xa5,
	0x98, 0x6a, 0xe3, 0x0c, 0x36, 0x35, 0xba, 0x05, 0xa6, 0x1a, 0x72, 0xea, 0x1e, 0x5e, 0x9b, 0x04,
	0xd9, 0xaa, 0xe8, 0xf1, 0x51, 0x77, 0x7f, 0xff, 0xf1, 0x0f, 0x66, 0x65, 0xef, 0x1f, 0xa2, 0xdc,
	0x23, 0x6d, 0xc1, 0x97, 0x85, 0xa1, 0x56, 0x97, 0xa0, 0xa9, 0x51, 0x1b, 0x76, 0x96, 0x11, 0xcf,
	0xf8, 0xd4, 0x1d, 0xa5, 0x0e, 0x1f, 0x8d, 0xdc, 0xab, 0x8b, 0xee, 0xfe, 0xf7, 0x26, 0xb9, 0xc7,
	0xbf, 0xff, 0xb8, 0x9b, 0x0d, 0xba, 0xf4, 0x0f, 0x4f, 0x0e, 0x9e, 0x88, 0x3c, 0xfd, 0x03, 0x38,
	0xc6, 0x57, 0x51, 0xb3, 0x25, 0xde, 0xbb, 0x76, 0xaf, 0x78, 0xf7, 0x52, 0xa4, 0xac, 0x7d, 0xd8,
	0x85, 0x59, 0xc6, 0xde, 0x1b, 0x52, 0x7c, 0x2d, 0xd4, 0x84, 0xa6, 0x3c, 0x0a, 0x69, 0x4d, 0x0d,
	0x7b, 0xe5, 0xc8, 0x71, 0x30, 0xc2, 0xd3, 0x30, 0xf5, 0x4d, 0xa2, 0xe2, 0x47, 0xbc, 0xc0, 0x2b,
	0xd8, 0x68, 0x25, 0xfe, 0x3c, 0xc4, 0xaf, 0xc0, 0xd4, 0xe9, 0x17, 0xf0, 0x60, 0x25, 0xe5, 0x69,
	0x14, 0xfa, 0xc2, 0x59, 0x55, 0xf3, 0xfa, 0xfe, 0x2c, 0x8c, 0x92, 0xe7, 0xb1, 0x17, 0x4c, 0xcf,
	0x5e, 0x66, 0xdc, 0x8b, 0x92, 0xbf, 0xaa, 0x2e, 0x83, 0xee, 0xc0, 0x76, 0x39, 0xab, 0xa8, 0x58,
	0xc3, 0xdd, 0x2a, 0xa7, 0x49, 0x22, 0xf5, 0xde, 0x77, 0x37, 0xb7, 0xb6, 0xf6, 0xfa, 0xd6, 0xd6,
	0xde, 0xde, 0xda, 0xe4, 0xb7, 0x85, 0x4d, 0xfe, 0x5a, 0xd8, 0xe4, 0xef, 0x85, 0x4d, 0x6e, 0x16,
	0x36, 0xf9, 0x77, 0x61, 0x93, 0xff, 0x16, 0xb6, 0xf6, 0x76, 0x61, 0x93, 0x3f, 0xee, 0x6c, 0xed,
	0xe6, 0xce, 0xd6, 0x5e, 0xdf, 0xd9, 0xda, 0xa5, 0x21, 0x7e, 0xe7, 0x27, 0xef, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x8b, 0x2b, 0xf4, 0x02, 0xae, 0x07, 0x00, 0x00,
}

func (x KeyForm) String() string {
	s, ok := KeyForm_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CryptoKitID) String() string {
	s, ok := CryptoKitID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HashKitID) String() string {
	s, ok := HashKitID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CryptOp) String() string {
	s, ok := CryptOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *CryptOpArgs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CryptOpArgs)
	if !ok {
		that2, ok := that.(CryptOpArgs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CryptOp != that1.CryptOp {
		return false
	}
	if this.DefaultCryptoKit != that1.DefaultCryptoKit {
		return false
	}
	if !bytes.Equal(this.BufIn, that1.BufIn) {
		return false
	}
	if !this.OpKey.Equal(that1.OpKey) {
		return false
	}
	if !bytes.Equal(this.PeerKey, that1.PeerKey) {
		return false
	}
	if !this.TomeIn.Equal(that1.TomeIn) {
		return false
	}
	return true
}
func (this *CryptOpOut) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CryptOpOut)
	if !ok {
		that2, ok := that.(CryptOpOut)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.BufOut, that1.BufOut) {
		return false
	}
	if !bytes.Equal(this.OpPubKey, that1.OpPubKey) {
		return false
	}
	return true
}
func (this *KeyInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KeyInfo)
	if !ok {
		that2, ok := that.(KeyInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeyForm != that1.KeyForm {
		return false
	}
	if this.CryptoKitID != that1.CryptoKitID {
		return false
	}
	if this.TimeCreated != that1.TimeCreated {
		return false
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return false
	}
	return true
}
func (this *KeyRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KeyRef)
	if !ok {
		that2, ok := that.(KeyRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.KeyringName, that1.KeyringName) {
		return false
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return false
	}
	return true
}
func (this *KeyEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KeyEntry)
	if !ok {
		that2, ok := that.(KeyEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.KeyInfo.Equal(that1.KeyInfo) {
		return false
	}
	if !bytes.Equal(this.PrivKey, that1.PrivKey) {
		return false
	}
	return true
}
func (this *Keyring) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Keyring)
	if !ok {
		that2, ok := that.(Keyring)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Name, that1.Name) {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if !this.Keys[i].Equal(that1.Keys[i]) {
			return false
		}
	}
	if this.SortedByPubKey != that1.SortedByPubKey {
		return false
	}
	if !bytes.Equal(this.NewestPubKey, that1.NewestPubKey) {
		return false
	}
	return true
}
func (this *KeyTome) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KeyTome)
	if !ok {
		that2, ok := that.(KeyTome)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Rev != that1.Rev {
		return false
	}
	if len(this.Keyrings) != len(that1.Keyrings) {
		return false
	}
	for i := range this.Keyrings {
		if !this.Keyrings[i].Equal(that1.Keyrings[i]) {
			return false
		}
	}
	if this.SortedByName != that1.SortedByName {
		return false
	}
	return true
}
func (this *SigHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SigHeader)
	if !ok {
		that2, ok := that.(SigHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SignerCryptoKit != that1.SignerCryptoKit {
		return false
	}
	if !bytes.Equal(this.SignerPubKey, that1.SignerPubKey) {
		return false
	}
	if this.HashKitID != that1.HashKitID {
		return false
	}
	if this.HeaderSz != that1.HeaderSz {
		return false
	}
	if this.HeaderCodec != that1.HeaderCodec {
		return false
	}
	if this.BodySz != that1.BodySz {
		return false
	}
	return true
}
func (this *KeyTomeCrypt) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KeyTomeCrypt)
	if !ok {
		that2, ok := that.(KeyTomeCrypt)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Tome, that1.Tome) {
		return false
	}
	if !this.KeyRef.Equal(that1.KeyRef) {
		return false
	}
	if !this.KeyInfo.Equal(that1.KeyInfo) {
		return false
	}
	return true
}
func (this *CryptOpArgs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&ski.CryptOpArgs{")
	s = append(s, "CryptOp: "+fmt.Sprintf("%#v", this.CryptOp)+",\n")
	s = append(s, "DefaultCryptoKit: "+fmt.Sprintf("%#v", this.DefaultCryptoKit)+",\n")
	s = append(s, "BufIn: "+fmt.Sprintf("%#v", this.BufIn)+",\n")
	if this.OpKey != nil {
		s = append(s, "OpKey: "+fmt.Sprintf("%#v", this.OpKey)+",\n")
	}
	s = append(s, "PeerKey: "+fmt.Sprintf("%#v", this.PeerKey)+",\n")
	if this.TomeIn != nil {
		s = append(s, "TomeIn: "+fmt.Sprintf("%#v", this.TomeIn)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CryptOpOut) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ski.CryptOpOut{")
	s = append(s, "BufOut: "+fmt.Sprintf("%#v", this.BufOut)+",\n")
	s = append(s, "OpPubKey: "+fmt.Sprintf("%#v", this.OpPubKey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KeyInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&ski.KeyInfo{")
	s = append(s, "KeyForm: "+fmt.Sprintf("%#v", this.KeyForm)+",\n")
	s = append(s, "CryptoKitID: "+fmt.Sprintf("%#v", this.CryptoKitID)+",\n")
	s = append(s, "TimeCreated: "+fmt.Sprintf("%#v", this.TimeCreated)+",\n")
	s = append(s, "PubKey: "+fmt.Sprintf("%#v", this.PubKey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KeyRef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ski.KeyRef{")
	s = append(s, "KeyringName: "+fmt.Sprintf("%#v", this.KeyringName)+",\n")
	s = append(s, "PubKey: "+fmt.Sprintf("%#v", this.PubKey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KeyEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ski.KeyEntry{")
	if this.KeyInfo != nil {
		s = append(s, "KeyInfo: "+fmt.Sprintf("%#v", this.KeyInfo)+",\n")
	}
	s = append(s, "PrivKey: "+fmt.Sprintf("%#v", this.PrivKey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Keyring) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&ski.Keyring{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Keys != nil {
		s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	}
	s = append(s, "SortedByPubKey: "+fmt.Sprintf("%#v", this.SortedByPubKey)+",\n")
	s = append(s, "NewestPubKey: "+fmt.Sprintf("%#v", this.NewestPubKey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KeyTome) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ski.KeyTome{")
	s = append(s, "Rev: "+fmt.Sprintf("%#v", this.Rev)+",\n")
	if this.Keyrings != nil {
		s = append(s, "Keyrings: "+fmt.Sprintf("%#v", this.Keyrings)+",\n")
	}
	s = append(s, "SortedByName: "+fmt.Sprintf("%#v", this.SortedByName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SigHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&ski.SigHeader{")
	s = append(s, "SignerCryptoKit: "+fmt.Sprintf("%#v", this.SignerCryptoKit)+",\n")
	s = append(s, "SignerPubKey: "+fmt.Sprintf("%#v", this.SignerPubKey)+",\n")
	s = append(s, "HashKitID: "+fmt.Sprintf("%#v", this.HashKitID)+",\n")
	s = append(s, "HeaderSz: "+fmt.Sprintf("%#v", this.HeaderSz)+",\n")
	s = append(s, "HeaderCodec: "+fmt.Sprintf("%#v", this.HeaderCodec)+",\n")
	s = append(s, "BodySz: "+fmt.Sprintf("%#v", this.BodySz)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KeyTomeCrypt) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ski.KeyTomeCrypt{")
	s = append(s, "Tome: "+fmt.Sprintf("%#v", this.Tome)+",\n")
	if this.KeyRef != nil {
		s = append(s, "KeyRef: "+fmt.Sprintf("%#v", this.KeyRef)+",\n")
	}
	if this.KeyInfo != nil {
		s = append(s, "KeyInfo: "+fmt.Sprintf("%#v", this.KeyInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAmpSki(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CryptOpArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptOpArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CryptOpArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TomeIn != nil {
		{
			size, err := m.TomeIn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpSki(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.PeerKey) > 0 {
		i -= len(m.PeerKey)
		copy(dAtA[i:], m.PeerKey)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.PeerKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OpKey != nil {
		{
			size, err := m.OpKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpSki(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.BufIn) > 0 {
		i -= len(m.BufIn)
		copy(dAtA[i:], m.BufIn)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.BufIn)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DefaultCryptoKit != 0 {
		i = encodeVarintAmpSki(dAtA, i, uint64(m.DefaultCryptoKit))
		i--
		dAtA[i] = 0x10
	}
	if m.CryptOp != 0 {
		i = encodeVarintAmpSki(dAtA, i, uint64(m.CryptOp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CryptOpOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptOpOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CryptOpOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OpPubKey) > 0 {
		i -= len(m.OpPubKey)
		copy(dAtA[i:], m.OpPubKey)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.OpPubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BufOut) > 0 {
		i -= len(m.BufOut)
		copy(dAtA[i:], m.BufOut)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.BufOut)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.TimeCreated != 0 {
		i = encodeVarintAmpSki(dAtA, i, uint64(m.TimeCreated))
		i--
		dAtA[i] = 0x18
	}
	if m.CryptoKitID != 0 {
		i = encodeVarintAmpSki(dAtA, i, uint64(m.CryptoKitID))
		i--
		dAtA[i] = 0x10
	}
	if m.KeyForm != 0 {
		i = encodeVarintAmpSki(dAtA, i, uint64(m.KeyForm))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyringName) > 0 {
		i -= len(m.KeyringName)
		copy(dAtA[i:], m.KeyringName)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.KeyringName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrivKey) > 0 {
		i -= len(m.PrivKey)
		copy(dAtA[i:], m.PrivKey)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.PrivKey)))
		i--
		dAtA[i] = 0x32
	}
	if m.KeyInfo != nil {
		{
			size, err := m.KeyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpSki(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Keyring) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Keyring) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Keyring) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewestPubKey) > 0 {
		i -= len(m.NewestPubKey)
		copy(dAtA[i:], m.NewestPubKey)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.NewestPubKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.SortedByPubKey {
		i--
		if m.SortedByPubKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Keys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAmpSki(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyTome) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyTome) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyTome) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SortedByName {
		i--
		if m.SortedByName {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Keyrings) > 0 {
		for iNdEx := len(m.Keyrings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Keyrings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAmpSki(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Rev != 0 {
		i = encodeVarintAmpSki(dAtA, i, uint64(m.Rev))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SigHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BodySz != 0 {
		i = encodeVarintAmpSki(dAtA, i, uint64(m.BodySz))
		i--
		dAtA[i] = 0x48
	}
	if m.HeaderCodec != 0 {
		i = encodeVarintAmpSki(dAtA, i, uint64(m.HeaderCodec))
		i--
		dAtA[i] = 0x40
	}
	if m.HeaderSz != 0 {
		i = encodeVarintAmpSki(dAtA, i, uint64(m.HeaderSz))
		i--
		dAtA[i] = 0x38
	}
	if m.HashKitID != 0 {
		i = encodeVarintAmpSki(dAtA, i, uint64(m.HashKitID))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SignerPubKey) > 0 {
		i -= len(m.SignerPubKey)
		copy(dAtA[i:], m.SignerPubKey)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.SignerPubKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.SignerCryptoKit != 0 {
		i = encodeVarintAmpSki(dAtA, i, uint64(m.SignerCryptoKit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyTomeCrypt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyTomeCrypt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyTomeCrypt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeyInfo != nil {
		{
			size, err := m.KeyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpSki(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.KeyRef != nil {
		{
			size, err := m.KeyRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpSki(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Tome) > 0 {
		i -= len(m.Tome)
		copy(dAtA[i:], m.Tome)
		i = encodeVarintAmpSki(dAtA, i, uint64(len(m.Tome)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAmpSki(dAtA []byte, offset int, v uint64) int {
	offset -= sovAmpSki(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CryptOpArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CryptOp != 0 {
		n += 1 + sovAmpSki(uint64(m.CryptOp))
	}
	if m.DefaultCryptoKit != 0 {
		n += 1 + sovAmpSki(uint64(m.DefaultCryptoKit))
	}
	l = len(m.BufIn)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	if m.OpKey != nil {
		l = m.OpKey.Size()
		n += 1 + l + sovAmpSki(uint64(l))
	}
	l = len(m.PeerKey)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	if m.TomeIn != nil {
		l = m.TomeIn.Size()
		n += 1 + l + sovAmpSki(uint64(l))
	}
	return n
}

func (m *CryptOpOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BufOut)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	l = len(m.OpPubKey)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	return n
}

func (m *KeyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyForm != 0 {
		n += 1 + sovAmpSki(uint64(m.KeyForm))
	}
	if m.CryptoKitID != 0 {
		n += 1 + sovAmpSki(uint64(m.CryptoKitID))
	}
	if m.TimeCreated != 0 {
		n += 1 + sovAmpSki(uint64(m.TimeCreated))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	return n
}

func (m *KeyRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyringName)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	return n
}

func (m *KeyEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyInfo != nil {
		l = m.KeyInfo.Size()
		n += 1 + l + sovAmpSki(uint64(l))
	}
	l = len(m.PrivKey)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	return n
}

func (m *Keyring) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovAmpSki(uint64(l))
		}
	}
	if m.SortedByPubKey {
		n += 2
	}
	l = len(m.NewestPubKey)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	return n
}

func (m *KeyTome) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rev != 0 {
		n += 1 + sovAmpSki(uint64(m.Rev))
	}
	if len(m.Keyrings) > 0 {
		for _, e := range m.Keyrings {
			l = e.Size()
			n += 1 + l + sovAmpSki(uint64(l))
		}
	}
	if m.SortedByName {
		n += 2
	}
	return n
}

func (m *SigHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignerCryptoKit != 0 {
		n += 1 + sovAmpSki(uint64(m.SignerCryptoKit))
	}
	l = len(m.SignerPubKey)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	if m.HashKitID != 0 {
		n += 1 + sovAmpSki(uint64(m.HashKitID))
	}
	if m.HeaderSz != 0 {
		n += 1 + sovAmpSki(uint64(m.HeaderSz))
	}
	if m.HeaderCodec != 0 {
		n += 1 + sovAmpSki(uint64(m.HeaderCodec))
	}
	if m.BodySz != 0 {
		n += 1 + sovAmpSki(uint64(m.BodySz))
	}
	return n
}

func (m *KeyTomeCrypt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tome)
	if l > 0 {
		n += 1 + l + sovAmpSki(uint64(l))
	}
	if m.KeyRef != nil {
		l = m.KeyRef.Size()
		n += 1 + l + sovAmpSki(uint64(l))
	}
	if m.KeyInfo != nil {
		l = m.KeyInfo.Size()
		n += 1 + l + sovAmpSki(uint64(l))
	}
	return n
}

func sovAmpSki(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAmpSki(x uint64) (n int) {
	return sovAmpSki(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CryptOpArgs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CryptOpArgs{`,
		`CryptOp:` + fmt.Sprintf("%v", this.CryptOp) + `,`,
		`DefaultCryptoKit:` + fmt.Sprintf("%v", this.DefaultCryptoKit) + `,`,
		`BufIn:` + fmt.Sprintf("%v", this.BufIn) + `,`,
		`OpKey:` + strings.Replace(this.OpKey.String(), "KeyRef", "KeyRef", 1) + `,`,
		`PeerKey:` + fmt.Sprintf("%v", this.PeerKey) + `,`,
		`TomeIn:` + strings.Replace(this.TomeIn.String(), "KeyTome", "KeyTome", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CryptOpOut) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CryptOpOut{`,
		`BufOut:` + fmt.Sprintf("%v", this.BufOut) + `,`,
		`OpPubKey:` + fmt.Sprintf("%v", this.OpPubKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KeyInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KeyInfo{`,
		`KeyForm:` + fmt.Sprintf("%v", this.KeyForm) + `,`,
		`CryptoKitID:` + fmt.Sprintf("%v", this.CryptoKitID) + `,`,
		`TimeCreated:` + fmt.Sprintf("%v", this.TimeCreated) + `,`,
		`PubKey:` + fmt.Sprintf("%v", this.PubKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KeyRef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KeyRef{`,
		`KeyringName:` + fmt.Sprintf("%v", this.KeyringName) + `,`,
		`PubKey:` + fmt.Sprintf("%v", this.PubKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KeyEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KeyEntry{`,
		`KeyInfo:` + strings.Replace(this.KeyInfo.String(), "KeyInfo", "KeyInfo", 1) + `,`,
		`PrivKey:` + fmt.Sprintf("%v", this.PrivKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Keyring) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForKeys := "[]*KeyEntry{"
	for _, f := range this.Keys {
		repeatedStringForKeys += strings.Replace(f.String(), "KeyEntry", "KeyEntry", 1) + ","
	}
	repeatedStringForKeys += "}"
	s := strings.Join([]string{`&Keyring{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Keys:` + repeatedStringForKeys + `,`,
		`SortedByPubKey:` + fmt.Sprintf("%v", this.SortedByPubKey) + `,`,
		`NewestPubKey:` + fmt.Sprintf("%v", this.NewestPubKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KeyTome) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForKeyrings := "[]*Keyring{"
	for _, f := range this.Keyrings {
		repeatedStringForKeyrings += strings.Replace(f.String(), "Keyring", "Keyring", 1) + ","
	}
	repeatedStringForKeyrings += "}"
	s := strings.Join([]string{`&KeyTome{`,
		`Rev:` + fmt.Sprintf("%v", this.Rev) + `,`,
		`Keyrings:` + repeatedStringForKeyrings + `,`,
		`SortedByName:` + fmt.Sprintf("%v", this.SortedByName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SigHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SigHeader{`,
		`SignerCryptoKit:` + fmt.Sprintf("%v", this.SignerCryptoKit) + `,`,
		`SignerPubKey:` + fmt.Sprintf("%v", this.SignerPubKey) + `,`,
		`HashKitID:` + fmt.Sprintf("%v", this.HashKitID) + `,`,
		`HeaderSz:` + fmt.Sprintf("%v", this.HeaderSz) + `,`,
		`HeaderCodec:` + fmt.Sprintf("%v", this.HeaderCodec) + `,`,
		`BodySz:` + fmt.Sprintf("%v", this.BodySz) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KeyTomeCrypt) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KeyTomeCrypt{`,
		`Tome:` + fmt.Sprintf("%v", this.Tome) + `,`,
		`KeyRef:` + strings.Replace(this.KeyRef.String(), "KeyRef", "KeyRef", 1) + `,`,
		`KeyInfo:` + strings.Replace(this.KeyInfo.String(), "KeyInfo", "KeyInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAmpSki(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CryptOpArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptOpArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptOpArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptOp", wireType)
			}
			m.CryptOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CryptOp |= CryptOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultCryptoKit", wireType)
			}
			m.DefaultCryptoKit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultCryptoKit |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufIn", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufIn = append(m.BufIn[:0], dAtA[iNdEx:postIndex]...)
			if m.BufIn == nil {
				m.BufIn = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpKey == nil {
				m.OpKey = &KeyRef{}
			}
			if err := m.OpKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerKey = append(m.PeerKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PeerKey == nil {
				m.PeerKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TomeIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TomeIn == nil {
				m.TomeIn = &KeyTome{}
			}
			if err := m.TomeIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CryptOpOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptOpOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptOpOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufOut", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufOut = append(m.BufOut[:0], dAtA[iNdEx:postIndex]...)
			if m.BufOut == nil {
				m.BufOut = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpPubKey = append(m.OpPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OpPubKey == nil {
				m.OpPubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyForm", wireType)
			}
			m.KeyForm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyForm |= KeyForm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoKitID", wireType)
			}
			m.CryptoKitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CryptoKitID |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCreated", wireType)
			}
			m.TimeCreated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCreated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyringName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyringName = append(m.KeyringName[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyringName == nil {
				m.KeyringName = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyInfo == nil {
				m.KeyInfo = &KeyInfo{}
			}
			if err := m.KeyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivKey = append(m.PrivKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivKey == nil {
				m.PrivKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keyring) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keyring: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keyring: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &KeyEntry{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedByPubKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SortedByPubKey = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewestPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewestPubKey = append(m.NewestPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.NewestPubKey == nil {
				m.NewestPubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyTome) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyTome: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyTome: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			m.Rev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rev |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyrings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyrings = append(m.Keyrings, &Keyring{})
			if err := m.Keyrings[len(m.Keyrings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedByName", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SortedByName = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAmpSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerCryptoKit", wireType)
			}
			m.SignerCryptoKit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignerCryptoKit |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerPubKey = append(m.SignerPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SignerPubKey == nil {
				m.SignerPubKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashKitID", wireType)
			}
			m.HashKitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashKitID |= HashKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderSz", wireType)
			}
			m.HeaderSz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderSz |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderCodec", wireType)
			}
			m.HeaderCodec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderCodec |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodySz", wireType)
			}
			m.BodySz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BodySz |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAmpSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyTomeCrypt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyTomeCrypt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyTomeCrypt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tome", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tome = append(m.Tome[:0], dAtA[iNdEx:postIndex]...)
			if m.Tome == nil {
				m.Tome = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRef == nil {
				m.KeyRef = &KeyRef{}
			}
			if err := m.KeyRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyInfo == nil {
				m.KeyInfo = &KeyInfo{}
			}
			if err := m.KeyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAmpSki(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAmpSki
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAmpSki
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAmpSki
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAmpSki
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAmpSki
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAmpSki        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAmpSki          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAmpSki = fmt.Errorf("proto: unexpected end of group")
)
