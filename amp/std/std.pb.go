// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: amp/std/std.proto

package std

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	amp "github.com/art-media-platform/amp.SDK/amp"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CordType describes how to interpret coordinates contained in a Position.
type CordType int32

const (
	CordType_Unspecified     CordType = 0
	CordType_Ordered         CordType = 1
	CordType_Plane_Cartesian CordType = 5
	CordType_Plane_HexEvenR  CordType = 6
	CordType_Geoid_Sphere    CordType = 10
	CordType_Geoid_WGS84     CordType = 11
)

var CordType_name = map[int32]string{
	0:  "CordType_Unspecified",
	1:  "CordType_Ordered",
	5:  "CordType_Plane_Cartesian",
	6:  "CordType_Plane_HexEvenR",
	10: "CordType_Geoid_Sphere",
	11: "CordType_Geoid_WGS84",
}

var CordType_value = map[string]int32{
	"CordType_Unspecified":     0,
	"CordType_Ordered":         1,
	"CordType_Plane_Cartesian": 5,
	"CordType_Plane_HexEvenR":  6,
	"CordType_Geoid_Sphere":    10,
	"CordType_Geoid_WGS84":     11,
}

func (CordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6f70fdd671fe185, []int{0}
}

type TRS_VisualScaleMode int32

const (
	AutoScale  TRS_VisualScaleMode = 0
	FixedScale TRS_VisualScaleMode = 1
)

var TRS_VisualScaleMode_name = map[int32]string{
	0: "AutoScale",
	1: "FixedScale",
}

var TRS_VisualScaleMode_value = map[string]int32{
	"AutoScale":  0,
	"FixedScale": 1,
}

func (TRS_VisualScaleMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6f70fdd671fe185, []int{4, 0}
}

// Position describes a position in space and/or time using a given coordinate system.
type Position struct {
	CordType CordType `protobuf:"varint,1,opt,name=CordType,proto3,enum=std.CordType" json:"CordType,omitempty"`
	Q        float64  `protobuf:"fixed64,3,opt,name=Q,proto3" json:"Q,omitempty"`
	R        float64  `protobuf:"fixed64,4,opt,name=R,proto3" json:"R,omitempty"`
	S        float64  `protobuf:"fixed64,5,opt,name=S,proto3" json:"S,omitempty"`
	ROU      float32  `protobuf:"fixed32,6,opt,name=ROU,proto3" json:"ROU,omitempty"`
}

func (m *Position) Reset()      { *m = Position{} }
func (*Position) ProtoMessage() {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6f70fdd671fe185, []int{0}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetCordType() CordType {
	if m != nil {
		return m.CordType
	}
	return CordType_Unspecified
}

func (m *Position) GetQ() float64 {
	if m != nil {
		return m.Q
	}
	return 0
}

func (m *Position) GetR() float64 {
	if m != nil {
		return m.R
	}
	return 0
}

func (m *Position) GetS() float64 {
	if m != nil {
		return m.S
	}
	return 0
}

func (m *Position) GetROU() float32 {
	if m != nil {
		return m.ROU
	}
	return 0
}

type FSInfo struct {
	Mode        string `protobuf:"bytes,1,opt,name=Mode,proto3" json:"Mode,omitempty"`
	IsDir       bool   `protobuf:"varint,2,opt,name=IsDir,proto3" json:"IsDir,omitempty"`
	Name        string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	NameLen     int32  `protobuf:"varint,4,opt,name=NameLen,proto3" json:"NameLen,omitempty"`
	ContentType string `protobuf:"bytes,5,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	CreatedAt   int64  `protobuf:"varint,7,opt,name=CreatedAt,proto3" json:"CreatedAt,omitempty"`
	ModifiedAt  int64  `protobuf:"varint,8,opt,name=ModifiedAt,proto3" json:"ModifiedAt,omitempty"`
	ByteSize    int64  `protobuf:"varint,9,opt,name=ByteSize,proto3" json:"ByteSize,omitempty"`
}

func (m *FSInfo) Reset()      { *m = FSInfo{} }
func (*FSInfo) ProtoMessage() {}
func (*FSInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6f70fdd671fe185, []int{1}
}
func (m *FSInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FSInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FSInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FSInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FSInfo.Merge(m, src)
}
func (m *FSInfo) XXX_Size() int {
	return m.Size()
}
func (m *FSInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FSInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FSInfo proto.InternalMessageInfo

func (m *FSInfo) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *FSInfo) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

func (m *FSInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FSInfo) GetNameLen() int32 {
	if m != nil {
		return m.NameLen
	}
	return 0
}

func (m *FSInfo) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *FSInfo) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *FSInfo) GetModifiedAt() int64 {
	if m != nil {
		return m.ModifiedAt
	}
	return 0
}

func (m *FSInfo) GetByteSize() int64 {
	if m != nil {
		return m.ByteSize
	}
	return 0
}

type Placement struct {
	// Expresses the position of this placement in space.
	// The coordinate system is specified within (or implied) from the hosting attribute spec.
	// Here's to the 3 domains that reflect completeness: alpha (finite), omega (unending), and the inaccessible cardinal(s) -- https://www.youtube.com/watch?v=SrU9YDoXE88
	Pos0 float64 `protobuf:"fixed64,1,opt,name=Pos0,proto3" json:"Pos0,omitempty"`
	Pos1 float64 `protobuf:"fixed64,2,opt,name=Pos1,proto3" json:"Pos1,omitempty"`
	Pos2 float64 `protobuf:"fixed64,3,opt,name=Pos2,proto3" json:"Pos2,omitempty"`
	// Expresses the scale of this Node.
	// If all three values are 0, they are all implicitly 1.
	// If Scale2 or Scale3 == 0, then they are each implicitly Scale1.
	Scale0 float32 `protobuf:"fixed32,4,opt,name=Scale0,proto3" json:"Scale0,omitempty"`
	Scale1 float32 `protobuf:"fixed32,5,opt,name=Scale1,proto3" json:"Scale1,omitempty"`
	Scale2 float32 `protobuf:"fixed32,6,opt,name=Scale2,proto3" json:"Scale2,omitempty"`
	// Expresses the orientation of this placement using Euler angles.
	EulerX float32    `protobuf:"fixed32,7,opt,name=EulerX,proto3" json:"EulerX,omitempty"`
	EulerY float32    `protobuf:"fixed32,8,opt,name=EulerY,proto3" json:"EulerY,omitempty"`
	EulerZ float32    `protobuf:"fixed32,9,opt,name=EulerZ,proto3" json:"EulerZ,omitempty"`
	Metric amp.Metric `protobuf:"varint,12,opt,name=Metric,proto3,enum=amp.Metric" json:"Metric,omitempty"`
}

func (m *Placement) Reset()      { *m = Placement{} }
func (*Placement) ProtoMessage() {}
func (*Placement) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6f70fdd671fe185, []int{2}
}
func (m *Placement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Placement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Placement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Placement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Placement.Merge(m, src)
}
func (m *Placement) XXX_Size() int {
	return m.Size()
}
func (m *Placement) XXX_DiscardUnknown() {
	xxx_messageInfo_Placement.DiscardUnknown(m)
}

var xxx_messageInfo_Placement proto.InternalMessageInfo

func (m *Placement) GetPos0() float64 {
	if m != nil {
		return m.Pos0
	}
	return 0
}

func (m *Placement) GetPos1() float64 {
	if m != nil {
		return m.Pos1
	}
	return 0
}

func (m *Placement) GetPos2() float64 {
	if m != nil {
		return m.Pos2
	}
	return 0
}

func (m *Placement) GetScale0() float32 {
	if m != nil {
		return m.Scale0
	}
	return 0
}

func (m *Placement) GetScale1() float32 {
	if m != nil {
		return m.Scale1
	}
	return 0
}

func (m *Placement) GetScale2() float32 {
	if m != nil {
		return m.Scale2
	}
	return 0
}

func (m *Placement) GetEulerX() float32 {
	if m != nil {
		return m.EulerX
	}
	return 0
}

func (m *Placement) GetEulerY() float32 {
	if m != nil {
		return m.EulerY
	}
	return 0
}

func (m *Placement) GetEulerZ() float32 {
	if m != nil {
		return m.EulerZ
	}
	return 0
}

func (m *Placement) GetMetric() amp.Metric {
	if m != nil {
		return m.Metric
	}
	return amp.Metric_Nil
}

type BadgeDigit struct {
	// // values assumed to be in range [1-{AmplitudeModulus}])
	// Importantly, this shifts the domain to have +0 be separate from -0.
	// Typically   -4,   -3,   -2,  -1,   +1,  +2,  +3, +4
	//              0,    1,    2,   3,    4,   5,   6,  7
	//            -1.0 -0.75 -0.50 -0.25 0.25 0.50 0.75 1.0
	Amplitude        int64 `protobuf:"varint,1,opt,name=Amplitude,proto3" json:"Amplitude,omitempty"`
	AmplitudeModulus int64 `protobuf:"varint,2,opt,name=AmplitudeModulus,proto3" json:"AmplitudeModulus,omitempty"`
}

func (m *BadgeDigit) Reset()      { *m = BadgeDigit{} }
func (*BadgeDigit) ProtoMessage() {}
func (*BadgeDigit) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6f70fdd671fe185, []int{3}
}
func (m *BadgeDigit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadgeDigit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BadgeDigit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BadgeDigit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadgeDigit.Merge(m, src)
}
func (m *BadgeDigit) XXX_Size() int {
	return m.Size()
}
func (m *BadgeDigit) XXX_DiscardUnknown() {
	xxx_messageInfo_BadgeDigit.DiscardUnknown(m)
}

var xxx_messageInfo_BadgeDigit proto.InternalMessageInfo

func (m *BadgeDigit) GetAmplitude() int64 {
	if m != nil {
		return m.Amplitude
	}
	return 0
}

func (m *BadgeDigit) GetAmplitudeModulus() int64 {
	if m != nil {
		return m.AmplitudeModulus
	}
	return 0
}

type TRS struct {
	// X1, X2, and X3 are coordinates or values expressed in any unit.
	// A channel client can later declare how to interpret these coordinates so that a channel server and provide indexed services.
	// Shoutout to the 3 domains that reflect all theoretical completeness: alpha (finite), omega (unending), and the inaccessible cardinal(s).
	// Special thanks to Michael at Vsauce: https://www.youtube.com/watch?v=SrU9YDoXE88
	X1 float64 `protobuf:"fixed64,41,opt,name=X1,proto3" json:"X1,omitempty"`
	X2 float64 `protobuf:"fixed64,42,opt,name=X2,proto3" json:"X2,omitempty"`
	X3 float64 `protobuf:"fixed64,43,opt,name=X3,proto3" json:"X3,omitempty"`
	// Specifies how scale dynamically changes based on observer position.
	ScaleMode TRS_VisualScaleMode `protobuf:"varint,50,opt,name=ScaleMode,proto3,enum=std.TRS_VisualScaleMode" json:"ScaleMode,omitempty"`
	// Scale1..3 express the scale of this placement.
	// If all three values are 0, they are all implicitly 1.
	// If Scale2 or Scale3 == 0, then it is implicitly Scale1.
	Scale1 float32 `protobuf:"fixed32,51,opt,name=Scale1,proto3" json:"Scale1,omitempty"`
	Scale2 float32 `protobuf:"fixed32,52,opt,name=Scale2,proto3" json:"Scale2,omitempty"`
	Scale3 float32 `protobuf:"fixed32,53,opt,name=Scale3,proto3" json:"Scale3,omitempty"`
	// Rotate1 - Rotate3 the orientation of this placement using Euler angles.
	Rotate1 float32 `protobuf:"fixed32,61,opt,name=Rotate1,proto3" json:"Rotate1,omitempty"`
	Rotate2 float32 `protobuf:"fixed32,62,opt,name=Rotate2,proto3" json:"Rotate2,omitempty"`
	Rotate3 float32 `protobuf:"fixed32,63,opt,name=Rotate3,proto3" json:"Rotate3,omitempty"`
}

func (m *TRS) Reset()      { *m = TRS{} }
func (*TRS) ProtoMessage() {}
func (*TRS) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6f70fdd671fe185, []int{4}
}
func (m *TRS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TRS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TRS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TRS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TRS.Merge(m, src)
}
func (m *TRS) XXX_Size() int {
	return m.Size()
}
func (m *TRS) XXX_DiscardUnknown() {
	xxx_messageInfo_TRS.DiscardUnknown(m)
}

var xxx_messageInfo_TRS proto.InternalMessageInfo

func (m *TRS) GetX1() float64 {
	if m != nil {
		return m.X1
	}
	return 0
}

func (m *TRS) GetX2() float64 {
	if m != nil {
		return m.X2
	}
	return 0
}

func (m *TRS) GetX3() float64 {
	if m != nil {
		return m.X3
	}
	return 0
}

func (m *TRS) GetScaleMode() TRS_VisualScaleMode {
	if m != nil {
		return m.ScaleMode
	}
	return AutoScale
}

func (m *TRS) GetScale1() float32 {
	if m != nil {
		return m.Scale1
	}
	return 0
}

func (m *TRS) GetScale2() float32 {
	if m != nil {
		return m.Scale2
	}
	return 0
}

func (m *TRS) GetScale3() float32 {
	if m != nil {
		return m.Scale3
	}
	return 0
}

func (m *TRS) GetRotate1() float32 {
	if m != nil {
		return m.Rotate1
	}
	return 0
}

func (m *TRS) GetRotate2() float32 {
	if m != nil {
		return m.Rotate2
	}
	return 0
}

func (m *TRS) GetRotate3() float32 {
	if m != nil {
		return m.Rotate3
	}
	return 0
}

type DataSegment struct {
	ByteOfs    uint64 `protobuf:"varint,5,opt,name=ByteOfs,proto3" json:"ByteOfs,omitempty"`
	ByteSz     uint64 `protobuf:"varint,6,opt,name=ByteSz,proto3" json:"ByteSz,omitempty"`
	InlineData []byte `protobuf:"bytes,7,opt,name=InlineData,proto3" json:"InlineData,omitempty"`
	StreamURI  string `protobuf:"bytes,9,opt,name=StreamURI,proto3" json:"StreamURI,omitempty"`
	BlobID     int64  `protobuf:"varint,10,opt,name=BlobID,proto3" json:"BlobID,omitempty"`
}

func (m *DataSegment) Reset()      { *m = DataSegment{} }
func (*DataSegment) ProtoMessage() {}
func (*DataSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6f70fdd671fe185, []int{5}
}
func (m *DataSegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSegment.Merge(m, src)
}
func (m *DataSegment) XXX_Size() int {
	return m.Size()
}
func (m *DataSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSegment.DiscardUnknown(m)
}

var xxx_messageInfo_DataSegment proto.InternalMessageInfo

func (m *DataSegment) GetByteOfs() uint64 {
	if m != nil {
		return m.ByteOfs
	}
	return 0
}

func (m *DataSegment) GetByteSz() uint64 {
	if m != nil {
		return m.ByteSz
	}
	return 0
}

func (m *DataSegment) GetInlineData() []byte {
	if m != nil {
		return m.InlineData
	}
	return nil
}

func (m *DataSegment) GetStreamURI() string {
	if m != nil {
		return m.StreamURI
	}
	return ""
}

func (m *DataSegment) GetBlobID() int64 {
	if m != nil {
		return m.BlobID
	}
	return 0
}

func init() {
	proto.RegisterEnum("std.CordType", CordType_name, CordType_value)
	proto.RegisterEnum("std.TRS_VisualScaleMode", TRS_VisualScaleMode_name, TRS_VisualScaleMode_value)
	proto.RegisterType((*Position)(nil), "std.Position")
	proto.RegisterType((*FSInfo)(nil), "std.FSInfo")
	proto.RegisterType((*Placement)(nil), "std.Placement")
	proto.RegisterType((*BadgeDigit)(nil), "std.BadgeDigit")
	proto.RegisterType((*TRS)(nil), "std.TRS")
	proto.RegisterType((*DataSegment)(nil), "std.DataSegment")
}

func init() { proto.RegisterFile("amp/std/std.proto", fileDescriptor_b6f70fdd671fe185) }

var fileDescriptor_b6f70fdd671fe185 = []byte{
	// 831 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x94, 0x4f, 0x6f, 0x1b, 0x45,
	0x18, 0xc6, 0x3d, 0x76, 0xec, 0xd8, 0x6f, 0x9a, 0xb0, 0x8c, 0x02, 0x0c, 0xa5, 0x5a, 0x59, 0xe6,
	0xe2, 0x06, 0xc5, 0x89, 0xed, 0x82, 0xb8, 0x00, 0xca, 0x9f, 0xb6, 0x58, 0xc2, 0xc4, 0x9d, 0x4d,
	0x4a, 0x9a, 0x4b, 0x34, 0xf1, 0x4e, 0xdc, 0x11, 0xbb, 0x3b, 0xcb, 0xee, 0x18, 0xb5, 0x3d, 0xf1,
	0x11, 0xb8, 0xf0, 0x1d, 0x50, 0xef, 0x7c, 0x07, 0x8e, 0x39, 0xf6, 0xc0, 0x81, 0x38, 0x17, 0x8e,
	0xfd, 0x00, 0x1c, 0xd0, 0xbc, 0xbb, 0x5e, 0x9b, 0x20, 0x0e, 0x96, 0xdf, 0xe7, 0xf7, 0xec, 0x9f,
	0x79, 0xdf, 0x79, 0x76, 0xe0, 0x5d, 0x11, 0xc6, 0x3b, 0xa9, 0xf1, 0xed, 0xaf, 0x13, 0x27, 0xda,
	0x68, 0x5a, 0x49, 0x8d, 0x7f, 0x77, 0xdd, 0x72, 0x11, 0xc6, 0x19, 0x6b, 0xfd, 0x00, 0xf5, 0x91,
	0x4e, 0x95, 0x51, 0x3a, 0xa2, 0xf7, 0xa1, 0x7e, 0xa0, 0x13, 0xff, 0xf8, 0x65, 0x2c, 0x19, 0x69,
	0x92, 0xf6, 0x46, 0x6f, 0xbd, 0x63, 0xef, 0x9e, 0x43, 0x5e, 0xd8, 0xf4, 0x0e, 0x90, 0x27, 0xac,
	0xd2, 0x24, 0x6d, 0xc2, 0xc9, 0x13, 0xab, 0x38, 0x5b, 0xc9, 0x14, 0xb7, 0xca, 0x63, 0xd5, 0x4c,
	0x79, 0xd4, 0x81, 0x0a, 0x3f, 0x3a, 0x61, 0xb5, 0x26, 0x69, 0x97, 0xb9, 0x2d, 0x5b, 0x7f, 0x10,
	0xa8, 0x3d, 0xf2, 0x06, 0xd1, 0xa5, 0xa6, 0x14, 0x56, 0x86, 0xda, 0xcf, 0xde, 0xd6, 0xe0, 0x58,
	0xd3, 0x4d, 0xa8, 0x0e, 0xd2, 0x43, 0x95, 0xb0, 0x72, 0x93, 0xb4, 0xeb, 0x3c, 0x13, 0xf6, 0xca,
	0x6f, 0x45, 0x28, 0xf1, 0x9d, 0x0d, 0x8e, 0x35, 0x65, 0xb0, 0x6a, 0xff, 0xbf, 0x91, 0x11, 0xbe,
	0xbc, 0xca, 0xe7, 0x92, 0x36, 0x61, 0xed, 0x40, 0x47, 0x46, 0x46, 0x06, 0x9b, 0xa9, 0xe2, 0x4d,
	0xcb, 0x88, 0xde, 0x83, 0xc6, 0x41, 0x22, 0x85, 0x91, 0xfe, 0x9e, 0x61, 0xab, 0x4d, 0xd2, 0xae,
	0xf0, 0x05, 0xa0, 0x2e, 0xc0, 0x50, 0xfb, 0xea, 0x52, 0xa1, 0x5d, 0x47, 0x7b, 0x89, 0xd0, 0xbb,
	0x50, 0xdf, 0x7f, 0x69, 0xa4, 0xa7, 0x5e, 0x49, 0xd6, 0x40, 0xb7, 0xd0, 0xad, 0xbf, 0x09, 0x34,
	0x46, 0x81, 0x18, 0xcb, 0x50, 0x46, 0xc6, 0xae, 0x7b, 0xa4, 0xd3, 0x5d, 0xec, 0x90, 0x70, 0xac,
	0x73, 0xd6, 0xc5, 0x06, 0x33, 0xd6, 0xcd, 0x59, 0x2f, 0x9f, 0x29, 0xd6, 0xf4, 0x7d, 0xa8, 0x79,
	0x63, 0x11, 0xc8, 0x5d, 0x6c, 0xaf, 0xcc, 0x73, 0x55, 0xf0, 0x2e, 0x36, 0x36, 0xe7, 0xdd, 0x82,
	0xf7, 0xf2, 0x69, 0xe7, 0xca, 0xf2, 0x87, 0xd3, 0x40, 0x26, 0xa7, 0xd8, 0x68, 0x99, 0xe7, 0xaa,
	0xe0, 0xcf, 0xb0, 0xc3, 0x39, 0x7f, 0x56, 0xf0, 0x33, 0xec, 0x6d, 0xce, 0xcf, 0xe8, 0xc7, 0x50,
	0x1b, 0x4a, 0x93, 0xa8, 0x31, 0xbb, 0x83, 0xe9, 0x58, 0xeb, 0xd8, 0x1c, 0x65, 0x88, 0xe7, 0x56,
	0xeb, 0x29, 0xc0, 0xbe, 0xf0, 0x27, 0xf2, 0x50, 0x4d, 0x94, 0xb1, 0x63, 0xde, 0x0b, 0xe3, 0x40,
	0x99, 0x69, 0xbe, 0xcb, 0x15, 0xbe, 0x00, 0x74, 0x0b, 0x9c, 0x42, 0x0c, 0xb5, 0x3f, 0x0d, 0xa6,
	0x29, 0x0e, 0xa5, 0xc2, 0xff, 0xc3, 0x5b, 0xbf, 0x95, 0xa1, 0x72, 0xcc, 0x3d, 0xba, 0x01, 0xe5,
	0xd3, 0x2e, 0xbb, 0x8f, 0x63, 0x2a, 0x9f, 0x76, 0x51, 0xf7, 0xd8, 0x56, 0xae, 0x7b, 0xa8, 0xfb,
	0xec, 0x93, 0x5c, 0xf7, 0xe9, 0x67, 0xd0, 0xc0, 0x31, 0x60, 0xce, 0x7a, 0xb8, 0x6e, 0x86, 0xa9,
	0x3e, 0xe6, 0x5e, 0xe7, 0xa9, 0x4a, 0xa7, 0x22, 0x28, 0x7c, 0xbe, 0xb8, 0x74, 0x69, 0xc8, 0xfd,
	0xff, 0x19, 0xf2, 0x83, 0xdb, 0x43, 0xc6, 0xaa, 0xcf, 0x3e, 0x5d, 0xe2, 0x7d, 0x1b, 0x52, 0xae,
	0x8d, 0x30, 0xb2, 0xcb, 0xbe, 0x40, 0x63, 0x2e, 0x17, 0x4e, 0x8f, 0x7d, 0xb9, 0xec, 0xf4, 0x16,
	0x4e, 0x9f, 0x7d, 0xb5, 0xec, 0xf4, 0x5b, 0xbb, 0xf0, 0xce, 0xad, 0x35, 0xd3, 0x75, 0x68, 0xec,
	0x4d, 0x8d, 0x46, 0xe0, 0x94, 0xe8, 0x06, 0xc0, 0x23, 0xf5, 0x42, 0xfa, 0x99, 0x26, 0xad, 0x5f,
	0x08, 0xac, 0x1d, 0x0a, 0x23, 0x3c, 0x39, 0xc1, 0x40, 0x32, 0x58, 0xb5, 0x51, 0x3d, 0xba, 0x4c,
	0x31, 0x3d, 0x2b, 0x7c, 0x2e, 0x6d, 0x07, 0x18, 0xe2, 0x57, 0x18, 0x9f, 0x15, 0x9e, 0x2b, 0xfb,
	0x31, 0x0c, 0xa2, 0x40, 0x45, 0xd2, 0x3e, 0x06, 0x23, 0x74, 0x87, 0x2f, 0x11, 0xbb, 0xc7, 0x9e,
	0x49, 0xa4, 0x08, 0x4f, 0xf8, 0x00, 0x13, 0xd3, 0xe0, 0x0b, 0x80, 0x4f, 0x0d, 0xf4, 0xc5, 0xe0,
	0x90, 0x01, 0xee, 0x6c, 0xae, 0xb6, 0x5e, 0x93, 0xc5, 0x69, 0x43, 0x19, 0x6c, 0xce, 0xeb, 0xf3,
	0x93, 0x28, 0x8d, 0xe5, 0x18, 0xbf, 0x34, 0xa7, 0x44, 0x37, 0xc1, 0x29, 0x9c, 0xa3, 0xc4, 0x97,
	0x89, 0xf4, 0x1d, 0x42, 0xef, 0x01, 0x2b, 0xe8, 0x28, 0x10, 0x91, 0x3c, 0x3f, 0x10, 0x89, 0x91,
	0xa9, 0x12, 0x91, 0x53, 0xa5, 0x1f, 0xc1, 0x07, 0xb7, 0xdc, 0xaf, 0xe5, 0x8b, 0x87, 0x3f, 0xca,
	0x88, 0x3b, 0x35, 0xfa, 0x21, 0xbc, 0x57, 0x98, 0x8f, 0xa5, 0x56, 0xfe, 0xb9, 0x17, 0x3f, 0x97,
	0x89, 0x74, 0xe0, 0x5f, 0xab, 0xc8, 0xac, 0xef, 0x1e, 0x7b, 0x9f, 0x3f, 0x70, 0xd6, 0xf6, 0xe3,
	0xab, 0x6b, 0xb7, 0xf4, 0xe6, 0xda, 0x2d, 0xbd, 0xbd, 0x76, 0xc9, 0x4f, 0x33, 0x97, 0xfc, 0x3a,
	0x73, 0xc9, 0xef, 0x33, 0x97, 0x5c, 0xcd, 0x5c, 0xf2, 0xe7, 0xcc, 0x25, 0x7f, 0xcd, 0xdc, 0xd2,
	0xdb, 0x99, 0x4b, 0x7e, 0xbe, 0x71, 0x4b, 0x57, 0x37, 0x6e, 0xe9, 0xcd, 0x8d, 0x5b, 0x3a, 0xdb,
	0x9d, 0x28, 0xf3, 0x7c, 0x7a, 0xd1, 0x19, 0xeb, 0x70, 0x47, 0x24, 0x66, 0x3b, 0x94, 0xbe, 0x12,
	0xdb, 0x71, 0x20, 0xcc, 0xa5, 0x4e, 0x42, 0x7b, 0x08, 0x6f, 0xa7, 0xfe, 0xf7, 0xdb, 0x13, 0xbd,
	0x93, 0x9f, 0xd5, 0xaf, 0xcb, 0xab, 0x7b, 0xc3, 0x51, 0xc7, 0x33, 0xfe, 0x45, 0x0d, 0x8f, 0xe7,
	0xfe, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd9, 0x0a, 0xdb, 0xb8, 0xc7, 0x05, 0x00, 0x00,
}

func (x CordType) String() string {
	s, ok := CordType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TRS_VisualScaleMode) String() string {
	s, ok := TRS_VisualScaleMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ROU != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ROU))))
		i--
		dAtA[i] = 0x35
	}
	if m.S != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.S))))
		i--
		dAtA[i] = 0x29
	}
	if m.R != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.R))))
		i--
		dAtA[i] = 0x21
	}
	if m.Q != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Q))))
		i--
		dAtA[i] = 0x19
	}
	if m.CordType != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.CordType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FSInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FSInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ByteSize != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.ByteSize))
		i--
		dAtA[i] = 0x48
	}
	if m.ModifiedAt != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.ModifiedAt))
		i--
		dAtA[i] = 0x40
	}
	if m.CreatedAt != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintStd(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NameLen != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.NameLen))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintStd(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsDir {
		i--
		if m.IsDir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintStd(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Placement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Placement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Placement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metric != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.Metric))
		i--
		dAtA[i] = 0x60
	}
	if m.EulerZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EulerZ))))
		i--
		dAtA[i] = 0x4d
	}
	if m.EulerY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EulerY))))
		i--
		dAtA[i] = 0x45
	}
	if m.EulerX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EulerX))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Scale2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale2))))
		i--
		dAtA[i] = 0x35
	}
	if m.Scale1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale1))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Scale0 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale0))))
		i--
		dAtA[i] = 0x25
	}
	if m.Pos2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Pos2))))
		i--
		dAtA[i] = 0x19
	}
	if m.Pos1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Pos1))))
		i--
		dAtA[i] = 0x11
	}
	if m.Pos0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Pos0))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *BadgeDigit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadgeDigit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadgeDigit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AmplitudeModulus != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.AmplitudeModulus))
		i--
		dAtA[i] = 0x10
	}
	if m.Amplitude != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.Amplitude))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TRS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TRS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TRS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rotate3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xfd
	}
	if m.Rotate2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf5
	}
	if m.Rotate1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xed
	}
	if m.Scale3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xad
	}
	if m.Scale2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa5
	}
	if m.Scale1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9d
	}
	if m.ScaleMode != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.ScaleMode))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.X3 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X3))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd9
	}
	if m.X2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X2))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd1
	}
	if m.X1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X1))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc9
	}
	return len(dAtA) - i, nil
}

func (m *DataSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlobID != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.BlobID))
		i--
		dAtA[i] = 0x50
	}
	if len(m.StreamURI) > 0 {
		i -= len(m.StreamURI)
		copy(dAtA[i:], m.StreamURI)
		i = encodeVarintStd(dAtA, i, uint64(len(m.StreamURI)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.InlineData) > 0 {
		i -= len(m.InlineData)
		copy(dAtA[i:], m.InlineData)
		i = encodeVarintStd(dAtA, i, uint64(len(m.InlineData)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ByteSz != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.ByteSz))
		i--
		dAtA[i] = 0x30
	}
	if m.ByteOfs != 0 {
		i = encodeVarintStd(dAtA, i, uint64(m.ByteOfs))
		i--
		dAtA[i] = 0x28
	}
	return len(dAtA) - i, nil
}

func encodeVarintStd(dAtA []byte, offset int, v uint64) int {
	offset -= sovStd(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (this *Position) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Position)
	if !ok {
		that2, ok := that.(Position)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CordType != that1.CordType {
		return false
	}
	if this.Q != that1.Q {
		return false
	}
	if this.R != that1.R {
		return false
	}
	if this.S != that1.S {
		return false
	}
	if this.ROU != that1.ROU {
		return false
	}
	return true
}
func (this *FSInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FSInfo)
	if !ok {
		that2, ok := that.(FSInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.IsDir != that1.IsDir {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.NameLen != that1.NameLen {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.ModifiedAt != that1.ModifiedAt {
		return false
	}
	if this.ByteSize != that1.ByteSize {
		return false
	}
	return true
}
func (this *Placement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Placement)
	if !ok {
		that2, ok := that.(Placement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pos0 != that1.Pos0 {
		return false
	}
	if this.Pos1 != that1.Pos1 {
		return false
	}
	if this.Pos2 != that1.Pos2 {
		return false
	}
	if this.Scale0 != that1.Scale0 {
		return false
	}
	if this.Scale1 != that1.Scale1 {
		return false
	}
	if this.Scale2 != that1.Scale2 {
		return false
	}
	if this.EulerX != that1.EulerX {
		return false
	}
	if this.EulerY != that1.EulerY {
		return false
	}
	if this.EulerZ != that1.EulerZ {
		return false
	}
	if this.Metric != that1.Metric {
		return false
	}
	return true
}
func (this *BadgeDigit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BadgeDigit)
	if !ok {
		that2, ok := that.(BadgeDigit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Amplitude != that1.Amplitude {
		return false
	}
	if this.AmplitudeModulus != that1.AmplitudeModulus {
		return false
	}
	return true
}
func (this *TRS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TRS)
	if !ok {
		that2, ok := that.(TRS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.X1 != that1.X1 {
		return false
	}
	if this.X2 != that1.X2 {
		return false
	}
	if this.X3 != that1.X3 {
		return false
	}
	if this.ScaleMode != that1.ScaleMode {
		return false
	}
	if this.Scale1 != that1.Scale1 {
		return false
	}
	if this.Scale2 != that1.Scale2 {
		return false
	}
	if this.Scale3 != that1.Scale3 {
		return false
	}
	if this.Rotate1 != that1.Rotate1 {
		return false
	}
	if this.Rotate2 != that1.Rotate2 {
		return false
	}
	if this.Rotate3 != that1.Rotate3 {
		return false
	}
	return true
}
func (this *DataSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataSegment)
	if !ok {
		that2, ok := that.(DataSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ByteOfs != that1.ByteOfs {
		return false
	}
	if this.ByteSz != that1.ByteSz {
		return false
	}
	if !bytes.Equal(this.InlineData, that1.InlineData) {
		return false
	}
	if this.StreamURI != that1.StreamURI {
		return false
	}
	if this.BlobID != that1.BlobID {
		return false
	}
	return true
}
func (this *Position) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&std.Position{")
	s = append(s, "CordType: "+fmt.Sprintf("%#v", this.CordType)+",\n")
	s = append(s, "Q: "+fmt.Sprintf("%#v", this.Q)+",\n")
	s = append(s, "R: "+fmt.Sprintf("%#v", this.R)+",\n")
	s = append(s, "S: "+fmt.Sprintf("%#v", this.S)+",\n")
	s = append(s, "ROU: "+fmt.Sprintf("%#v", this.ROU)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FSInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&std.FSInfo{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "IsDir: "+fmt.Sprintf("%#v", this.IsDir)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "NameLen: "+fmt.Sprintf("%#v", this.NameLen)+",\n")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	s = append(s, "ModifiedAt: "+fmt.Sprintf("%#v", this.ModifiedAt)+",\n")
	s = append(s, "ByteSize: "+fmt.Sprintf("%#v", this.ByteSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Placement) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&std.Placement{")
	s = append(s, "Pos0: "+fmt.Sprintf("%#v", this.Pos0)+",\n")
	s = append(s, "Pos1: "+fmt.Sprintf("%#v", this.Pos1)+",\n")
	s = append(s, "Pos2: "+fmt.Sprintf("%#v", this.Pos2)+",\n")
	s = append(s, "Scale0: "+fmt.Sprintf("%#v", this.Scale0)+",\n")
	s = append(s, "Scale1: "+fmt.Sprintf("%#v", this.Scale1)+",\n")
	s = append(s, "Scale2: "+fmt.Sprintf("%#v", this.Scale2)+",\n")
	s = append(s, "EulerX: "+fmt.Sprintf("%#v", this.EulerX)+",\n")
	s = append(s, "EulerY: "+fmt.Sprintf("%#v", this.EulerY)+",\n")
	s = append(s, "EulerZ: "+fmt.Sprintf("%#v", this.EulerZ)+",\n")
	s = append(s, "Metric: "+fmt.Sprintf("%#v", this.Metric)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BadgeDigit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&std.BadgeDigit{")
	s = append(s, "Amplitude: "+fmt.Sprintf("%#v", this.Amplitude)+",\n")
	s = append(s, "AmplitudeModulus: "+fmt.Sprintf("%#v", this.AmplitudeModulus)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TRS) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&std.TRS{")
	s = append(s, "X1: "+fmt.Sprintf("%#v", this.X1)+",\n")
	s = append(s, "X2: "+fmt.Sprintf("%#v", this.X2)+",\n")
	s = append(s, "X3: "+fmt.Sprintf("%#v", this.X3)+",\n")
	s = append(s, "ScaleMode: "+fmt.Sprintf("%#v", this.ScaleMode)+",\n")
	s = append(s, "Scale1: "+fmt.Sprintf("%#v", this.Scale1)+",\n")
	s = append(s, "Scale2: "+fmt.Sprintf("%#v", this.Scale2)+",\n")
	s = append(s, "Scale3: "+fmt.Sprintf("%#v", this.Scale3)+",\n")
	s = append(s, "Rotate1: "+fmt.Sprintf("%#v", this.Rotate1)+",\n")
	s = append(s, "Rotate2: "+fmt.Sprintf("%#v", this.Rotate2)+",\n")
	s = append(s, "Rotate3: "+fmt.Sprintf("%#v", this.Rotate3)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&std.DataSegment{")
	s = append(s, "ByteOfs: "+fmt.Sprintf("%#v", this.ByteOfs)+",\n")
	s = append(s, "ByteSz: "+fmt.Sprintf("%#v", this.ByteSz)+",\n")
	s = append(s, "InlineData: "+fmt.Sprintf("%#v", this.InlineData)+",\n")
	s = append(s, "StreamURI: "+fmt.Sprintf("%#v", this.StreamURI)+",\n")
	s = append(s, "BlobID: "+fmt.Sprintf("%#v", this.BlobID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringStd(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CordType != 0 {
		n += 1 + sovStd(uint64(m.CordType))
	}
	if m.Q != 0 {
		n += 9
	}
	if m.R != 0 {
		n += 9
	}
	if m.S != 0 {
		n += 9
	}
	if m.ROU != 0 {
		n += 5
	}
	return n
}

func (m *FSInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovStd(uint64(l))
	}
	if m.IsDir {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStd(uint64(l))
	}
	if m.NameLen != 0 {
		n += 1 + sovStd(uint64(m.NameLen))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovStd(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovStd(uint64(m.CreatedAt))
	}
	if m.ModifiedAt != 0 {
		n += 1 + sovStd(uint64(m.ModifiedAt))
	}
	if m.ByteSize != 0 {
		n += 1 + sovStd(uint64(m.ByteSize))
	}
	return n
}

func (m *Placement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos0 != 0 {
		n += 9
	}
	if m.Pos1 != 0 {
		n += 9
	}
	if m.Pos2 != 0 {
		n += 9
	}
	if m.Scale0 != 0 {
		n += 5
	}
	if m.Scale1 != 0 {
		n += 5
	}
	if m.Scale2 != 0 {
		n += 5
	}
	if m.EulerX != 0 {
		n += 5
	}
	if m.EulerY != 0 {
		n += 5
	}
	if m.EulerZ != 0 {
		n += 5
	}
	if m.Metric != 0 {
		n += 1 + sovStd(uint64(m.Metric))
	}
	return n
}

func (m *BadgeDigit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amplitude != 0 {
		n += 1 + sovStd(uint64(m.Amplitude))
	}
	if m.AmplitudeModulus != 0 {
		n += 1 + sovStd(uint64(m.AmplitudeModulus))
	}
	return n
}

func (m *TRS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X1 != 0 {
		n += 10
	}
	if m.X2 != 0 {
		n += 10
	}
	if m.X3 != 0 {
		n += 10
	}
	if m.ScaleMode != 0 {
		n += 2 + sovStd(uint64(m.ScaleMode))
	}
	if m.Scale1 != 0 {
		n += 6
	}
	if m.Scale2 != 0 {
		n += 6
	}
	if m.Scale3 != 0 {
		n += 6
	}
	if m.Rotate1 != 0 {
		n += 6
	}
	if m.Rotate2 != 0 {
		n += 6
	}
	if m.Rotate3 != 0 {
		n += 6
	}
	return n
}

func (m *DataSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ByteOfs != 0 {
		n += 1 + sovStd(uint64(m.ByteOfs))
	}
	if m.ByteSz != 0 {
		n += 1 + sovStd(uint64(m.ByteSz))
	}
	l = len(m.InlineData)
	if l > 0 {
		n += 1 + l + sovStd(uint64(l))
	}
	l = len(m.StreamURI)
	if l > 0 {
		n += 1 + l + sovStd(uint64(l))
	}
	if m.BlobID != 0 {
		n += 1 + sovStd(uint64(m.BlobID))
	}
	return n
}

func sovStd(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStd(x uint64) (n int) {
	return sovStd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Position) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Position{`,
		`CordType:` + fmt.Sprintf("%v", this.CordType) + `,`,
		`Q:` + fmt.Sprintf("%v", this.Q) + `,`,
		`R:` + fmt.Sprintf("%v", this.R) + `,`,
		`S:` + fmt.Sprintf("%v", this.S) + `,`,
		`ROU:` + fmt.Sprintf("%v", this.ROU) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FSInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FSInfo{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`IsDir:` + fmt.Sprintf("%v", this.IsDir) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`NameLen:` + fmt.Sprintf("%v", this.NameLen) + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`CreatedAt:` + fmt.Sprintf("%v", this.CreatedAt) + `,`,
		`ModifiedAt:` + fmt.Sprintf("%v", this.ModifiedAt) + `,`,
		`ByteSize:` + fmt.Sprintf("%v", this.ByteSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Placement) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Placement{`,
		`Pos0:` + fmt.Sprintf("%v", this.Pos0) + `,`,
		`Pos1:` + fmt.Sprintf("%v", this.Pos1) + `,`,
		`Pos2:` + fmt.Sprintf("%v", this.Pos2) + `,`,
		`Scale0:` + fmt.Sprintf("%v", this.Scale0) + `,`,
		`Scale1:` + fmt.Sprintf("%v", this.Scale1) + `,`,
		`Scale2:` + fmt.Sprintf("%v", this.Scale2) + `,`,
		`EulerX:` + fmt.Sprintf("%v", this.EulerX) + `,`,
		`EulerY:` + fmt.Sprintf("%v", this.EulerY) + `,`,
		`EulerZ:` + fmt.Sprintf("%v", this.EulerZ) + `,`,
		`Metric:` + fmt.Sprintf("%v", this.Metric) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BadgeDigit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BadgeDigit{`,
		`Amplitude:` + fmt.Sprintf("%v", this.Amplitude) + `,`,
		`AmplitudeModulus:` + fmt.Sprintf("%v", this.AmplitudeModulus) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TRS) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TRS{`,
		`X1:` + fmt.Sprintf("%v", this.X1) + `,`,
		`X2:` + fmt.Sprintf("%v", this.X2) + `,`,
		`X3:` + fmt.Sprintf("%v", this.X3) + `,`,
		`ScaleMode:` + fmt.Sprintf("%v", this.ScaleMode) + `,`,
		`Scale1:` + fmt.Sprintf("%v", this.Scale1) + `,`,
		`Scale2:` + fmt.Sprintf("%v", this.Scale2) + `,`,
		`Scale3:` + fmt.Sprintf("%v", this.Scale3) + `,`,
		`Rotate1:` + fmt.Sprintf("%v", this.Rotate1) + `,`,
		`Rotate2:` + fmt.Sprintf("%v", this.Rotate2) + `,`,
		`Rotate3:` + fmt.Sprintf("%v", this.Rotate3) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSegment{`,
		`ByteOfs:` + fmt.Sprintf("%v", this.ByteOfs) + `,`,
		`ByteSz:` + fmt.Sprintf("%v", this.ByteSz) + `,`,
		`InlineData:` + fmt.Sprintf("%v", this.InlineData) + `,`,
		`StreamURI:` + fmt.Sprintf("%v", this.StreamURI) + `,`,
		`BlobID:` + fmt.Sprintf("%v", this.BlobID) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringStd(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CordType", wireType)
			}
			m.CordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CordType |= CordType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Q = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.R = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.S = float64(math.Float64frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ROU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ROU = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDir = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameLen", wireType)
			}
			m.NameLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NameLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedAt", wireType)
			}
			m.ModifiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteSize", wireType)
			}
			m.ByteSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Placement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Placement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Placement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos0", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Pos0 = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Pos1 = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos2", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Pos2 = float64(math.Float64frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale0 = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale1 = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale2 = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EulerX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EulerX = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EulerY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EulerY = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EulerZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EulerZ = float32(math.Float32frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= amp.Metric(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BadgeDigit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadgeDigit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadgeDigit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amplitude", wireType)
			}
			m.Amplitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amplitude |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmplitudeModulus", wireType)
			}
			m.AmplitudeModulus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmplitudeModulus |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TRS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TRS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TRS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 41:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X1 = float64(math.Float64frombits(v))
		case 42:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X2", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X2 = float64(math.Float64frombits(v))
		case 43:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X3", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X3 = float64(math.Float64frombits(v))
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleMode", wireType)
			}
			m.ScaleMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScaleMode |= TRS_VisualScaleMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale1 = float32(math.Float32frombits(v))
		case 52:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale2 = float32(math.Float32frombits(v))
		case 53:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale3 = float32(math.Float32frombits(v))
		case 61:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate1 = float32(math.Float32frombits(v))
		case 62:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate2 = float32(math.Float32frombits(v))
		case 63:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate3 = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteOfs", wireType)
			}
			m.ByteOfs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteOfs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteSz", wireType)
			}
			m.ByteSz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteSz |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStd
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineData = append(m.InlineData[:0], dAtA[iNdEx:postIndex]...)
			if m.InlineData == nil {
				m.InlineData = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlobID", wireType)
			}
			m.BlobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStd
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStd
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStd
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStd        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStd          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStd = fmt.Errorf("proto: unexpected end of group")
)
