// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: amp.crates.proto

// Contains data structures used by the client for content management and deployment

package crates

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AssetFlags int32

const (
	NoFlags         AssetFlags = 0
	IsTexture       AssetFlags = 1
	IsSprite        AssetFlags = 2
	IsMaterial      AssetFlags = 4
	IsPlaceable     AssetFlags = 8
	IsRectTransform AssetFlags = 16
	// HasIcon means that this Asset includes an icon with the same name (and has IsIcon set),
	HasIcon AssetFlags = 256
	// IsPrivate means this item is not intended for general use and is not normally visible.
	IsPrivate AssetFlags = 512
	// IsSkybox means this is a transform containing a Skybox component.
	IsSkybox AssetFlags = 1024
	// AutoScale means this asset should be placed with auto scale enabled by default.
	AutoScale AssetFlags = 2048
	// IsSurface means this asset behaves like terrain and/or should be considered a constituent part of a scene.
	// These objects should be opaque and have colliders attached to them
	// e.g.  a building, a terrain formation, a wall
	IsSurface AssetFlags = 4096
)

var AssetFlags_name = map[int32]string{
	0:    "NoFlags",
	1:    "IsTexture",
	2:    "IsSprite",
	4:    "IsMaterial",
	8:    "IsPlaceable",
	16:   "IsRectTransform",
	256:  "HasIcon",
	512:  "IsPrivate",
	1024: "IsSkybox",
	2048: "AutoScale",
	4096: "IsSurface",
}

var AssetFlags_value = map[string]int32{
	"NoFlags":         0,
	"IsTexture":       1,
	"IsSprite":        2,
	"IsMaterial":      4,
	"IsPlaceable":     8,
	"IsRectTransform": 16,
	"HasIcon":         256,
	"IsPrivate":       512,
	"IsSkybox":        1024,
	"AutoScale":       2048,
	"IsSurface":       4096,
}

func (AssetFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_39eb848e8ca52014, []int{0}
}

// Enum values should be three base-10 digits corresponding to the major, minor, and revision number.
type CrateSchema int32

const (
	UndefinedSchema CrateSchema = 0
	// v100 (April 2020) should be used for CrateInfo.CrateSchema
	v100 CrateSchema = 100
)

var CrateSchema_name = map[int32]string{
	0:   "UndefinedSchema",
	100: "v100",
}

var CrateSchema_value = map[string]int32{
	"UndefinedSchema": 0,
	"v100":            100,
}

func (CrateSchema) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_39eb848e8ca52014, []int{1}
}

type AssetEntry struct {
	// AssetFlags specifies properties about this AssetEntry.
	Flags AssetFlags `protobuf:"varint,1,opt,name=Flags,proto3,enum=crates.AssetFlags" json:"Flags,omitempty"`
	// EntryURI is a Unix-style pathname that identifies an asset within a crate.
	// By convention, this URI does *not* start or end with '/'
	// An asset URI has the form "{CrateURI}/{EntryURI}"
	// If two or more assets have the same EntryURI, then only one is accessible.
	EntryURI string `protobuf:"bytes,2,opt,name=EntryURI,proto3" json:"EntryURI,omitempty"`
	// Label is the human-readable label for this asset.
	Label string `protobuf:"bytes,3,opt,name=Label,proto3" json:"Label,omitempty"`
	// AssetID is an alternative name for this asset that is used to identify the asset in code.
	// DEPRECATED -- EntryURI should be used instead of AssetID (or use [2]uint64 that Unity returns)
	AssetID string `protobuf:"bytes,4,opt,name=AssetID,proto3" json:"AssetID,omitempty"`
	// CenterX and CenterZ specify the positional center of this asset (and are typically 0).
	// CenterY is the distance above the baseline (y=0) to the y center-point height of this asset.
	// Y is considered to be the *vertical* (up) direction and by convention rests on the plane y=0.
	CenterX float32 `protobuf:"fixed32,5,opt,name=CenterX,proto3" json:"CenterX,omitempty"`
	CenterY float32 `protobuf:"fixed32,6,opt,name=CenterY,proto3" json:"CenterY,omitempty"`
	CenterZ float32 `protobuf:"fixed32,7,opt,name=CenterZ,proto3" json:"CenterZ,omitempty"`
	// Extents specify the distance from the center to the extent of the asset on each axis.
	ExtentsX float32 `protobuf:"fixed32,10,opt,name=ExtentsX,proto3" json:"ExtentsX,omitempty"`
	ExtentsY float32 `protobuf:"fixed32,11,opt,name=ExtentsY,proto3" json:"ExtentsY,omitempty"`
	ExtentsZ float32 `protobuf:"fixed32,12,opt,name=ExtentsZ,proto3" json:"ExtentsZ,omitempty"`
	// Reserved for runtime use -- defaults to empty.
	LocalURI string `protobuf:"bytes,30,opt,name=LocalURI,proto3" json:"LocalURI,omitempty"`
	// Comma-delimited and whitespace-trimmed list of tags.
	Tags string `protobuf:"bytes,31,opt,name=Tags,proto3" json:"Tags,omitempty"`
	// A short phrase or fragment describing this asset, starting with an article where appropriate. e.g.:
	//
	//	"A typical 6 crew member fire truck"
	//	"A leading U.S. naval ship-based helicopter"
	//	"The Texas capitol building located in Austin"
	//	"An animated scared-geometry inspired flat seal"
	ShortDesc string `protobuf:"bytes,32,opt,name=ShortDesc,proto3" json:"ShortDesc,omitempty"`
}

func (m *AssetEntry) Reset()      { *m = AssetEntry{} }
func (*AssetEntry) ProtoMessage() {}
func (*AssetEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_39eb848e8ca52014, []int{0}
}
func (m *AssetEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetEntry.Merge(m, src)
}
func (m *AssetEntry) XXX_Size() int {
	return m.Size()
}
func (m *AssetEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AssetEntry proto.InternalMessageInfo

func (m *AssetEntry) GetFlags() AssetFlags {
	if m != nil {
		return m.Flags
	}
	return NoFlags
}

func (m *AssetEntry) GetEntryURI() string {
	if m != nil {
		return m.EntryURI
	}
	return ""
}

func (m *AssetEntry) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *AssetEntry) GetAssetID() string {
	if m != nil {
		return m.AssetID
	}
	return ""
}

func (m *AssetEntry) GetCenterX() float32 {
	if m != nil {
		return m.CenterX
	}
	return 0
}

func (m *AssetEntry) GetCenterY() float32 {
	if m != nil {
		return m.CenterY
	}
	return 0
}

func (m *AssetEntry) GetCenterZ() float32 {
	if m != nil {
		return m.CenterZ
	}
	return 0
}

func (m *AssetEntry) GetExtentsX() float32 {
	if m != nil {
		return m.ExtentsX
	}
	return 0
}

func (m *AssetEntry) GetExtentsY() float32 {
	if m != nil {
		return m.ExtentsY
	}
	return 0
}

func (m *AssetEntry) GetExtentsZ() float32 {
	if m != nil {
		return m.ExtentsZ
	}
	return 0
}

func (m *AssetEntry) GetLocalURI() string {
	if m != nil {
		return m.LocalURI
	}
	return ""
}

func (m *AssetEntry) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *AssetEntry) GetShortDesc() string {
	if m != nil {
		return m.ShortDesc
	}
	return ""
}

type BundleManifest struct {
	// BundleTitle is how the outside world sees this bundle and has no other impact.
	// This means it can change from build to build and contain any Unicode characters.
	BundleTitle string `protobuf:"bytes,2,opt,name=BundleTitle,proto3" json:"BundleTitle,omitempty"`
	// BundleNameID is how this bundle is internally identified and expressed as the filename of this bundle.
	// This is case sensitive, contains only path-safe characters (sans /:\<>|?*\"), and does not terminate in '.' or whitespace.
	BundleNameID string        `protobuf:"bytes,3,opt,name=BundleNameID,proto3" json:"BundleNameID,omitempty"`
	Assets       []*AssetEntry `protobuf:"bytes,10,rep,name=Assets,proto3" json:"Assets,omitempty"`
	LoadAllHint  bool          `protobuf:"varint,20,opt,name=LoadAllHint,proto3" json:"LoadAllHint,omitempty"`
}

func (m *BundleManifest) Reset()      { *m = BundleManifest{} }
func (*BundleManifest) ProtoMessage() {}
func (*BundleManifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_39eb848e8ca52014, []int{1}
}
func (m *BundleManifest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BundleManifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BundleManifest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BundleManifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BundleManifest.Merge(m, src)
}
func (m *BundleManifest) XXX_Size() int {
	return m.Size()
}
func (m *BundleManifest) XXX_DiscardUnknown() {
	xxx_messageInfo_BundleManifest.DiscardUnknown(m)
}

var xxx_messageInfo_BundleManifest proto.InternalMessageInfo

func (m *BundleManifest) GetBundleTitle() string {
	if m != nil {
		return m.BundleTitle
	}
	return ""
}

func (m *BundleManifest) GetBundleNameID() string {
	if m != nil {
		return m.BundleNameID
	}
	return ""
}

func (m *BundleManifest) GetAssets() []*AssetEntry {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *BundleManifest) GetLoadAllHint() bool {
	if m != nil {
		return m.LoadAllHint
	}
	return false
}

// CrateInfo represents a Crate, the fundamental unit of amp's asset/package manager.
type CrateInfo struct {
	// CrateSchema communicates which build and packaging schema was used for this crate build.
	// This value should be the integer value of a valid CrateSchema.vNNN enum.
	CrateSchema int32 `protobuf:"varint,1,opt,name=CrateSchema,proto3" json:"CrateSchema,omitempty"`
	// InstID is 0 by default and reserved for a runtime manager to reference a crate via issuing integers.
	// If non-zero, it will not change and no other instance will have the same value.
	InstID uint32 `protobuf:"varint,2,opt,name=InstID,proto3" json:"InstID,omitempty"`
	// CrateURI takes the form "{PublisherID}/{CrateID}" and is used to globally reference assets in this crate.
	// This URI string can only contain chars in [A-Za-z0-9_.-] (other than the separating '/' char).
	// PublisherID uniquely identifies the author/owner/publisher of this crate (and potentially other crates).
	// CrateID uniquely identifies this crate for the given publisher and all subsequent revisions.
	//
	//	"plan-systems.org/plan.app.ui"
	//	"plan-systems.org/about-plan-systems"
	//	"themushroom.farm/land"
	//	"themushroom.farm/mycology-201"
	//	"the-smiths.family/123-Maple"
	CrateURI string `protobuf:"bytes,4,opt,name=CrateURI,proto3" json:"CrateURI,omitempty"`
	// PublisherName is a human-readable name of the author/owner/publisher of this crate and can change without repercussions (i.e. is purely optical).
	PublisherName string `protobuf:"bytes,6,opt,name=PublisherName,proto3" json:"PublisherName,omitempty"`
	// CrateName is a human-readable title for this crate and can change without repercussions.
	CrateName string `protobuf:"bytes,10,opt,name=CrateName,proto3" json:"CrateName,omitempty"`
	// ShortDesc describes this crate in a brief phrase.
	ShortDesc string `protobuf:"bytes,11,opt,name=ShortDesc,proto3" json:"ShortDesc,omitempty"`
	// Comma-delimited and whitespace-trimmed list of tags.
	Tags string `protobuf:"bytes,15,opt,name=Tags,proto3" json:"Tags,omitempty"`
	// TimeCreated is the UTC value (in seconds) when this crate was first created (and does not change).
	TimeCreated int64 `protobuf:"varint,30,opt,name=TimeCreated,proto3" json:"TimeCreated,omitempty"`
	// TimeBuilt is the UTC value (in seconds) when this crate was built.
	TimeBuilt int64 `protobuf:"varint,31,opt,name=TimeBuilt,proto3" json:"TimeBuilt,omitempty"`
	// VersionID uniquely identifies this build and has the form "v{MajorNum}.{MinorNum}.{BuildNum}"
	// e.g. "v1.11.201"
	MajorVersion int32 `protobuf:"varint,40,opt,name=MajorVersion,proto3" json:"MajorVersion,omitempty"`
	MinorVersion int32 `protobuf:"varint,41,opt,name=MinorVersion,proto3" json:"MinorVersion,omitempty"`
	BuildNumber  int32 `protobuf:"varint,42,opt,name=BuildNumber,proto3" json:"BuildNumber,omitempty"`
	// BuildID uniquely identifies a particular crate build/version.
	// This value should have no spaces and only have '.', '_', or '-' (and starts and ends with an alphanumeric character).
	// By convention, the format is "yyMMdd-{VersionID}" (so that sorting by BuildID string yields the most recent release).
	// e.g. "210320-v0.1.11"
	BuildID string `protobuf:"bytes,45,opt,name=BuildID,proto3" json:"BuildID,omitempty"`
	// HomeURL is an optional link that allows a human to learn more about this crate.
	HomeURL string `protobuf:"bytes,50,opt,name=HomeURL,proto3" json:"HomeURL,omitempty"`
	// URL is an optional string available to specify a URL to download this crate.
	URL string `protobuf:"bytes,55,opt,name=URL,proto3" json:"URL,omitempty"`
	// Approximate size of this crate in bytes (or 0 if unknown).
	ApproxSize int64 `protobuf:"varint,60,opt,name=ApproxSize,proto3" json:"ApproxSize,omitempty"`
}

func (m *CrateInfo) Reset()      { *m = CrateInfo{} }
func (*CrateInfo) ProtoMessage() {}
func (*CrateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_39eb848e8ca52014, []int{2}
}
func (m *CrateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrateInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrateInfo.Merge(m, src)
}
func (m *CrateInfo) XXX_Size() int {
	return m.Size()
}
func (m *CrateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CrateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CrateInfo proto.InternalMessageInfo

func (m *CrateInfo) GetCrateSchema() int32 {
	if m != nil {
		return m.CrateSchema
	}
	return 0
}

func (m *CrateInfo) GetInstID() uint32 {
	if m != nil {
		return m.InstID
	}
	return 0
}

func (m *CrateInfo) GetCrateURI() string {
	if m != nil {
		return m.CrateURI
	}
	return ""
}

func (m *CrateInfo) GetPublisherName() string {
	if m != nil {
		return m.PublisherName
	}
	return ""
}

func (m *CrateInfo) GetCrateName() string {
	if m != nil {
		return m.CrateName
	}
	return ""
}

func (m *CrateInfo) GetShortDesc() string {
	if m != nil {
		return m.ShortDesc
	}
	return ""
}

func (m *CrateInfo) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *CrateInfo) GetTimeCreated() int64 {
	if m != nil {
		return m.TimeCreated
	}
	return 0
}

func (m *CrateInfo) GetTimeBuilt() int64 {
	if m != nil {
		return m.TimeBuilt
	}
	return 0
}

func (m *CrateInfo) GetMajorVersion() int32 {
	if m != nil {
		return m.MajorVersion
	}
	return 0
}

func (m *CrateInfo) GetMinorVersion() int32 {
	if m != nil {
		return m.MinorVersion
	}
	return 0
}

func (m *CrateInfo) GetBuildNumber() int32 {
	if m != nil {
		return m.BuildNumber
	}
	return 0
}

func (m *CrateInfo) GetBuildID() string {
	if m != nil {
		return m.BuildID
	}
	return ""
}

func (m *CrateInfo) GetHomeURL() string {
	if m != nil {
		return m.HomeURL
	}
	return ""
}

func (m *CrateInfo) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *CrateInfo) GetApproxSize() int64 {
	if m != nil {
		return m.ApproxSize
	}
	return 0
}

// CrateManifest is the top-level manifest/catalog for a amp asset module called a "crate".
// It contains catalog and type info that amp loads at runtime to know what's inside binary asset bundles without having to load them.
//
// A reference to a amp asset is via a URI with the form:
//
//	assetURI := "PublisherID/CrateID[@CrateBuildID]/{AssetEntry.Pathname}"
type CrateManifest struct {
	Info *CrateInfo `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	// IconBundleName is the bundle name ID of the bundle containing icons (Sprites) used to represent the "real" crate assets.
	// Asset name IDs in this bundle correspond to assets in all the other Crate's bundles.
	IconBundleName string            `protobuf:"bytes,5,opt,name=IconBundleName,proto3" json:"IconBundleName,omitempty"`
	Bundles        []*BundleManifest `protobuf:"bytes,10,rep,name=Bundles,proto3" json:"Bundles,omitempty"`
}

func (m *CrateManifest) Reset()      { *m = CrateManifest{} }
func (*CrateManifest) ProtoMessage() {}
func (*CrateManifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_39eb848e8ca52014, []int{3}
}
func (m *CrateManifest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrateManifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrateManifest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrateManifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrateManifest.Merge(m, src)
}
func (m *CrateManifest) XXX_Size() int {
	return m.Size()
}
func (m *CrateManifest) XXX_DiscardUnknown() {
	xxx_messageInfo_CrateManifest.DiscardUnknown(m)
}

var xxx_messageInfo_CrateManifest proto.InternalMessageInfo

func (m *CrateManifest) GetInfo() *CrateInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CrateManifest) GetIconBundleName() string {
	if m != nil {
		return m.IconBundleName
	}
	return ""
}

func (m *CrateManifest) GetBundles() []*BundleManifest {
	if m != nil {
		return m.Bundles
	}
	return nil
}

// CrateSnapshot is a general purpose container to track multiple crates and associated build IDs.
type CrateSnapshot struct {
	RevID int64 `protobuf:"varint,1,opt,name=RevID,proto3" json:"RevID,omitempty"`
	// This is a template URL where the symbols "CrateURI", "CrateBuildID", "PlatformID" are delimited with { }.
	// The symbol "{.}" is to be replaced with a local pathname if the URL refers to a local file system pathname.
	// e.g. "https://whatever.com/{CrateURI}__{CrateBuildID}.{PlatformID}.crate"
	//
	//	"{.}/{CrateURI}__{CrateBuildID}.{PlatformID}.crate"
	DownloadURL string       `protobuf:"bytes,3,opt,name=DownloadURL,proto3" json:"DownloadURL,omitempty"`
	Crates      []*CrateInfo `protobuf:"bytes,10,rep,name=Crates,proto3" json:"Crates,omitempty"`
}

func (m *CrateSnapshot) Reset()      { *m = CrateSnapshot{} }
func (*CrateSnapshot) ProtoMessage() {}
func (*CrateSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_39eb848e8ca52014, []int{4}
}
func (m *CrateSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrateSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrateSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrateSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrateSnapshot.Merge(m, src)
}
func (m *CrateSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CrateSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CrateSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CrateSnapshot proto.InternalMessageInfo

func (m *CrateSnapshot) GetRevID() int64 {
	if m != nil {
		return m.RevID
	}
	return 0
}

func (m *CrateSnapshot) GetDownloadURL() string {
	if m != nil {
		return m.DownloadURL
	}
	return ""
}

func (m *CrateSnapshot) GetCrates() []*CrateInfo {
	if m != nil {
		return m.Crates
	}
	return nil
}

// AppVars help the amp runtime manage dynamic Go or Clib module loading
// This can be thought of a data record for a registered app in the art-media-platform ecosystem.
type AppVars struct {
	// AppDomain is the domain name used for primary queries (e.g. "plan-systems.org")
	AppDomain string `protobuf:"bytes,2,opt,name=AppDomain,proto3" json:"AppDomain,omitempty"`
	// AppDesc succinctly describes this org and is for humans.
	AppDesc string `protobuf:"bytes,4,opt,name=AppDesc,proto3" json:"AppDesc,omitempty"`
	// OrgHomeURL is the home link for this org (e.g. "https://plan-systems.org")
	OrgHomeURL string `protobuf:"bytes,6,opt,name=OrgHomeURL,proto3" json:"OrgHomeURL,omitempty"`
	// AppHomeURL points to the home URL for the app
	AppHomeURL string `protobuf:"bytes,12,opt,name=AppHomeURL,proto3" json:"AppHomeURL,omitempty"`
	// CrateSnapshotURL specifies where to load this org's CrateSnapshot
	CrateSnapshotURL string `protobuf:"bytes,14,opt,name=CrateSnapshotURL,proto3" json:"CrateSnapshotURL,omitempty"`
	// AppDownloadURLs are a download URL for a given platform.
	// A key of "" denotes an unknown platform
	AppDownloadURLs map[string]string `protobuf:"bytes,16,rep,name=AppDownloadURLs,proto3" json:"AppDownloadURLs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// URLSchemes declare URL prefixes used to check if in incoming URL from the OS should be handled.
	// The first entry is the primary scheme and the rest are alternately recognized schemes.
	//
	// If an URL is matched, it is replaced by "amp://" and then passed to the amp runtime.
	URLSchemes []string `protobuf:"bytes,18,rep,name=URLSchemes,proto3" json:"URLSchemes,omitempty"`
	// Overrides default settings
	Settings map[string]string `protobuf:"bytes,20,rep,name=Settings,proto3" json:"Settings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Links is a list of channel URIs for easy access.
	Links []*KVEntry `protobuf:"bytes,40,rep,name=Links,proto3" json:"Links,omitempty"`
}

func (m *AppVars) Reset()      { *m = AppVars{} }
func (*AppVars) ProtoMessage() {}
func (*AppVars) Descriptor() ([]byte, []int) {
	return fileDescriptor_39eb848e8ca52014, []int{5}
}
func (m *AppVars) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppVars) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppVars.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppVars) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppVars.Merge(m, src)
}
func (m *AppVars) XXX_Size() int {
	return m.Size()
}
func (m *AppVars) XXX_DiscardUnknown() {
	xxx_messageInfo_AppVars.DiscardUnknown(m)
}

var xxx_messageInfo_AppVars proto.InternalMessageInfo

func (m *AppVars) GetAppDomain() string {
	if m != nil {
		return m.AppDomain
	}
	return ""
}

func (m *AppVars) GetAppDesc() string {
	if m != nil {
		return m.AppDesc
	}
	return ""
}

func (m *AppVars) GetOrgHomeURL() string {
	if m != nil {
		return m.OrgHomeURL
	}
	return ""
}

func (m *AppVars) GetAppHomeURL() string {
	if m != nil {
		return m.AppHomeURL
	}
	return ""
}

func (m *AppVars) GetCrateSnapshotURL() string {
	if m != nil {
		return m.CrateSnapshotURL
	}
	return ""
}

func (m *AppVars) GetAppDownloadURLs() map[string]string {
	if m != nil {
		return m.AppDownloadURLs
	}
	return nil
}

func (m *AppVars) GetURLSchemes() []string {
	if m != nil {
		return m.URLSchemes
	}
	return nil
}

func (m *AppVars) GetSettings() map[string]string {
	if m != nil {
		return m.Settings
	}
	return nil
}

func (m *AppVars) GetLinks() []*KVEntry {
	if m != nil {
		return m.Links
	}
	return nil
}

// KVEntry is a generic entry for any key-value pair.
type KVEntry struct {
	Key   string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *KVEntry) Reset()      { *m = KVEntry{} }
func (*KVEntry) ProtoMessage() {}
func (*KVEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_39eb848e8ca52014, []int{6}
}
func (m *KVEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVEntry.Merge(m, src)
}
func (m *KVEntry) XXX_Size() int {
	return m.Size()
}
func (m *KVEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_KVEntry.DiscardUnknown(m)
}

var xxx_messageInfo_KVEntry proto.InternalMessageInfo

func (m *KVEntry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KVEntry) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func init() {
	proto.RegisterEnum("crates.AssetFlags", AssetFlags_name, AssetFlags_value)
	proto.RegisterEnum("crates.CrateSchema", CrateSchema_name, CrateSchema_value)
	proto.RegisterType((*AssetEntry)(nil), "crates.AssetEntry")
	proto.RegisterType((*BundleManifest)(nil), "crates.BundleManifest")
	proto.RegisterType((*CrateInfo)(nil), "crates.CrateInfo")
	proto.RegisterType((*CrateManifest)(nil), "crates.CrateManifest")
	proto.RegisterType((*CrateSnapshot)(nil), "crates.CrateSnapshot")
	proto.RegisterType((*AppVars)(nil), "crates.AppVars")
	proto.RegisterMapType((map[string]string)(nil), "crates.AppVars.AppDownloadURLsEntry")
	proto.RegisterMapType((map[string]string)(nil), "crates.AppVars.SettingsEntry")
	proto.RegisterType((*KVEntry)(nil), "crates.KVEntry")
}

func init() { proto.RegisterFile("amp.crates.proto", fileDescriptor_39eb848e8ca52014) }

var fileDescriptor_39eb848e8ca52014 = []byte{
	// 1069 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcb, 0x4e, 0x23, 0x47,
	0x17, 0x76, 0xdb, 0xc6, 0x97, 0x63, 0x0c, 0xfd, 0xd7, 0x8f, 0x46, 0xa5, 0x51, 0xd2, 0xb1, 0xac,
	0x99, 0xc8, 0x83, 0x12, 0x34, 0x43, 0x16, 0xb9, 0x6e, 0x0c, 0x4e, 0x44, 0x0b, 0x43, 0x50, 0x1b,
	0xd0, 0xc0, 0xae, 0x6c, 0x17, 0xd0, 0xa1, 0xdd, 0xdd, 0xaa, 0x2a, 0x13, 0xc8, 0xca, 0x8f, 0x30,
	0x0f, 0x91, 0x45, 0x94, 0x37, 0xc8, 0x1b, 0x64, 0xc9, 0x72, 0x96, 0xc1, 0x2c, 0x92, 0xe5, 0x28,
	0x4f, 0x10, 0xd5, 0xa9, 0x6e, 0xbb, 0xed, 0xcc, 0x26, 0xbb, 0xfe, 0xbe, 0xef, 0x9c, 0xaa, 0x73,
	0x2d, 0x1b, 0x6c, 0x36, 0x8a, 0xb7, 0x06, 0x82, 0x29, 0x2e, 0xb7, 0x62, 0x11, 0xa9, 0x88, 0x94,
	0x0c, 0x6a, 0xfe, 0x9d, 0x07, 0x68, 0x4b, 0xc9, 0xd5, 0xb7, 0xa1, 0x12, 0x77, 0xa4, 0x05, 0x2b,
	0xdf, 0x05, 0xec, 0x52, 0x52, 0xab, 0x61, 0xb5, 0xd6, 0xb6, 0x49, 0xea, 0x84, 0x26, 0xa8, 0x78,
	0xc6, 0x80, 0x3c, 0x85, 0x0a, 0xba, 0x9c, 0x78, 0x2e, 0xcd, 0x37, 0xac, 0x56, 0xd5, 0x9b, 0x61,
	0xb2, 0x01, 0x2b, 0x5d, 0xd6, 0xe7, 0x01, 0x2d, 0xa0, 0x60, 0x00, 0xa1, 0x50, 0xc6, 0x63, 0xdc,
	0x0e, 0x2d, 0x22, 0x9f, 0x42, 0xad, 0xec, 0xf2, 0x50, 0x71, 0xf1, 0x9a, 0xae, 0x34, 0xac, 0x56,
	0xde, 0x4b, 0xe1, 0x5c, 0x39, 0xa3, 0xa5, 0xac, 0x72, 0x36, 0x57, 0xce, 0x69, 0x39, 0xab, 0x9c,
	0x63, 0x64, 0xb7, 0x8a, 0x87, 0x4a, 0xbe, 0xa6, 0x80, 0xd2, 0x0c, 0x67, 0xb4, 0x33, 0x5a, 0x5b,
	0xd0, 0xce, 0x32, 0xda, 0x39, 0x5d, 0x5d, 0xd0, 0xf0, 0xcc, 0x6e, 0x34, 0x60, 0x81, 0xce, 0xd6,
	0x31, 0xd9, 0xa6, 0x98, 0x10, 0x28, 0x1e, 0xeb, 0x92, 0x7d, 0x84, 0x3c, 0x7e, 0x93, 0x0f, 0xa0,
	0xda, 0xbb, 0x8a, 0x84, 0xea, 0x70, 0x39, 0xa0, 0x0d, 0x14, 0xe6, 0x44, 0xf3, 0x67, 0x0b, 0xd6,
	0x76, 0xc6, 0xe1, 0x30, 0xe0, 0x07, 0x2c, 0xf4, 0x2f, 0xb8, 0x54, 0xa4, 0x01, 0x35, 0xc3, 0x1c,
	0xfb, 0x2a, 0xe0, 0x49, 0x45, 0xb3, 0x14, 0x69, 0xc2, 0xaa, 0x81, 0x87, 0x6c, 0xc4, 0xdd, 0x4e,
	0x52, 0xdb, 0x05, 0x8e, 0x6c, 0x42, 0x09, 0x6b, 0x2a, 0x29, 0x34, 0x0a, 0xad, 0xda, 0x52, 0xff,
	0xb0, 0x3f, 0x5e, 0x62, 0xa1, 0x6f, 0xec, 0x46, 0x6c, 0xd8, 0x0e, 0x82, 0x3d, 0x3f, 0x54, 0x74,
	0xa3, 0x61, 0xb5, 0x2a, 0x5e, 0x96, 0x6a, 0xfe, 0x59, 0x80, 0xea, 0xae, 0xf6, 0x77, 0xc3, 0x8b,
	0x48, 0xdb, 0x23, 0xe8, 0x0d, 0xae, 0xf8, 0x88, 0xe1, 0x80, 0xac, 0x78, 0x59, 0x8a, 0x3c, 0x81,
	0x92, 0x1b, 0x4a, 0xdd, 0x5f, 0x1d, 0x7e, 0xdd, 0x4b, 0x90, 0x2e, 0x1e, 0x9a, 0xe9, 0xe2, 0x99,
	0xce, 0xcf, 0x30, 0x79, 0x06, 0xf5, 0xa3, 0x71, 0x3f, 0xf0, 0xe5, 0x15, 0x17, 0x3a, 0x09, 0x6c,
	0x73, 0xd5, 0x5b, 0x24, 0x75, 0x39, 0xd1, 0x03, 0x2d, 0xc0, 0x94, 0x73, 0x46, 0x2c, 0x16, 0xbb,
	0xb6, 0x54, 0xec, 0x59, 0x7b, 0xd6, 0x33, 0xed, 0x69, 0x40, 0xed, 0xd8, 0x1f, 0xf1, 0x5d, 0xc1,
	0x99, 0xe2, 0x43, 0xec, 0x68, 0xc1, 0xcb, 0x52, 0xfa, 0x4c, 0x0d, 0x77, 0xc6, 0x7e, 0xa0, 0xb0,
	0xb3, 0x05, 0x6f, 0x4e, 0xe8, 0x5e, 0x1c, 0xb0, 0x1f, 0x22, 0x71, 0xca, 0x85, 0xf4, 0xa3, 0x90,
	0xb6, 0xb0, 0x18, 0x0b, 0x1c, 0xda, 0xf8, 0xe1, 0xdc, 0xe6, 0x45, 0x62, 0x93, 0xe1, 0x4c, 0xd7,
	0xfd, 0x60, 0x78, 0x38, 0x1e, 0xf5, 0xb9, 0xa0, 0x9b, 0xa6, 0xa6, 0x19, 0x4a, 0x8f, 0x39, 0x42,
	0xb7, 0x43, 0x3f, 0x35, 0x4b, 0x93, 0x40, 0xad, 0xec, 0x45, 0x23, 0x7e, 0xe2, 0x75, 0xe9, 0xb6,
	0x51, 0x12, 0x48, 0x6c, 0x28, 0x68, 0xf6, 0x73, 0x64, 0xf5, 0x27, 0x71, 0x00, 0xda, 0x71, 0x2c,
	0xa2, 0xdb, 0x9e, 0xff, 0x13, 0xa7, 0xdf, 0x60, 0x3a, 0x19, 0xa6, 0xf9, 0xc6, 0x82, 0x3a, 0xd6,
	0x73, 0x36, 0x8f, 0xcf, 0xa1, 0xa8, 0xbb, 0x8e, 0x6d, 0xae, 0x6d, 0xff, 0x2f, 0x9d, 0xa3, 0xd9,
	0x38, 0x78, 0x28, 0x93, 0x8f, 0x61, 0xcd, 0x1d, 0x44, 0xe1, 0x7c, 0x08, 0x71, 0x81, 0xab, 0xde,
	0x12, 0x4b, 0x5e, 0xea, 0x34, 0x34, 0x4a, 0x27, 0xf3, 0x49, 0x7a, 0xe2, 0xe2, 0x1e, 0x78, 0xa9,
	0x59, 0x53, 0x24, 0x11, 0xf5, 0x42, 0x16, 0xcb, 0xab, 0x48, 0xe9, 0x47, 0xc5, 0xe3, 0x37, 0x6e,
	0x07, 0x43, 0x2a, 0x78, 0x06, 0xe8, 0x0a, 0x76, 0xa2, 0x1f, 0xc3, 0x20, 0x62, 0x43, 0x9d, 0xb3,
	0x59, 0x8a, 0x2c, 0x45, 0x5e, 0x40, 0x09, 0x0f, 0x4a, 0x6f, 0x7e, 0x4f, 0x2e, 0x89, 0x41, 0x73,
	0x52, 0x84, 0x72, 0x3b, 0x8e, 0x4f, 0x99, 0xc0, 0x0d, 0x6e, 0xc7, 0x71, 0x27, 0x1a, 0x31, 0x3f,
	0x4c, 0xd6, 0x71, 0x4e, 0xe0, 0x5b, 0x16, 0xc7, 0x38, 0x70, 0xe9, 0x5b, 0x66, 0xa0, 0x2e, 0xf5,
	0xf7, 0xe2, 0x32, 0xed, 0x8c, 0x99, 0xe6, 0x0c, 0x93, 0xb4, 0x22, 0xd5, 0x57, 0x8d, 0x3e, 0x67,
	0xc8, 0x26, 0xd8, 0x0b, 0x79, 0x6b, 0xab, 0x35, 0xb4, 0xfa, 0x17, 0x4f, 0x0e, 0x61, 0x1d, 0x43,
	0x9a, 0x25, 0x2b, 0xa9, 0x8d, 0x39, 0x3e, 0x9b, 0xed, 0xbd, 0xc9, 0x66, 0x6b, 0xc9, 0xcc, 0xbc,
	0x04, 0xcb, 0xce, 0x3a, 0xb6, 0x13, 0xaf, 0x8b, 0xdb, 0xcc, 0x25, 0x25, 0x8d, 0x82, 0x8e, 0x6d,
	0xce, 0x90, 0x2f, 0xa1, 0xd2, 0xe3, 0x4a, 0xf9, 0xe1, 0xa5, 0xa4, 0x1b, 0x78, 0xd1, 0x87, 0xcb,
	0x17, 0xa5, 0xba, 0xb9, 0x61, 0x66, 0x4e, 0x9e, 0xc3, 0x4a, 0xd7, 0x0f, 0xaf, 0x25, 0x6d, 0xa1,
	0xdf, 0x7a, 0xea, 0xb7, 0x7f, 0x6a, 0x2c, 0x8d, 0xfa, 0x74, 0x07, 0x36, 0xde, 0x17, 0xaa, 0x1e,
	0xe9, 0x6b, 0x7e, 0x87, 0xad, 0xaf, 0x7a, 0xfa, 0x53, 0x8f, 0xc3, 0x0d, 0x0b, 0xc6, 0xe9, 0x53,
	0x69, 0xc0, 0x57, 0xf9, 0x2f, 0xac, 0xa7, 0x5f, 0x43, 0x7d, 0x21, 0x8a, 0xff, 0xe2, 0xdc, 0x7c,
	0x05, 0xe5, 0x24, 0x24, 0xed, 0xb6, 0x3f, 0x77, 0xdb, 0x37, 0x6e, 0xa7, 0x59, 0x37, 0x04, 0x9b,
	0xbf, 0x59, 0xc9, 0x4f, 0xa8, 0xf9, 0x61, 0xac, 0x41, 0xf9, 0x30, 0xc2, 0x4f, 0x3b, 0x47, 0xea,
	0x50, 0x75, 0xe5, 0x31, 0xbf, 0x55, 0x63, 0xc1, 0x6d, 0x8b, 0xac, 0x42, 0xc5, 0x95, 0xbd, 0x58,
	0xf8, 0x8a, 0xdb, 0x79, 0xb2, 0x06, 0xe0, 0xca, 0x03, 0xa6, 0xb8, 0xf0, 0x59, 0x60, 0x17, 0xc9,
	0x3a, 0xd4, 0x5c, 0x79, 0x14, 0xb0, 0x01, 0x67, 0xfd, 0x80, 0xdb, 0x15, 0xf2, 0x7f, 0x58, 0x77,
	0xa5, 0xc7, 0x07, 0xea, 0x58, 0xb0, 0x50, 0x5e, 0x44, 0x62, 0x64, 0xdb, 0x64, 0x15, 0xca, 0x7b,
	0x4c, 0xea, 0xfd, 0xb2, 0x27, 0xfa, 0x8c, 0xaa, 0x2b, 0x8f, 0x84, 0x7f, 0xc3, 0x14, 0xb7, 0x27,
	0x45, 0x52, 0xc7, 0x1b, 0xae, 0xef, 0xfa, 0xd1, 0xad, 0x3d, 0xa9, 0x68, 0xb9, 0x3d, 0x56, 0x51,
	0x6f, 0xc0, 0x02, 0x6e, 0x4f, 0x6c, 0x63, 0xde, 0x1b, 0x8b, 0x0b, 0x36, 0xe0, 0xf6, 0xa4, 0xb1,
	0xf9, 0xc9, 0xc2, 0xa3, 0xae, 0x2f, 0x3c, 0x09, 0x87, 0xfc, 0xc2, 0x0f, 0xf9, 0xd0, 0x50, 0x76,
	0x8e, 0x54, 0xa0, 0x78, 0xf3, 0xea, 0xe5, 0x4b, 0x7b, 0xb8, 0xe3, 0xde, 0x3f, 0x38, 0xb9, 0xb7,
	0x0f, 0x4e, 0xee, 0xdd, 0x83, 0x63, 0x4d, 0xa6, 0x8e, 0xf5, 0xcb, 0xd4, 0xb1, 0x7e, 0x9f, 0x3a,
	0xd6, 0xfd, 0xd4, 0xb1, 0xfe, 0x98, 0x3a, 0xd6, 0x5f, 0x53, 0x27, 0xf7, 0x6e, 0xea, 0x58, 0x6f,
	0x1e, 0x9d, 0xdc, 0xfd, 0xa3, 0x93, 0x7b, 0xfb, 0xe8, 0xe4, 0x7e, 0xcd, 0x13, 0x26, 0xd4, 0xd6,
	0x88, 0x0f, 0x7d, 0xb6, 0x15, 0x07, 0x4c, 0xe9, 0x3c, 0xfa, 0x25, 0xfc, 0x1b, 0xf2, 0xd9, 0x3f,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x41, 0xa8, 0xee, 0x41, 0x9a, 0x08, 0x00, 0x00,
}

func (x AssetFlags) String() string {
	s, ok := AssetFlags_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CrateSchema) String() string {
	s, ok := CrateSchema_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *AssetEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AssetEntry)
	if !ok {
		that2, ok := that.(AssetEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	if this.EntryURI != that1.EntryURI {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.AssetID != that1.AssetID {
		return false
	}
	if this.CenterX != that1.CenterX {
		return false
	}
	if this.CenterY != that1.CenterY {
		return false
	}
	if this.CenterZ != that1.CenterZ {
		return false
	}
	if this.ExtentsX != that1.ExtentsX {
		return false
	}
	if this.ExtentsY != that1.ExtentsY {
		return false
	}
	if this.ExtentsZ != that1.ExtentsZ {
		return false
	}
	if this.LocalURI != that1.LocalURI {
		return false
	}
	if this.Tags != that1.Tags {
		return false
	}
	if this.ShortDesc != that1.ShortDesc {
		return false
	}
	return true
}
func (this *BundleManifest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BundleManifest)
	if !ok {
		that2, ok := that.(BundleManifest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BundleTitle != that1.BundleTitle {
		return false
	}
	if this.BundleNameID != that1.BundleNameID {
		return false
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(that1.Assets[i]) {
			return false
		}
	}
	if this.LoadAllHint != that1.LoadAllHint {
		return false
	}
	return true
}
func (this *CrateInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CrateInfo)
	if !ok {
		that2, ok := that.(CrateInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CrateSchema != that1.CrateSchema {
		return false
	}
	if this.InstID != that1.InstID {
		return false
	}
	if this.CrateURI != that1.CrateURI {
		return false
	}
	if this.PublisherName != that1.PublisherName {
		return false
	}
	if this.CrateName != that1.CrateName {
		return false
	}
	if this.ShortDesc != that1.ShortDesc {
		return false
	}
	if this.Tags != that1.Tags {
		return false
	}
	if this.TimeCreated != that1.TimeCreated {
		return false
	}
	if this.TimeBuilt != that1.TimeBuilt {
		return false
	}
	if this.MajorVersion != that1.MajorVersion {
		return false
	}
	if this.MinorVersion != that1.MinorVersion {
		return false
	}
	if this.BuildNumber != that1.BuildNumber {
		return false
	}
	if this.BuildID != that1.BuildID {
		return false
	}
	if this.HomeURL != that1.HomeURL {
		return false
	}
	if this.URL != that1.URL {
		return false
	}
	if this.ApproxSize != that1.ApproxSize {
		return false
	}
	return true
}
func (this *CrateManifest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CrateManifest)
	if !ok {
		that2, ok := that.(CrateManifest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if this.IconBundleName != that1.IconBundleName {
		return false
	}
	if len(this.Bundles) != len(that1.Bundles) {
		return false
	}
	for i := range this.Bundles {
		if !this.Bundles[i].Equal(that1.Bundles[i]) {
			return false
		}
	}
	return true
}
func (this *CrateSnapshot) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CrateSnapshot)
	if !ok {
		that2, ok := that.(CrateSnapshot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RevID != that1.RevID {
		return false
	}
	if this.DownloadURL != that1.DownloadURL {
		return false
	}
	if len(this.Crates) != len(that1.Crates) {
		return false
	}
	for i := range this.Crates {
		if !this.Crates[i].Equal(that1.Crates[i]) {
			return false
		}
	}
	return true
}
func (this *AppVars) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppVars)
	if !ok {
		that2, ok := that.(AppVars)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppDomain != that1.AppDomain {
		return false
	}
	if this.AppDesc != that1.AppDesc {
		return false
	}
	if this.OrgHomeURL != that1.OrgHomeURL {
		return false
	}
	if this.AppHomeURL != that1.AppHomeURL {
		return false
	}
	if this.CrateSnapshotURL != that1.CrateSnapshotURL {
		return false
	}
	if len(this.AppDownloadURLs) != len(that1.AppDownloadURLs) {
		return false
	}
	for i := range this.AppDownloadURLs {
		if this.AppDownloadURLs[i] != that1.AppDownloadURLs[i] {
			return false
		}
	}
	if len(this.URLSchemes) != len(that1.URLSchemes) {
		return false
	}
	for i := range this.URLSchemes {
		if this.URLSchemes[i] != that1.URLSchemes[i] {
			return false
		}
	}
	if len(this.Settings) != len(that1.Settings) {
		return false
	}
	for i := range this.Settings {
		if this.Settings[i] != that1.Settings[i] {
			return false
		}
	}
	if len(this.Links) != len(that1.Links) {
		return false
	}
	for i := range this.Links {
		if !this.Links[i].Equal(that1.Links[i]) {
			return false
		}
	}
	return true
}
func (this *KVEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KVEntry)
	if !ok {
		that2, ok := that.(KVEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *AssetEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&crates.AssetEntry{")
	s = append(s, "Flags: "+fmt.Sprintf("%#v", this.Flags)+",\n")
	s = append(s, "EntryURI: "+fmt.Sprintf("%#v", this.EntryURI)+",\n")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "AssetID: "+fmt.Sprintf("%#v", this.AssetID)+",\n")
	s = append(s, "CenterX: "+fmt.Sprintf("%#v", this.CenterX)+",\n")
	s = append(s, "CenterY: "+fmt.Sprintf("%#v", this.CenterY)+",\n")
	s = append(s, "CenterZ: "+fmt.Sprintf("%#v", this.CenterZ)+",\n")
	s = append(s, "ExtentsX: "+fmt.Sprintf("%#v", this.ExtentsX)+",\n")
	s = append(s, "ExtentsY: "+fmt.Sprintf("%#v", this.ExtentsY)+",\n")
	s = append(s, "ExtentsZ: "+fmt.Sprintf("%#v", this.ExtentsZ)+",\n")
	s = append(s, "LocalURI: "+fmt.Sprintf("%#v", this.LocalURI)+",\n")
	s = append(s, "Tags: "+fmt.Sprintf("%#v", this.Tags)+",\n")
	s = append(s, "ShortDesc: "+fmt.Sprintf("%#v", this.ShortDesc)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BundleManifest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&crates.BundleManifest{")
	s = append(s, "BundleTitle: "+fmt.Sprintf("%#v", this.BundleTitle)+",\n")
	s = append(s, "BundleNameID: "+fmt.Sprintf("%#v", this.BundleNameID)+",\n")
	if this.Assets != nil {
		s = append(s, "Assets: "+fmt.Sprintf("%#v", this.Assets)+",\n")
	}
	s = append(s, "LoadAllHint: "+fmt.Sprintf("%#v", this.LoadAllHint)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CrateInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&crates.CrateInfo{")
	s = append(s, "CrateSchema: "+fmt.Sprintf("%#v", this.CrateSchema)+",\n")
	s = append(s, "InstID: "+fmt.Sprintf("%#v", this.InstID)+",\n")
	s = append(s, "CrateURI: "+fmt.Sprintf("%#v", this.CrateURI)+",\n")
	s = append(s, "PublisherName: "+fmt.Sprintf("%#v", this.PublisherName)+",\n")
	s = append(s, "CrateName: "+fmt.Sprintf("%#v", this.CrateName)+",\n")
	s = append(s, "ShortDesc: "+fmt.Sprintf("%#v", this.ShortDesc)+",\n")
	s = append(s, "Tags: "+fmt.Sprintf("%#v", this.Tags)+",\n")
	s = append(s, "TimeCreated: "+fmt.Sprintf("%#v", this.TimeCreated)+",\n")
	s = append(s, "TimeBuilt: "+fmt.Sprintf("%#v", this.TimeBuilt)+",\n")
	s = append(s, "MajorVersion: "+fmt.Sprintf("%#v", this.MajorVersion)+",\n")
	s = append(s, "MinorVersion: "+fmt.Sprintf("%#v", this.MinorVersion)+",\n")
	s = append(s, "BuildNumber: "+fmt.Sprintf("%#v", this.BuildNumber)+",\n")
	s = append(s, "BuildID: "+fmt.Sprintf("%#v", this.BuildID)+",\n")
	s = append(s, "HomeURL: "+fmt.Sprintf("%#v", this.HomeURL)+",\n")
	s = append(s, "URL: "+fmt.Sprintf("%#v", this.URL)+",\n")
	s = append(s, "ApproxSize: "+fmt.Sprintf("%#v", this.ApproxSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CrateManifest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&crates.CrateManifest{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	s = append(s, "IconBundleName: "+fmt.Sprintf("%#v", this.IconBundleName)+",\n")
	if this.Bundles != nil {
		s = append(s, "Bundles: "+fmt.Sprintf("%#v", this.Bundles)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CrateSnapshot) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&crates.CrateSnapshot{")
	s = append(s, "RevID: "+fmt.Sprintf("%#v", this.RevID)+",\n")
	s = append(s, "DownloadURL: "+fmt.Sprintf("%#v", this.DownloadURL)+",\n")
	if this.Crates != nil {
		s = append(s, "Crates: "+fmt.Sprintf("%#v", this.Crates)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppVars) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&crates.AppVars{")
	s = append(s, "AppDomain: "+fmt.Sprintf("%#v", this.AppDomain)+",\n")
	s = append(s, "AppDesc: "+fmt.Sprintf("%#v", this.AppDesc)+",\n")
	s = append(s, "OrgHomeURL: "+fmt.Sprintf("%#v", this.OrgHomeURL)+",\n")
	s = append(s, "AppHomeURL: "+fmt.Sprintf("%#v", this.AppHomeURL)+",\n")
	s = append(s, "CrateSnapshotURL: "+fmt.Sprintf("%#v", this.CrateSnapshotURL)+",\n")
	keysForAppDownloadURLs := make([]string, 0, len(this.AppDownloadURLs))
	for k, _ := range this.AppDownloadURLs {
		keysForAppDownloadURLs = append(keysForAppDownloadURLs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAppDownloadURLs)
	mapStringForAppDownloadURLs := "map[string]string{"
	for _, k := range keysForAppDownloadURLs {
		mapStringForAppDownloadURLs += fmt.Sprintf("%#v: %#v,", k, this.AppDownloadURLs[k])
	}
	mapStringForAppDownloadURLs += "}"
	if this.AppDownloadURLs != nil {
		s = append(s, "AppDownloadURLs: "+mapStringForAppDownloadURLs+",\n")
	}
	s = append(s, "URLSchemes: "+fmt.Sprintf("%#v", this.URLSchemes)+",\n")
	keysForSettings := make([]string, 0, len(this.Settings))
	for k, _ := range this.Settings {
		keysForSettings = append(keysForSettings, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSettings)
	mapStringForSettings := "map[string]string{"
	for _, k := range keysForSettings {
		mapStringForSettings += fmt.Sprintf("%#v: %#v,", k, this.Settings[k])
	}
	mapStringForSettings += "}"
	if this.Settings != nil {
		s = append(s, "Settings: "+mapStringForSettings+",\n")
	}
	if this.Links != nil {
		s = append(s, "Links: "+fmt.Sprintf("%#v", this.Links)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KVEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&crates.KVEntry{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAmpCrates(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AssetEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ShortDesc) > 0 {
		i -= len(m.ShortDesc)
		copy(dAtA[i:], m.ShortDesc)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.ShortDesc)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if len(m.LocalURI) > 0 {
		i -= len(m.LocalURI)
		copy(dAtA[i:], m.LocalURI)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.LocalURI)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.ExtentsZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ExtentsZ))))
		i--
		dAtA[i] = 0x65
	}
	if m.ExtentsY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ExtentsY))))
		i--
		dAtA[i] = 0x5d
	}
	if m.ExtentsX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ExtentsX))))
		i--
		dAtA[i] = 0x55
	}
	if m.CenterZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CenterZ))))
		i--
		dAtA[i] = 0x3d
	}
	if m.CenterY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CenterY))))
		i--
		dAtA[i] = 0x35
	}
	if m.CenterX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CenterX))))
		i--
		dAtA[i] = 0x2d
	}
	if len(m.AssetID) > 0 {
		i -= len(m.AssetID)
		copy(dAtA[i:], m.AssetID)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.AssetID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EntryURI) > 0 {
		i -= len(m.EntryURI)
		copy(dAtA[i:], m.EntryURI)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.EntryURI)))
		i--
		dAtA[i] = 0x12
	}
	if m.Flags != 0 {
		i = encodeVarintAmpCrates(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BundleManifest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BundleManifest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BundleManifest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LoadAllHint {
		i--
		if m.LoadAllHint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAmpCrates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.BundleNameID) > 0 {
		i -= len(m.BundleNameID)
		copy(dAtA[i:], m.BundleNameID)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.BundleNameID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BundleTitle) > 0 {
		i -= len(m.BundleTitle)
		copy(dAtA[i:], m.BundleTitle)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.BundleTitle)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *CrateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrateInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApproxSize != 0 {
		i = encodeVarintAmpCrates(dAtA, i, uint64(m.ApproxSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xba
	}
	if len(m.HomeURL) > 0 {
		i -= len(m.HomeURL)
		copy(dAtA[i:], m.HomeURL)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.HomeURL)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.BuildID) > 0 {
		i -= len(m.BuildID)
		copy(dAtA[i:], m.BuildID)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.BuildID)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.BuildNumber != 0 {
		i = encodeVarintAmpCrates(dAtA, i, uint64(m.BuildNumber))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.MinorVersion != 0 {
		i = encodeVarintAmpCrates(dAtA, i, uint64(m.MinorVersion))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.MajorVersion != 0 {
		i = encodeVarintAmpCrates(dAtA, i, uint64(m.MajorVersion))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.TimeBuilt != 0 {
		i = encodeVarintAmpCrates(dAtA, i, uint64(m.TimeBuilt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.TimeCreated != 0 {
		i = encodeVarintAmpCrates(dAtA, i, uint64(m.TimeCreated))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ShortDesc) > 0 {
		i -= len(m.ShortDesc)
		copy(dAtA[i:], m.ShortDesc)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.ShortDesc)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CrateName) > 0 {
		i -= len(m.CrateName)
		copy(dAtA[i:], m.CrateName)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.CrateName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.PublisherName) > 0 {
		i -= len(m.PublisherName)
		copy(dAtA[i:], m.PublisherName)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.PublisherName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CrateURI) > 0 {
		i -= len(m.CrateURI)
		copy(dAtA[i:], m.CrateURI)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.CrateURI)))
		i--
		dAtA[i] = 0x22
	}
	if m.InstID != 0 {
		i = encodeVarintAmpCrates(dAtA, i, uint64(m.InstID))
		i--
		dAtA[i] = 0x10
	}
	if m.CrateSchema != 0 {
		i = encodeVarintAmpCrates(dAtA, i, uint64(m.CrateSchema))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CrateManifest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrateManifest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrateManifest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bundles) > 0 {
		for iNdEx := len(m.Bundles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bundles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAmpCrates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.IconBundleName) > 0 {
		i -= len(m.IconBundleName)
		copy(dAtA[i:], m.IconBundleName)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.IconBundleName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCrates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CrateSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrateSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrateSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Crates) > 0 {
		for iNdEx := len(m.Crates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Crates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAmpCrates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.DownloadURL) > 0 {
		i -= len(m.DownloadURL)
		copy(dAtA[i:], m.DownloadURL)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.DownloadURL)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RevID != 0 {
		i = encodeVarintAmpCrates(dAtA, i, uint64(m.RevID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppVars) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppVars) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppVars) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Links) > 0 {
		for iNdEx := len(m.Links) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Links[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAmpCrates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.Settings) > 0 {
		for k := range m.Settings {
			v := m.Settings[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAmpCrates(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAmpCrates(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAmpCrates(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.URLSchemes) > 0 {
		for iNdEx := len(m.URLSchemes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.URLSchemes[iNdEx])
			copy(dAtA[i:], m.URLSchemes[iNdEx])
			i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.URLSchemes[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.AppDownloadURLs) > 0 {
		for k := range m.AppDownloadURLs {
			v := m.AppDownloadURLs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAmpCrates(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAmpCrates(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAmpCrates(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.CrateSnapshotURL) > 0 {
		i -= len(m.CrateSnapshotURL)
		copy(dAtA[i:], m.CrateSnapshotURL)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.CrateSnapshotURL)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.AppHomeURL) > 0 {
		i -= len(m.AppHomeURL)
		copy(dAtA[i:], m.AppHomeURL)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.AppHomeURL)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.OrgHomeURL) > 0 {
		i -= len(m.OrgHomeURL)
		copy(dAtA[i:], m.OrgHomeURL)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.OrgHomeURL)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AppDesc) > 0 {
		i -= len(m.AppDesc)
		copy(dAtA[i:], m.AppDesc)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.AppDesc)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AppDomain) > 0 {
		i -= len(m.AppDomain)
		copy(dAtA[i:], m.AppDomain)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.AppDomain)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *KVEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintAmpCrates(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAmpCrates(dAtA []byte, offset int, v uint64) int {
	offset -= sovAmpCrates(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AssetEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovAmpCrates(uint64(m.Flags))
	}
	l = len(m.EntryURI)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.AssetID)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	if m.CenterX != 0 {
		n += 5
	}
	if m.CenterY != 0 {
		n += 5
	}
	if m.CenterZ != 0 {
		n += 5
	}
	if m.ExtentsX != 0 {
		n += 5
	}
	if m.ExtentsY != 0 {
		n += 5
	}
	if m.ExtentsZ != 0 {
		n += 5
	}
	l = len(m.LocalURI)
	if l > 0 {
		n += 2 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 2 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.ShortDesc)
	if l > 0 {
		n += 2 + l + sovAmpCrates(uint64(l))
	}
	return n
}

func (m *BundleManifest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BundleTitle)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.BundleNameID)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovAmpCrates(uint64(l))
		}
	}
	if m.LoadAllHint {
		n += 3
	}
	return n
}

func (m *CrateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CrateSchema != 0 {
		n += 1 + sovAmpCrates(uint64(m.CrateSchema))
	}
	if m.InstID != 0 {
		n += 1 + sovAmpCrates(uint64(m.InstID))
	}
	l = len(m.CrateURI)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.PublisherName)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.CrateName)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.ShortDesc)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	if m.TimeCreated != 0 {
		n += 2 + sovAmpCrates(uint64(m.TimeCreated))
	}
	if m.TimeBuilt != 0 {
		n += 2 + sovAmpCrates(uint64(m.TimeBuilt))
	}
	if m.MajorVersion != 0 {
		n += 2 + sovAmpCrates(uint64(m.MajorVersion))
	}
	if m.MinorVersion != 0 {
		n += 2 + sovAmpCrates(uint64(m.MinorVersion))
	}
	if m.BuildNumber != 0 {
		n += 2 + sovAmpCrates(uint64(m.BuildNumber))
	}
	l = len(m.BuildID)
	if l > 0 {
		n += 2 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.HomeURL)
	if l > 0 {
		n += 2 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 2 + l + sovAmpCrates(uint64(l))
	}
	if m.ApproxSize != 0 {
		n += 2 + sovAmpCrates(uint64(m.ApproxSize))
	}
	return n
}

func (m *CrateManifest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.IconBundleName)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	if len(m.Bundles) > 0 {
		for _, e := range m.Bundles {
			l = e.Size()
			n += 1 + l + sovAmpCrates(uint64(l))
		}
	}
	return n
}

func (m *CrateSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RevID != 0 {
		n += 1 + sovAmpCrates(uint64(m.RevID))
	}
	l = len(m.DownloadURL)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	if len(m.Crates) > 0 {
		for _, e := range m.Crates {
			l = e.Size()
			n += 1 + l + sovAmpCrates(uint64(l))
		}
	}
	return n
}

func (m *AppVars) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppDomain)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.AppDesc)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.OrgHomeURL)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.AppHomeURL)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.CrateSnapshotURL)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	if len(m.AppDownloadURLs) > 0 {
		for k, v := range m.AppDownloadURLs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAmpCrates(uint64(len(k))) + 1 + len(v) + sovAmpCrates(uint64(len(v)))
			n += mapEntrySize + 2 + sovAmpCrates(uint64(mapEntrySize))
		}
	}
	if len(m.URLSchemes) > 0 {
		for _, s := range m.URLSchemes {
			l = len(s)
			n += 2 + l + sovAmpCrates(uint64(l))
		}
	}
	if len(m.Settings) > 0 {
		for k, v := range m.Settings {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAmpCrates(uint64(len(k))) + 1 + len(v) + sovAmpCrates(uint64(len(v)))
			n += mapEntrySize + 2 + sovAmpCrates(uint64(mapEntrySize))
		}
	}
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 2 + l + sovAmpCrates(uint64(l))
		}
	}
	return n
}

func (m *KVEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAmpCrates(uint64(l))
	}
	return n
}

func sovAmpCrates(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAmpCrates(x uint64) (n int) {
	return sovAmpCrates(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AssetEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AssetEntry{`,
		`Flags:` + fmt.Sprintf("%v", this.Flags) + `,`,
		`EntryURI:` + fmt.Sprintf("%v", this.EntryURI) + `,`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`AssetID:` + fmt.Sprintf("%v", this.AssetID) + `,`,
		`CenterX:` + fmt.Sprintf("%v", this.CenterX) + `,`,
		`CenterY:` + fmt.Sprintf("%v", this.CenterY) + `,`,
		`CenterZ:` + fmt.Sprintf("%v", this.CenterZ) + `,`,
		`ExtentsX:` + fmt.Sprintf("%v", this.ExtentsX) + `,`,
		`ExtentsY:` + fmt.Sprintf("%v", this.ExtentsY) + `,`,
		`ExtentsZ:` + fmt.Sprintf("%v", this.ExtentsZ) + `,`,
		`LocalURI:` + fmt.Sprintf("%v", this.LocalURI) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`ShortDesc:` + fmt.Sprintf("%v", this.ShortDesc) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BundleManifest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAssets := "[]*AssetEntry{"
	for _, f := range this.Assets {
		repeatedStringForAssets += strings.Replace(f.String(), "AssetEntry", "AssetEntry", 1) + ","
	}
	repeatedStringForAssets += "}"
	s := strings.Join([]string{`&BundleManifest{`,
		`BundleTitle:` + fmt.Sprintf("%v", this.BundleTitle) + `,`,
		`BundleNameID:` + fmt.Sprintf("%v", this.BundleNameID) + `,`,
		`Assets:` + repeatedStringForAssets + `,`,
		`LoadAllHint:` + fmt.Sprintf("%v", this.LoadAllHint) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CrateInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CrateInfo{`,
		`CrateSchema:` + fmt.Sprintf("%v", this.CrateSchema) + `,`,
		`InstID:` + fmt.Sprintf("%v", this.InstID) + `,`,
		`CrateURI:` + fmt.Sprintf("%v", this.CrateURI) + `,`,
		`PublisherName:` + fmt.Sprintf("%v", this.PublisherName) + `,`,
		`CrateName:` + fmt.Sprintf("%v", this.CrateName) + `,`,
		`ShortDesc:` + fmt.Sprintf("%v", this.ShortDesc) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`TimeCreated:` + fmt.Sprintf("%v", this.TimeCreated) + `,`,
		`TimeBuilt:` + fmt.Sprintf("%v", this.TimeBuilt) + `,`,
		`MajorVersion:` + fmt.Sprintf("%v", this.MajorVersion) + `,`,
		`MinorVersion:` + fmt.Sprintf("%v", this.MinorVersion) + `,`,
		`BuildNumber:` + fmt.Sprintf("%v", this.BuildNumber) + `,`,
		`BuildID:` + fmt.Sprintf("%v", this.BuildID) + `,`,
		`HomeURL:` + fmt.Sprintf("%v", this.HomeURL) + `,`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`ApproxSize:` + fmt.Sprintf("%v", this.ApproxSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CrateManifest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBundles := "[]*BundleManifest{"
	for _, f := range this.Bundles {
		repeatedStringForBundles += strings.Replace(f.String(), "BundleManifest", "BundleManifest", 1) + ","
	}
	repeatedStringForBundles += "}"
	s := strings.Join([]string{`&CrateManifest{`,
		`Info:` + strings.Replace(this.Info.String(), "CrateInfo", "CrateInfo", 1) + `,`,
		`IconBundleName:` + fmt.Sprintf("%v", this.IconBundleName) + `,`,
		`Bundles:` + repeatedStringForBundles + `,`,
		`}`,
	}, "")
	return s
}
func (this *CrateSnapshot) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCrates := "[]*CrateInfo{"
	for _, f := range this.Crates {
		repeatedStringForCrates += strings.Replace(f.String(), "CrateInfo", "CrateInfo", 1) + ","
	}
	repeatedStringForCrates += "}"
	s := strings.Join([]string{`&CrateSnapshot{`,
		`RevID:` + fmt.Sprintf("%v", this.RevID) + `,`,
		`DownloadURL:` + fmt.Sprintf("%v", this.DownloadURL) + `,`,
		`Crates:` + repeatedStringForCrates + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppVars) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLinks := "[]*KVEntry{"
	for _, f := range this.Links {
		repeatedStringForLinks += strings.Replace(f.String(), "KVEntry", "KVEntry", 1) + ","
	}
	repeatedStringForLinks += "}"
	keysForAppDownloadURLs := make([]string, 0, len(this.AppDownloadURLs))
	for k, _ := range this.AppDownloadURLs {
		keysForAppDownloadURLs = append(keysForAppDownloadURLs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAppDownloadURLs)
	mapStringForAppDownloadURLs := "map[string]string{"
	for _, k := range keysForAppDownloadURLs {
		mapStringForAppDownloadURLs += fmt.Sprintf("%v: %v,", k, this.AppDownloadURLs[k])
	}
	mapStringForAppDownloadURLs += "}"
	keysForSettings := make([]string, 0, len(this.Settings))
	for k, _ := range this.Settings {
		keysForSettings = append(keysForSettings, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSettings)
	mapStringForSettings := "map[string]string{"
	for _, k := range keysForSettings {
		mapStringForSettings += fmt.Sprintf("%v: %v,", k, this.Settings[k])
	}
	mapStringForSettings += "}"
	s := strings.Join([]string{`&AppVars{`,
		`AppDomain:` + fmt.Sprintf("%v", this.AppDomain) + `,`,
		`AppDesc:` + fmt.Sprintf("%v", this.AppDesc) + `,`,
		`OrgHomeURL:` + fmt.Sprintf("%v", this.OrgHomeURL) + `,`,
		`AppHomeURL:` + fmt.Sprintf("%v", this.AppHomeURL) + `,`,
		`CrateSnapshotURL:` + fmt.Sprintf("%v", this.CrateSnapshotURL) + `,`,
		`AppDownloadURLs:` + mapStringForAppDownloadURLs + `,`,
		`URLSchemes:` + fmt.Sprintf("%v", this.URLSchemes) + `,`,
		`Settings:` + mapStringForSettings + `,`,
		`Links:` + repeatedStringForLinks + `,`,
		`}`,
	}, "")
	return s
}
func (this *KVEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KVEntry{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAmpCrates(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AssetEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= AssetFlags(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CenterX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CenterX = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CenterY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CenterY = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CenterZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CenterZ = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtentsX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ExtentsX = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtentsY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ExtentsY = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtentsZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ExtentsZ = float32(math.Float32frombits(v))
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BundleManifest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BundleManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BundleManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundleTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleNameID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundleNameID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &AssetEntry{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadAllHint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoadAllHint = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrateSchema", wireType)
			}
			m.CrateSchema = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrateSchema |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstID", wireType)
			}
			m.InstID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrateURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrateURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublisherName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublisherName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCreated", wireType)
			}
			m.TimeCreated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCreated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeBuilt", wireType)
			}
			m.TimeBuilt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeBuilt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MajorVersion", wireType)
			}
			m.MajorVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MajorVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinorVersion", wireType)
			}
			m.MinorVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinorVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildNumber", wireType)
			}
			m.BuildNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproxSize", wireType)
			}
			m.ApproxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproxSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrateManifest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrateManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrateManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &CrateInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconBundleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconBundleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bundles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bundles = append(m.Bundles, &BundleManifest{})
			if err := m.Bundles[len(m.Bundles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrateSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrateSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrateSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevID", wireType)
			}
			m.RevID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crates = append(m.Crates, &CrateInfo{})
			if err := m.Crates[len(m.Crates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppVars) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppVars: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppVars: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgHomeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgHomeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppHomeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppHomeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrateSnapshotURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrateSnapshotURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppDownloadURLs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppDownloadURLs == nil {
				m.AppDownloadURLs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAmpCrates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAmpCrates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAmpCrates
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAmpCrates
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAmpCrates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAmpCrates
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAmpCrates
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAmpCrates(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAmpCrates
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AppDownloadURLs[mapkey] = mapvalue
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLSchemes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URLSchemes = append(m.URLSchemes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Settings == nil {
				m.Settings = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAmpCrates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAmpCrates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAmpCrates
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAmpCrates
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAmpCrates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAmpCrates
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAmpCrates
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAmpCrates(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAmpCrates
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Settings[mapkey] = mapvalue
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &KVEntry{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAmpCrates(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAmpCrates
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAmpCrates
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAmpCrates
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAmpCrates
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAmpCrates
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAmpCrates        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAmpCrates          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAmpCrates = fmt.Errorf("proto: unexpected end of group")
)
