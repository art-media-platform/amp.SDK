// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: amp.core.proto

// package amp is an implementation-independent API for a pluggable client-server UI/UX system,
// featuring support and integration for files, media, and communication.
//
// Welcome to art.media.platform (c) 2024 ("amp"): a runtime model and specification to securely share and experience digital media under their own agreed terms and permissions,
//   something we can all agree on.

package amp

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Const int32

const (
	Const_Defs Const = 0
	// The bootstrapping ("head") channel ID
	Const_HeadChannelID Const = 55
	// DefaultServicePort  is the default TCP port used to expose amp.Host service.
	Const_DefaultServicePort Const = 5192
	// Byte size and version of a TxMsg encoding -- values are little endian
	// A TxPreamble has the following layout:
	//   Bytes  00:03 -- TxPreamble marker ('amp')
	//          03:04 -- Const_TxPreamble_Version
	//          04:08 -- sizeof(TxPreamble, TxHeader, serialized []TxOp)
	//          08:12 -- TxMsg.DataStore size
	//          12:16 -- Reserved
	Const_TxPreamble_Size Const = 16
	// Version of the TxPreamble -- first byte
	Const_TxPreamble_Version Const = 51
	// The first byte of the TxPreamble is the header size and version and
	// the following 3 bytes of a serialized TxMsg ("amp")
	Const_TxPreamble_Marker Const = 6385008
	// בְּרֵאשִׁ֖ית בָּרָ֣א אֱלֹהִ֑ים אֵ֥ת הַשָּׁמַ֖יִם וְאֵ֥ת הָאָֽרֶץ
	// Oh Lord, please bless this project, those who fight for it, and those who lay their life on Your altar.
	Const_Invocation Const = 3773
)

var Const_name = map[int32]string{
	0:       "Const_Defs",
	55:      "Const_HeadChannelID",
	5192:    "Const_DefaultServicePort",
	16:      "Const_TxPreamble_Size",
	51:      "Const_TxPreamble_Version",
	6385008: "Const_TxPreamble_Marker",
	3773:    "Const_Invocation",
}

var Const_value = map[string]int32{
	"Const_Defs":               0,
	"Const_HeadChannelID":      55,
	"Const_DefaultServicePort": 5192,
	"Const_TxPreamble_Size":    16,
	"Const_TxPreamble_Version": 51,
	"Const_TxPreamble_Marker":  6385008,
	"Const_Invocation":         3773,
}

func (Const) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{0}
}

// TxOpCode specifies a particular TxOp transaction operation.
type TxOpCode int32

const (
	TxOpCode_MetaOp TxOpCode = 0
	TxOpCode_Upsert TxOpCode = 2
	TxOpCode_Delete TxOpCode = 4
)

var TxOpCode_name = map[int32]string{
	0: "TxOpCode_MetaOp",
	2: "TxOpCode_Upsert",
	4: "TxOpCode_Delete",
}

var TxOpCode_value = map[string]int32{
	"TxOpCode_MetaOp": 0,
	"TxOpCode_Upsert": 2,
	"TxOpCode_Delete": 4,
}

func (TxOpCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{1}
}

// TxField maps a fixed count of int64 payload fields.
//
// Why not a proto message?  Compression is much better since values usually repeat.
type TxField int32

const (
	TxField_Nil       TxField = 0
	TxField_ChanID_0  TxField = 2
	TxField_ChanID_1  TxField = 3
	TxField_AttrID_0  TxField = 4
	TxField_AttrID_1  TxField = 5
	TxField_ItemID_0  TxField = 7
	TxField_ItemID_1  TxField = 8
	TxField_EditID_0  TxField = 10
	TxField_EditID_1  TxField = 11
	TxField_NumFields TxField = 12
	TxField_MaxFields TxField = 24
)

var TxField_name = map[int32]string{
	0:  "TxField_Nil",
	2:  "TxField_ChanID_0",
	3:  "TxField_ChanID_1",
	4:  "TxField_AttrID_0",
	5:  "TxField_AttrID_1",
	7:  "TxField_ItemID_0",
	8:  "TxField_ItemID_1",
	10: "TxField_EditID_0",
	11: "TxField_EditID_1",
	12: "TxField_NumFields",
	24: "TxField_MaxFields",
}

var TxField_value = map[string]int32{
	"TxField_Nil":       0,
	"TxField_ChanID_0":  2,
	"TxField_ChanID_1":  3,
	"TxField_AttrID_0":  4,
	"TxField_AttrID_1":  5,
	"TxField_ItemID_0":  7,
	"TxField_ItemID_1":  8,
	"TxField_EditID_0":  10,
	"TxField_EditID_1":  11,
	"TxField_NumFields": 12,
	"TxField_MaxFields": 24,
}

func (TxField) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{2}
}

// Expresses the status of a amp.Pin.
type PinStatus int32

const (
	PinStatus_Inactive PinStatus = 0
	PinStatus_Started  PinStatus = 2
	PinStatus_TxCommit PinStatus = 6
	PinStatus_Syncing  PinStatus = 8
	PinStatus_Synced   PinStatus = 9
	PinStatus_Complete PinStatus = 16
)

var PinStatus_name = map[int32]string{
	0:  "PinStatus_Inactive",
	2:  "PinStatus_Started",
	6:  "PinStatus_TxCommit",
	8:  "PinStatus_Syncing",
	9:  "PinStatus_Synced",
	16: "PinStatus_Complete",
}

var PinStatus_value = map[string]int32{
	"PinStatus_Inactive": 0,
	"PinStatus_Started":  2,
	"PinStatus_TxCommit": 6,
	"PinStatus_Syncing":  8,
	"PinStatus_Synced":   9,
	"PinStatus_Complete": 16,
}

func (PinStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{3}
}

type CabinetOpCode int32

const (
	CabinetOpCode_Nil    CabinetOpCode = 0
	CabinetOpCode_Get    CabinetOpCode = 1
	CabinetOpCode_Put    CabinetOpCode = 2
	CabinetOpCode_Delete CabinetOpCode = 3
)

var CabinetOpCode_name = map[int32]string{
	0: "CabinetOpCode_Nil",
	1: "CabinetOpCode_Get",
	2: "CabinetOpCode_Put",
	3: "CabinetOpCode_Delete",
}

var CabinetOpCode_value = map[string]int32{
	"CabinetOpCode_Nil":    0,
	"CabinetOpCode_Get":    1,
	"CabinetOpCode_Put":    2,
	"CabinetOpCode_Delete": 3,
}

func (CabinetOpCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{4}
}

// Determines how much a Pin emits to its client Requester.
type PinMode int32

const (
	// If set, no state is emitted to the client.
	// Used when only writing via CommitTx()
	PinMode_Commit PinMode = 0
	// Send requested attrs, then auto-close this request
	// Used when instantaneous state is sufficient (e.g. applying a setting)
	PinMode_Snapshot PinMode = 1
	// If set, the request will remain open after the initial state snapshot is sent.
	// Requester will receive state updates until this request is closed.
	PinMode_MaintainSync PinMode = 2
)

var PinMode_name = map[int32]string{
	0: "PinMode_Commit",
	1: "PinMode_Snapshot",
	2: "PinMode_MaintainSync",
}

var PinMode_value = map[string]int32{
	"PinMode_Commit":       0,
	"PinMode_Snapshot":     1,
	"PinMode_MaintainSync": 2,
}

func (PinMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{5}
}

type Enable int32

const (
	Enable_LatentOff Enable = 0
	Enable_LatentOn  Enable = 1
	Enable_ActiveOn  Enable = 2
	Enable_ActiveOff Enable = 3
)

var Enable_name = map[int32]string{
	0: "Enable_LatentOff",
	1: "Enable_LatentOn",
	2: "Enable_ActiveOn",
	3: "Enable_ActiveOff",
}

var Enable_value = map[string]int32{
	"Enable_LatentOff": 0,
	"Enable_LatentOn":  1,
	"Enable_ActiveOn":  2,
	"Enable_ActiveOff": 3,
}

func (Enable) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{6}
}

type UriScheme int32

const (
	UriScheme_Nil      UriScheme = 0
	UriScheme_Reserved UriScheme = 1
	UriScheme_Path     UriScheme = 2
	UriScheme_Http     UriScheme = 4
	UriScheme_Data     UriScheme = 5
	UriScheme_File     UriScheme = 6
	UriScheme_Amp      UriScheme = 16
)

var UriScheme_name = map[int32]string{
	0:  "UriScheme_Nil",
	1:  "UriScheme_Reserved",
	2:  "UriScheme_Path",
	4:  "UriScheme_Http",
	5:  "UriScheme_Data",
	6:  "UriScheme_File",
	16: "UriScheme_Amp",
}

var UriScheme_value = map[string]int32{
	"UriScheme_Nil":      0,
	"UriScheme_Reserved": 1,
	"UriScheme_Path":     2,
	"UriScheme_Http":     4,
	"UriScheme_Data":     5,
	"UriScheme_File":     6,
	"UriScheme_Amp":      16,
}

func (UriScheme) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{7}
}

// Grid specifies a standard lattice or coordinate convention.
type Grid int32

const (
	Grid_Ortho               Grid = 0
	Grid_Cylinder            Grid = 5
	Grid_Sphere              Grid = 6
	Grid_Tile                Grid = 7
	Grid_EquilateralRhomboid Grid = 16
	Grid_TrapezoDodecahedron Grid = 17
)

var Grid_name = map[int32]string{
	0:  "Grid_Ortho",
	5:  "Grid_Cylinder",
	6:  "Grid_Sphere",
	7:  "Grid_Tile",
	16: "Grid_EquilateralRhomboid",
	17: "Grid_TrapezoDodecahedron",
}

var Grid_value = map[string]int32{
	"Grid_Ortho":               0,
	"Grid_Cylinder":            5,
	"Grid_Sphere":              6,
	"Grid_Tile":                7,
	"Grid_EquilateralRhomboid": 16,
	"Grid_TrapezoDodecahedron": 17,
}

func (Grid) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{8}
}

type TagTypes int32

const (
	TagTypes_Nil  TagTypes = 0
	TagTypes_Chan TagTypes = 1
	TagTypes_Attr TagTypes = 2
	TagTypes_Item TagTypes = 4
	TagTypes_Edit TagTypes = 8
)

var TagTypes_name = map[int32]string{
	0: "TagTypes_Nil",
	1: "TagTypes_Chan",
	2: "TagTypes_Attr",
	4: "TagTypes_Item",
	8: "TagTypes_Edit",
}

var TagTypes_value = map[string]int32{
	"TagTypes_Nil":  0,
	"TagTypes_Chan": 1,
	"TagTypes_Attr": 2,
	"TagTypes_Item": 4,
	"TagTypes_Edit": 8,
}

func (TagTypes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{9}
}

// Units specifies a standard units convention.
type Units int32

const (
	Units_Unspecified Units = 0
	Units_Operations  Units = 1
	Units_Bytes       Units = 2
	Units_Pixels      Units = 3
	Units_Plank       Units = 5
	Units_Nanometers  Units = 7
	Units_Millimeters Units = 10
	Units_Meters      Units = 11
	Units_LightYears  Units = 16
)

var Units_name = map[int32]string{
	0:  "Units_Unspecified",
	1:  "Units_Operations",
	2:  "Units_Bytes",
	3:  "Units_Pixels",
	5:  "Units_Plank",
	7:  "Units_Nanometers",
	10: "Units_Millimeters",
	11: "Units_Meters",
	16: "Units_LightYears",
}

var Units_value = map[string]int32{
	"Units_Unspecified": 0,
	"Units_Operations":  1,
	"Units_Bytes":       2,
	"Units_Pixels":      3,
	"Units_Plank":       5,
	"Units_Nanometers":  7,
	"Units_Millimeters": 10,
	"Units_Meters":      11,
	"Units_LightYears":  16,
}

func (Units) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{10}
}

// CryptoKitID identifies an encryption suite that implements ski.CryptoKit
type CryptoKitID int32

const (
	CryptoKit_Nil             CryptoKitID = 0
	CryptoKit_SecretBox_NaCl  CryptoKitID = 100
	CryptoKit_AsymMsg_NaCl    CryptoKitID = 101
	CryptoKit_Signing_NaCl    CryptoKitID = 102
	CryptoKit_Signing_ED25519 CryptoKitID = 202
)

var CryptoKitID_name = map[int32]string{
	0:   "CryptoKit_Nil",
	100: "CryptoKit_SecretBox_NaCl",
	101: "CryptoKit_AsymMsg_NaCl",
	102: "CryptoKit_Signing_NaCl",
	202: "CryptoKit_Signing_ED25519",
}

var CryptoKitID_value = map[string]int32{
	"CryptoKit_Nil":             0,
	"CryptoKit_SecretBox_NaCl":  100,
	"CryptoKit_AsymMsg_NaCl":    101,
	"CryptoKit_Signing_NaCl":    102,
	"CryptoKit_Signing_ED25519": 202,
}

func (CryptoKitID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{11}
}

// ErrCode expresses status and error codes.
type ErrCode int32

const (
	ErrCode_Nil                        ErrCode = 0
	ErrCode_Unnamed                    ErrCode = -23001
	ErrCode_AssertFailed               ErrCode = -23002
	ErrCode_UnsupportedOp              ErrCode = -23003
	ErrCode_Unimplemented              ErrCode = -23004
	ErrCode_Timeout                    ErrCode = -23005
	ErrCode_ShuttingDown               ErrCode = -23006
	ErrCode_NotConnected               ErrCode = -23007
	ErrCode_AuthFailed                 ErrCode = -23008
	ErrCode_LoginFailed                ErrCode = -23009
	ErrCode_Expired                    ErrCode = -23010
	ErrCode_NotReady                   ErrCode = -23011
	ErrCode_Cancelled                  ErrCode = -23012
	ErrCode_ItemNotFound               ErrCode = -23013
	ErrCode_ContextNotReady            ErrCode = -23020
	ErrCode_RequestClosed              ErrCode = -23021
	ErrCode_BadRequest                 ErrCode = -23022
	ErrCode_BadTag                     ErrCode = -23023
	ErrCode_BadValue                   ErrCode = -23024
	ErrCode_AlreadyExists              ErrCode = -23025
	ErrCode_AttrNotFound               ErrCode = -23026
	ErrCode_NothingToCommit            ErrCode = -23027
	ErrCode_CommitFailed               ErrCode = -23028
	ErrCode_StorageFailure             ErrCode = -23030
	ErrCode_MalformedTx                ErrCode = -23032
	ErrCode_BadSchema                  ErrCode = -23040
	ErrCode_DataFailure                ErrCode = -23041
	ErrCode_ExportErr                  ErrCode = -23042
	ErrCode_PinFailed                  ErrCode = -23043
	ErrCode_ProviderErr                ErrCode = -23045
	ErrCode_ViolatesAppendOnly         ErrCode = -23050
	ErrCode_InsufficientPermissions    ErrCode = -23051
	ErrCode_CryptoKitAlreadyRegistered ErrCode = -23100
	ErrCode_UnrecognizedCryptoKit      ErrCode = -23101
	ErrCode_DecryptFailed              ErrCode = -23102
	ErrCode_VerifySignatureFailed      ErrCode = -23103
	ErrCode_BadKeyFormat               ErrCode = -23104
	ErrCode_KeyGenerationFailed        ErrCode = -23105
	ErrCode_KeyringNotFound            ErrCode = -23106
	ErrCode_KeyEntryNotFound           ErrCode = -23107
	ErrCode_HashKitNotFound            ErrCode = -23108
	ErrCode_UnrecognizedCryptOp        ErrCode = -23110
	ErrCode_MarshalFailed              ErrCode = -23111
	ErrCode_UnmarshalFailed            ErrCode = -23112
)

var ErrCode_name = map[int32]string{
	0:      "ErrCode_Nil",
	-23001: "ErrCode_Unnamed",
	-23002: "ErrCode_AssertFailed",
	-23003: "ErrCode_UnsupportedOp",
	-23004: "ErrCode_Unimplemented",
	-23005: "ErrCode_Timeout",
	-23006: "ErrCode_ShuttingDown",
	-23007: "ErrCode_NotConnected",
	-23008: "ErrCode_AuthFailed",
	-23009: "ErrCode_LoginFailed",
	-23010: "ErrCode_Expired",
	-23011: "ErrCode_NotReady",
	-23012: "ErrCode_Cancelled",
	-23013: "ErrCode_ItemNotFound",
	-23020: "ErrCode_ContextNotReady",
	-23021: "ErrCode_RequestClosed",
	-23022: "ErrCode_BadRequest",
	-23023: "ErrCode_BadTag",
	-23024: "ErrCode_BadValue",
	-23025: "ErrCode_AlreadyExists",
	-23026: "ErrCode_AttrNotFound",
	-23027: "ErrCode_NothingToCommit",
	-23028: "ErrCode_CommitFailed",
	-23030: "ErrCode_StorageFailure",
	-23032: "ErrCode_MalformedTx",
	-23040: "ErrCode_BadSchema",
	-23041: "ErrCode_DataFailure",
	-23042: "ErrCode_ExportErr",
	-23043: "ErrCode_PinFailed",
	-23045: "ErrCode_ProviderErr",
	-23050: "ErrCode_ViolatesAppendOnly",
	-23051: "ErrCode_InsufficientPermissions",
	-23100: "ErrCode_CryptoKitAlreadyRegistered",
	-23101: "ErrCode_UnrecognizedCryptoKit",
	-23102: "ErrCode_DecryptFailed",
	-23103: "ErrCode_VerifySignatureFailed",
	-23104: "ErrCode_BadKeyFormat",
	-23105: "ErrCode_KeyGenerationFailed",
	-23106: "ErrCode_KeyringNotFound",
	-23107: "ErrCode_KeyEntryNotFound",
	-23108: "ErrCode_HashKitNotFound",
	-23110: "ErrCode_UnrecognizedCryptOp",
	-23111: "ErrCode_MarshalFailed",
	-23112: "ErrCode_UnmarshalFailed",
}

var ErrCode_value = map[string]int32{
	"ErrCode_Nil":                        0,
	"ErrCode_Unnamed":                    -23001,
	"ErrCode_AssertFailed":               -23002,
	"ErrCode_UnsupportedOp":              -23003,
	"ErrCode_Unimplemented":              -23004,
	"ErrCode_Timeout":                    -23005,
	"ErrCode_ShuttingDown":               -23006,
	"ErrCode_NotConnected":               -23007,
	"ErrCode_AuthFailed":                 -23008,
	"ErrCode_LoginFailed":                -23009,
	"ErrCode_Expired":                    -23010,
	"ErrCode_NotReady":                   -23011,
	"ErrCode_Cancelled":                  -23012,
	"ErrCode_ItemNotFound":               -23013,
	"ErrCode_ContextNotReady":            -23020,
	"ErrCode_RequestClosed":              -23021,
	"ErrCode_BadRequest":                 -23022,
	"ErrCode_BadTag":                     -23023,
	"ErrCode_BadValue":                   -23024,
	"ErrCode_AlreadyExists":              -23025,
	"ErrCode_AttrNotFound":               -23026,
	"ErrCode_NothingToCommit":            -23027,
	"ErrCode_CommitFailed":               -23028,
	"ErrCode_StorageFailure":             -23030,
	"ErrCode_MalformedTx":                -23032,
	"ErrCode_BadSchema":                  -23040,
	"ErrCode_DataFailure":                -23041,
	"ErrCode_ExportErr":                  -23042,
	"ErrCode_PinFailed":                  -23043,
	"ErrCode_ProviderErr":                -23045,
	"ErrCode_ViolatesAppendOnly":         -23050,
	"ErrCode_InsufficientPermissions":    -23051,
	"ErrCode_CryptoKitAlreadyRegistered": -23100,
	"ErrCode_UnrecognizedCryptoKit":      -23101,
	"ErrCode_DecryptFailed":              -23102,
	"ErrCode_VerifySignatureFailed":      -23103,
	"ErrCode_BadKeyFormat":               -23104,
	"ErrCode_KeyGenerationFailed":        -23105,
	"ErrCode_KeyringNotFound":            -23106,
	"ErrCode_KeyEntryNotFound":           -23107,
	"ErrCode_HashKitNotFound":            -23108,
	"ErrCode_UnrecognizedCryptOp":        -23110,
	"ErrCode_MarshalFailed":              -23111,
	"ErrCode_UnmarshalFailed":            -23112,
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{12}
}

type LogLevel int32

const (
	LogLevel_Error LogLevel = 0
	LogLevel_Warn  LogLevel = 2
	LogLevel_Info  LogLevel = 4
)

var LogLevel_name = map[int32]string{
	0: "LogLevel_Error",
	2: "LogLevel_Warn",
	4: "LogLevel_Info",
}

var LogLevel_value = map[string]int32{
	"LogLevel_Error": 0,
	"LogLevel_Warn":  2,
	"LogLevel_Info":  4,
}

func (LogLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{13}
}

// TxHeader contains information for a TxMsg
type TxHeader struct {
	// Universally unique tag.UID assigned when a tx originates.
	// IN THE CLEAR
	TxID_0 uint64 `protobuf:"fixed64,1,opt,name=TxID_0,json=TxID0,proto3" json:"TxID_0,omitempty"`
	TxID_1 uint64 `protobuf:"fixed64,2,opt,name=TxID_1,json=TxID1,proto3" json:"TxID_1,omitempty"`
	// The planet epoch this tx is associated with.
	// IN THE CLEAR
	Recipient *Tag `protobuf:"bytes,5,opt,name=Recipient,proto3" json:"Recipient,omitempty"`
	// Author alias claiming the right to publish this tx in given planet epoch.
	// IN THE CLEAR
	Author *Tag `protobuf:"bytes,8,opt,name=Author,proto3" json:"Author,omitempty"`
	// When set, this tx is sealed (signed) by Author.
	// IN THE CLEAR
	Signature *Tag `protobuf:"bytes,9,opt,name=Signature,proto3" json:"Signature,omitempty"`
	// If set, updates the active PinRequest state.
	Request *PinRequest `protobuf:"bytes,16,opt,name=Request,proto3" json:"Request,omitempty"`
	// Status of the most recent PinRequest revision.
	Status PinStatus `protobuf:"varint,17,opt,name=Status,proto3,enum=amp.PinStatus" json:"Status,omitempty"`
	// Number of TxOps in this TxHeader
	OpCount uint64 `protobuf:"varint,19,opt,name=OpCount,proto3" json:"OpCount,omitempty"`
	// Refers to a tag ID (usually a TxID) for subsequent requests and responses.
	// Used to reference a tx thread to a request.
	// If nil or equal to TxID, then this tx is context-free and TxID is implied context ID.
	ContextID_0 uint64 `protobuf:"fixed64,24,opt,name=ContextID_0,json=ContextID0,proto3" json:"ContextID_0,omitempty"`
	ContextID_1 uint64 `protobuf:"fixed64,25,opt,name=ContextID_1,json=ContextID1,proto3" json:"ContextID_1,omitempty"`
}

func (m *TxHeader) Reset()      { *m = TxHeader{} }
func (*TxHeader) ProtoMessage() {}
func (*TxHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{0}
}
func (m *TxHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxHeader.Merge(m, src)
}
func (m *TxHeader) XXX_Size() int {
	return m.Size()
}
func (m *TxHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TxHeader.DiscardUnknown(m)
}

var xxx_messageInfo_TxHeader proto.InternalMessageInfo

func (m *TxHeader) GetTxID_0() uint64 {
	if m != nil {
		return m.TxID_0
	}
	return 0
}

func (m *TxHeader) GetTxID_1() uint64 {
	if m != nil {
		return m.TxID_1
	}
	return 0
}

func (m *TxHeader) GetRecipient() *Tag {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *TxHeader) GetAuthor() *Tag {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *TxHeader) GetSignature() *Tag {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *TxHeader) GetRequest() *PinRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *TxHeader) GetStatus() PinStatus {
	if m != nil {
		return m.Status
	}
	return PinStatus_Inactive
}

func (m *TxHeader) GetOpCount() uint64 {
	if m != nil {
		return m.OpCount
	}
	return 0
}

func (m *TxHeader) GetContextID_0() uint64 {
	if m != nil {
		return m.ContextID_0
	}
	return 0
}

func (m *TxHeader) GetContextID_1() uint64 {
	if m != nil {
		return m.ContextID_1
	}
	return 0
}

// Login -- STEP 1: client -> host
type Login struct {
	User   *Tag `protobuf:"bytes,1,opt,name=User,proto3" json:"User,omitempty"`
	Planet *Tag `protobuf:"bytes,2,opt,name=Planet,proto3" json:"Planet,omitempty"`
	Device *Tag `protobuf:"bytes,5,opt,name=Device,proto3" json:"Device,omitempty"`
	// HostAddress is the network address of the server known to the client (e.g. IP address, localhost, domain name, etc)
	// amp.Host uses this as the host name when serving URLs for the client to consume.
	HostAddress string `protobuf:"bytes,8,opt,name=HostAddress,proto3" json:"HostAddress,omitempty"`
	// Tags is an unordered list of string literal tokens with predefined meanings, separated by spaces, periods, or commas.
	Tags string `protobuf:"bytes,9,opt,name=Tags,proto3" json:"Tags,omitempty"`
	// Checkpoint allows the client to resume an auth session.
	Checkpoint *LoginCheckpoint `protobuf:"bytes,12,opt,name=Checkpoint,proto3" json:"Checkpoint,omitempty"`
}

func (m *Login) Reset()      { *m = Login{} }
func (*Login) ProtoMessage() {}
func (*Login) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{1}
}
func (m *Login) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Login) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Login.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Login) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Login.Merge(m, src)
}
func (m *Login) XXX_Size() int {
	return m.Size()
}
func (m *Login) XXX_DiscardUnknown() {
	xxx_messageInfo_Login.DiscardUnknown(m)
}

var xxx_messageInfo_Login proto.InternalMessageInfo

func (m *Login) GetUser() *Tag {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Login) GetPlanet() *Tag {
	if m != nil {
		return m.Planet
	}
	return nil
}

func (m *Login) GetDevice() *Tag {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *Login) GetHostAddress() string {
	if m != nil {
		return m.HostAddress
	}
	return ""
}

func (m *Login) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *Login) GetCheckpoint() *LoginCheckpoint {
	if m != nil {
		return m.Checkpoint
	}
	return nil
}

// LoginChallenge -- STEP 2: host -> client
type LoginChallenge struct {
	Hash []byte `protobuf:"bytes,1,opt,name=Hash,proto3" json:"Hash,omitempty"`
}

func (m *LoginChallenge) Reset()      { *m = LoginChallenge{} }
func (*LoginChallenge) ProtoMessage() {}
func (*LoginChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{2}
}
func (m *LoginChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginChallenge.Merge(m, src)
}
func (m *LoginChallenge) XXX_Size() int {
	return m.Size()
}
func (m *LoginChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_LoginChallenge proto.InternalMessageInfo

func (m *LoginChallenge) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// LoginResponse -- STEP 3: client -> host
type LoginResponse struct {
	HashResponse []byte `protobuf:"bytes,1,opt,name=HashResponse,proto3" json:"HashResponse,omitempty"`
}

func (m *LoginResponse) Reset()      { *m = LoginResponse{} }
func (*LoginResponse) ProtoMessage() {}
func (*LoginResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{3}
}
func (m *LoginResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginResponse.Merge(m, src)
}
func (m *LoginResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoginResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoginResponse proto.InternalMessageInfo

func (m *LoginResponse) GetHashResponse() []byte {
	if m != nil {
		return m.HashResponse
	}
	return nil
}

// LoginCheckpoint wraps oauth2 -- see oauth2.Token
type LoginCheckpoint struct {
	TokenType    string `protobuf:"bytes,1,opt,name=TokenType,proto3" json:"TokenType,omitempty"`
	AccessToken  string `protobuf:"bytes,2,opt,name=AccessToken,proto3" json:"AccessToken,omitempty"`
	RefreshToken string `protobuf:"bytes,3,opt,name=RefreshToken,proto3" json:"RefreshToken,omitempty"`
	Expiry       int64  `protobuf:"varint,4,opt,name=Expiry,proto3" json:"Expiry,omitempty"`
	UserID       string `protobuf:"bytes,11,opt,name=UserID,proto3" json:"UserID,omitempty"`
	URI          string `protobuf:"bytes,12,opt,name=URI,proto3" json:"URI,omitempty"`
}

func (m *LoginCheckpoint) Reset()      { *m = LoginCheckpoint{} }
func (*LoginCheckpoint) ProtoMessage() {}
func (*LoginCheckpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{4}
}
func (m *LoginCheckpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginCheckpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginCheckpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginCheckpoint.Merge(m, src)
}
func (m *LoginCheckpoint) XXX_Size() int {
	return m.Size()
}
func (m *LoginCheckpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginCheckpoint.DiscardUnknown(m)
}

var xxx_messageInfo_LoginCheckpoint proto.InternalMessageInfo

func (m *LoginCheckpoint) GetTokenType() string {
	if m != nil {
		return m.TokenType
	}
	return ""
}

func (m *LoginCheckpoint) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *LoginCheckpoint) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

func (m *LoginCheckpoint) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *LoginCheckpoint) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *LoginCheckpoint) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

// PinRequest is a peer request to "pin" a set of element IDs, where selected attrs and items will be pushed to the peer.
type PinRequest struct {
	// Used for easy sorting and ordering of requests
	//
	//	0: initial request
	//	1: 1st revision
	//	2: 2nd revision ...
	Revision int64 `protobuf:"varint,1,opt,name=Revision,proto3" json:"Revision,omitempty"`
	// Operation mode for this pin request.
	Mode PinMode `protobuf:"varint,2,opt,name=Mode,proto3,enum=amp.PinMode" json:"Mode,omitempty"`
	// Permissions and access controls.
	Access *AccessControl `protobuf:"bytes,3,opt,name=Access,proto3" json:"Access,omitempty"`
	// Explicit URL or ID invocation associated with this request.
	Invoke *Tag `protobuf:"bytes,4,opt,name=Invoke,proto3" json:"Invoke,omitempty"`
	// Selects which values to synchronize and which NOT to synchronize.
	Select *PinSelector `protobuf:"bytes,6,opt,name=Select,proto3" json:"Select,omitempty"`
	// If set, this is a genesis request to create a new channel with the given typeID (
	Epoch *ChannelEpoch `protobuf:"bytes,16,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
}

func (m *PinRequest) Reset()      { *m = PinRequest{} }
func (*PinRequest) ProtoMessage() {}
func (*PinRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{5}
}
func (m *PinRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PinRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PinRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PinRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PinRequest.Merge(m, src)
}
func (m *PinRequest) XXX_Size() int {
	return m.Size()
}
func (m *PinRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PinRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PinRequest proto.InternalMessageInfo

func (m *PinRequest) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *PinRequest) GetMode() PinMode {
	if m != nil {
		return m.Mode
	}
	return PinMode_Commit
}

func (m *PinRequest) GetAccess() *AccessControl {
	if m != nil {
		return m.Access
	}
	return nil
}

func (m *PinRequest) GetInvoke() *Tag {
	if m != nil {
		return m.Invoke
	}
	return nil
}

func (m *PinRequest) GetSelect() *PinSelector {
	if m != nil {
		return m.Select
	}
	return nil
}

func (m *PinRequest) GetEpoch() *ChannelEpoch {
	if m != nil {
		return m.Epoch
	}
	return nil
}

type PinSelector struct {
	Anchor *Tag         `protobuf:"bytes,2,opt,name=Anchor,proto3" json:"Anchor,omitempty"`
	Ranges []*AddrRange `protobuf:"bytes,3,rep,name=Ranges,proto3" json:"Ranges,omitempty"`
}

func (m *PinSelector) Reset()      { *m = PinSelector{} }
func (*PinSelector) ProtoMessage() {}
func (*PinSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{6}
}
func (m *PinSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PinSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PinSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PinSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PinSelector.Merge(m, src)
}
func (m *PinSelector) XXX_Size() int {
	return m.Size()
}
func (m *PinSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_PinSelector.DiscardUnknown(m)
}

var xxx_messageInfo_PinSelector proto.InternalMessageInfo

func (m *PinSelector) GetAnchor() *Tag {
	if m != nil {
		return m.Anchor
	}
	return nil
}

func (m *PinSelector) GetRanges() []*AddrRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

type AddrRange struct {
	Weight    float32 `protobuf:"fixed32,1,opt,name=Weight,proto3" json:"Weight,omitempty"`
	Chan_Lo_0 uint64  `protobuf:"fixed64,4,opt,name=Chan_Lo_0,json=ChanLo0,proto3" json:"Chan_Lo_0,omitempty"`
	Chan_Hi_0 uint64  `protobuf:"fixed64,5,opt,name=Chan_Hi_0,json=ChanHi0,proto3" json:"Chan_Hi_0,omitempty"`
	Chan_Lo_1 uint64  `protobuf:"fixed64,6,opt,name=Chan_Lo_1,json=ChanLo1,proto3" json:"Chan_Lo_1,omitempty"`
	Chan_Hi_1 uint64  `protobuf:"fixed64,7,opt,name=Chan_Hi_1,json=ChanHi1,proto3" json:"Chan_Hi_1,omitempty"`
	Attr_Lo_0 uint64  `protobuf:"fixed64,10,opt,name=Attr_Lo_0,json=AttrLo0,proto3" json:"Attr_Lo_0,omitempty"`
	Attr_Hi_0 uint64  `protobuf:"fixed64,11,opt,name=Attr_Hi_0,json=AttrHi0,proto3" json:"Attr_Hi_0,omitempty"`
	Attr_Lo_1 uint64  `protobuf:"fixed64,12,opt,name=Attr_Lo_1,json=AttrLo1,proto3" json:"Attr_Lo_1,omitempty"`
	Attr_Hi_1 uint64  `protobuf:"fixed64,13,opt,name=Attr_Hi_1,json=AttrHi1,proto3" json:"Attr_Hi_1,omitempty"`
	Item_Lo_0 uint64  `protobuf:"fixed64,14,opt,name=Item_Lo_0,json=ItemLo0,proto3" json:"Item_Lo_0,omitempty"`
	Item_Hi_0 uint64  `protobuf:"fixed64,15,opt,name=Item_Hi_0,json=ItemHi0,proto3" json:"Item_Hi_0,omitempty"`
	Item_Lo_1 uint64  `protobuf:"fixed64,16,opt,name=Item_Lo_1,json=ItemLo1,proto3" json:"Item_Lo_1,omitempty"`
	Item_Hi_1 uint64  `protobuf:"fixed64,17,opt,name=Item_Hi_1,json=ItemHi1,proto3" json:"Item_Hi_1,omitempty"`
	Edit_Lo_0 uint64  `protobuf:"fixed64,20,opt,name=Edit_Lo_0,json=EditLo0,proto3" json:"Edit_Lo_0,omitempty"`
	Edit_Hi_0 uint64  `protobuf:"fixed64,21,opt,name=Edit_Hi_0,json=EditHi0,proto3" json:"Edit_Hi_0,omitempty"`
	Edit_Lo_1 uint64  `protobuf:"fixed64,22,opt,name=Edit_Lo_1,json=EditLo1,proto3" json:"Edit_Lo_1,omitempty"`
	Edit_Hi_1 uint64  `protobuf:"fixed64,23,opt,name=Edit_Hi_1,json=EditHi1,proto3" json:"Edit_Hi_1,omitempty"`
}

func (m *AddrRange) Reset()      { *m = AddrRange{} }
func (*AddrRange) ProtoMessage() {}
func (*AddrRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{7}
}
func (m *AddrRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddrRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddrRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddrRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddrRange.Merge(m, src)
}
func (m *AddrRange) XXX_Size() int {
	return m.Size()
}
func (m *AddrRange) XXX_DiscardUnknown() {
	xxx_messageInfo_AddrRange.DiscardUnknown(m)
}

var xxx_messageInfo_AddrRange proto.InternalMessageInfo

func (m *AddrRange) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *AddrRange) GetChan_Lo_0() uint64 {
	if m != nil {
		return m.Chan_Lo_0
	}
	return 0
}

func (m *AddrRange) GetChan_Hi_0() uint64 {
	if m != nil {
		return m.Chan_Hi_0
	}
	return 0
}

func (m *AddrRange) GetChan_Lo_1() uint64 {
	if m != nil {
		return m.Chan_Lo_1
	}
	return 0
}

func (m *AddrRange) GetChan_Hi_1() uint64 {
	if m != nil {
		return m.Chan_Hi_1
	}
	return 0
}

func (m *AddrRange) GetAttr_Lo_0() uint64 {
	if m != nil {
		return m.Attr_Lo_0
	}
	return 0
}

func (m *AddrRange) GetAttr_Hi_0() uint64 {
	if m != nil {
		return m.Attr_Hi_0
	}
	return 0
}

func (m *AddrRange) GetAttr_Lo_1() uint64 {
	if m != nil {
		return m.Attr_Lo_1
	}
	return 0
}

func (m *AddrRange) GetAttr_Hi_1() uint64 {
	if m != nil {
		return m.Attr_Hi_1
	}
	return 0
}

func (m *AddrRange) GetItem_Lo_0() uint64 {
	if m != nil {
		return m.Item_Lo_0
	}
	return 0
}

func (m *AddrRange) GetItem_Hi_0() uint64 {
	if m != nil {
		return m.Item_Hi_0
	}
	return 0
}

func (m *AddrRange) GetItem_Lo_1() uint64 {
	if m != nil {
		return m.Item_Lo_1
	}
	return 0
}

func (m *AddrRange) GetItem_Hi_1() uint64 {
	if m != nil {
		return m.Item_Hi_1
	}
	return 0
}

func (m *AddrRange) GetEdit_Lo_0() uint64 {
	if m != nil {
		return m.Edit_Lo_0
	}
	return 0
}

func (m *AddrRange) GetEdit_Hi_0() uint64 {
	if m != nil {
		return m.Edit_Hi_0
	}
	return 0
}

func (m *AddrRange) GetEdit_Lo_1() uint64 {
	if m != nil {
		return m.Edit_Lo_1
	}
	return 0
}

func (m *AddrRange) GetEdit_Hi_1() uint64 {
	if m != nil {
		return m.Edit_Hi_1
	}
	return 0
}

type AccessControl struct {
	Credentials *Tags `protobuf:"bytes,2,opt,name=Credentials,proto3" json:"Credentials,omitempty"`
}

func (m *AccessControl) Reset()      { *m = AccessControl{} }
func (*AccessControl) ProtoMessage() {}
func (*AccessControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{8}
}
func (m *AccessControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessControl.Merge(m, src)
}
func (m *AccessControl) XXX_Size() int {
	return m.Size()
}
func (m *AccessControl) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessControl.DiscardUnknown(m)
}

var xxx_messageInfo_AccessControl proto.InternalMessageInfo

func (m *AccessControl) GetCredentials() *Tags {
	if m != nil {
		return m.Credentials
	}
	return nil
}

type ChannelEpoch struct {
	Channel       *Tag   `protobuf:"bytes,1,opt,name=Channel,proto3" json:"Channel,omitempty"`
	ParentChannel *Tag   `protobuf:"bytes,2,opt,name=ParentChannel,proto3" json:"ParentChannel,omitempty"`
	TypeID        uint64 `protobuf:"fixed64,3,opt,name=TypeID,proto3" json:"TypeID,omitempty"`
	Comment       string `protobuf:"bytes,10,opt,name=Comment,proto3" json:"Comment,omitempty"`
}

func (m *ChannelEpoch) Reset()      { *m = ChannelEpoch{} }
func (*ChannelEpoch) ProtoMessage() {}
func (*ChannelEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{9}
}
func (m *ChannelEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelEpoch.Merge(m, src)
}
func (m *ChannelEpoch) XXX_Size() int {
	return m.Size()
}
func (m *ChannelEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelEpoch proto.InternalMessageInfo

func (m *ChannelEpoch) GetChannel() *Tag {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *ChannelEpoch) GetParentChannel() *Tag {
	if m != nil {
		return m.ParentChannel
	}
	return nil
}

func (m *ChannelEpoch) GetTypeID() uint64 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *ChannelEpoch) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// Tag is a versatile and lightweight way to fuse any URL, ID, precise geo-location, crypto address, content-type, or payload text.
//
// All fields are optional and their meaning is contextual.
type Tag struct {
	ID_0        uint64 `protobuf:"fixed64,3,opt,name=ID_0,json=ID0,proto3" json:"ID_0,omitempty"`
	ID_1        uint64 `protobuf:"fixed64,4,opt,name=ID_1,json=ID1,proto3" json:"ID_1,omitempty"`
	R           int64  `protobuf:"varint,16,opt,name=R,proto3" json:"R,omitempty"`
	I           int64  `protobuf:"varint,17,opt,name=I,proto3" json:"I,omitempty"`
	J           int64  `protobuf:"varint,18,opt,name=J,proto3" json:"J,omitempty"`
	Grid        Grid   `protobuf:"varint,20,opt,name=Grid,proto3,enum=amp.Grid" json:"Grid,omitempty"`
	Units       Units  `protobuf:"varint,21,opt,name=Units,proto3,enum=amp.Units" json:"Units,omitempty"`
	ContentType string `protobuf:"bytes,24,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	URI         string `protobuf:"bytes,26,opt,name=URI,proto3" json:"URI,omitempty"`
	Text        string `protobuf:"bytes,28,opt,name=Text,proto3" json:"Text,omitempty"`
}

func (m *Tag) Reset()      { *m = Tag{} }
func (*Tag) ProtoMessage() {}
func (*Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{10}
}
func (m *Tag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tag.Merge(m, src)
}
func (m *Tag) XXX_Size() int {
	return m.Size()
}
func (m *Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Tag proto.InternalMessageInfo

func (m *Tag) GetID_0() uint64 {
	if m != nil {
		return m.ID_0
	}
	return 0
}

func (m *Tag) GetID_1() uint64 {
	if m != nil {
		return m.ID_1
	}
	return 0
}

func (m *Tag) GetR() int64 {
	if m != nil {
		return m.R
	}
	return 0
}

func (m *Tag) GetI() int64 {
	if m != nil {
		return m.I
	}
	return 0
}

func (m *Tag) GetJ() int64 {
	if m != nil {
		return m.J
	}
	return 0
}

func (m *Tag) GetGrid() Grid {
	if m != nil {
		return m.Grid
	}
	return Grid_Ortho
}

func (m *Tag) GetUnits() Units {
	if m != nil {
		return m.Units
	}
	return Units_Unspecified
}

func (m *Tag) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *Tag) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *Tag) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// Tags is a multi-purpose, serializable, and customizable tree of tags.
//
// All fields are optional and their meaning is contextual.
type Tags struct {
	Head     *Tag    `protobuf:"bytes,1,opt,name=Head,proto3" json:"Head,omitempty"`
	SubTags  []*Tag  `protobuf:"bytes,4,rep,name=SubTags,proto3" json:"SubTags,omitempty"`
	Children []*Tags `protobuf:"bytes,6,rep,name=Children,proto3" json:"Children,omitempty"`
}

func (m *Tags) Reset()      { *m = Tags{} }
func (*Tags) ProtoMessage() {}
func (*Tags) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{11}
}
func (m *Tags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tags.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tags.Merge(m, src)
}
func (m *Tags) XXX_Size() int {
	return m.Size()
}
func (m *Tags) XXX_DiscardUnknown() {
	xxx_messageInfo_Tags.DiscardUnknown(m)
}

var xxx_messageInfo_Tags proto.InternalMessageInfo

func (m *Tags) GetHead() *Tag {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *Tags) GetSubTags() []*Tag {
	if m != nil {
		return m.SubTags
	}
	return nil
}

func (m *Tags) GetChildren() []*Tags {
	if m != nil {
		return m.Children
	}
	return nil
}

// Err is a general purpose error / warning / log message.
type Err struct {
	// Identifies the type of error.
	Code ErrCode `protobuf:"varint,1,opt,name=Code,proto3,enum=amp.ErrCode" json:"Code,omitempty"`
	// Severity level
	Level LogLevel `protobuf:"varint,2,opt,name=Level,proto3,enum=amp.LogLevel" json:"Level,omitempty"`
	// human-readable info
	Msg string `protobuf:"bytes,4,opt,name=Msg,proto3" json:"Msg,omitempty"`
}

func (m *Err) Reset()      { *m = Err{} }
func (*Err) ProtoMessage() {}
func (*Err) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab24c3800b7c0c17, []int{12}
}
func (m *Err) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Err) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Err.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Err) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Err.Merge(m, src)
}
func (m *Err) XXX_Size() int {
	return m.Size()
}
func (m *Err) XXX_DiscardUnknown() {
	xxx_messageInfo_Err.DiscardUnknown(m)
}

var xxx_messageInfo_Err proto.InternalMessageInfo

func (m *Err) GetCode() ErrCode {
	if m != nil {
		return m.Code
	}
	return ErrCode_Nil
}

func (m *Err) GetLevel() LogLevel {
	if m != nil {
		return m.Level
	}
	return LogLevel_Error
}

func (m *Err) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterEnum("amp.Const", Const_name, Const_value)
	proto.RegisterEnum("amp.TxOpCode", TxOpCode_name, TxOpCode_value)
	proto.RegisterEnum("amp.TxField", TxField_name, TxField_value)
	proto.RegisterEnum("amp.PinStatus", PinStatus_name, PinStatus_value)
	proto.RegisterEnum("amp.CabinetOpCode", CabinetOpCode_name, CabinetOpCode_value)
	proto.RegisterEnum("amp.PinMode", PinMode_name, PinMode_value)
	proto.RegisterEnum("amp.Enable", Enable_name, Enable_value)
	proto.RegisterEnum("amp.UriScheme", UriScheme_name, UriScheme_value)
	proto.RegisterEnum("amp.Grid", Grid_name, Grid_value)
	proto.RegisterEnum("amp.TagTypes", TagTypes_name, TagTypes_value)
	proto.RegisterEnum("amp.Units", Units_name, Units_value)
	proto.RegisterEnum("amp.CryptoKitID", CryptoKitID_name, CryptoKitID_value)
	proto.RegisterEnum("amp.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterEnum("amp.LogLevel", LogLevel_name, LogLevel_value)
	proto.RegisterType((*TxHeader)(nil), "amp.TxHeader")
	proto.RegisterType((*Login)(nil), "amp.Login")
	proto.RegisterType((*LoginChallenge)(nil), "amp.LoginChallenge")
	proto.RegisterType((*LoginResponse)(nil), "amp.LoginResponse")
	proto.RegisterType((*LoginCheckpoint)(nil), "amp.LoginCheckpoint")
	proto.RegisterType((*PinRequest)(nil), "amp.PinRequest")
	proto.RegisterType((*PinSelector)(nil), "amp.PinSelector")
	proto.RegisterType((*AddrRange)(nil), "amp.AddrRange")
	proto.RegisterType((*AccessControl)(nil), "amp.AccessControl")
	proto.RegisterType((*ChannelEpoch)(nil), "amp.ChannelEpoch")
	proto.RegisterType((*Tag)(nil), "amp.Tag")
	proto.RegisterType((*Tags)(nil), "amp.Tags")
	proto.RegisterType((*Err)(nil), "amp.Err")
}

func init() { proto.RegisterFile("amp.core.proto", fileDescriptor_ab24c3800b7c0c17) }

var fileDescriptor_ab24c3800b7c0c17 = []byte{
	// 2550 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x58, 0xc9, 0x6f, 0x23, 0xc7,
	0xf5, 0x56, 0x8b, 0x14, 0x25, 0x96, 0x96, 0x29, 0xd5, 0x6c, 0xed, 0xf1, 0x0c, 0xad, 0x1f, 0xbd,
	0xc9, 0xfc, 0xc5, 0xb2, 0x28, 0xc7, 0x08, 0x02, 0xe4, 0x22, 0x91, 0x1a, 0x4b, 0x9e, 0xd1, 0x48,
	0x68, 0x51, 0x63, 0x24, 0x07, 0x13, 0x25, 0xf6, 0x23, 0x59, 0x98, 0x66, 0x75, 0xbb, 0xba, 0xa8,
	0x90, 0x3e, 0xf9, 0x62, 0x20, 0x08, 0xb2, 0x38, 0x89, 0x91, 0x20, 0xc8, 0x9e, 0x38, 0x0b, 0xf2,
	0x0f, 0x64, 0x41, 0x1c, 0x67, 0x3b, 0x18, 0x99, 0x1c, 0x7c, 0x09, 0xe0, 0xe4, 0x10, 0xc4, 0x9a,
	0x4b, 0x80, 0x5c, 0x7c, 0x49, 0x10, 0x20, 0x88, 0x1d, 0x54, 0x75, 0xf5, 0xc2, 0x51, 0xc7, 0x07,
	0x4f, 0xd5, 0xf7, 0x7d, 0xaf, 0x5e, 0xbd, 0x57, 0xaf, 0x5e, 0x35, 0x85, 0x96, 0xe8, 0x20, 0x58,
	0xeb, 0xf8, 0x02, 0xd6, 0x02, 0xe1, 0x4b, 0x9f, 0x14, 0xe8, 0x20, 0xa8, 0xfe, 0x69, 0x1a, 0xcd,
	0xb5, 0x46, 0x3b, 0x40, 0x5d, 0x10, 0xe4, 0x22, 0x2a, 0xb5, 0x46, 0xbb, 0xcd, 0xf6, 0xba, 0x6d,
	0xad, 0x58, 0xab, 0x25, 0x67, 0x46, 0xcd, 0xd6, 0x13, 0xb8, 0x6e, 0x4f, 0xa7, 0x70, 0x9d, 0x3c,
	0x86, 0xca, 0x0e, 0x74, 0x58, 0xc0, 0x80, 0x4b, 0x7b, 0x66, 0xc5, 0x5a, 0x9d, 0xdf, 0x98, 0x5b,
	0x53, 0x3e, 0x5a, 0xb4, 0xe7, 0xa4, 0x14, 0x59, 0x41, 0xa5, 0xcd, 0xa1, 0xec, 0xfb, 0xc2, 0x9e,
	0xbb, 0x4f, 0x64, 0x70, 0xb5, 0xd2, 0x21, 0xeb, 0x71, 0x2a, 0x87, 0x02, 0xec, 0xf2, 0xfd, 0x2b,
	0x25, 0x14, 0x79, 0x02, 0xcd, 0x3a, 0xf0, 0xe2, 0x10, 0x42, 0x69, 0x63, 0xad, 0x3a, 0xa7, 0x55,
	0x07, 0x8c, 0x1b, 0xd8, 0x89, 0x79, 0xf2, 0x18, 0x2a, 0x1d, 0x4a, 0x2a, 0x87, 0xa1, 0xbd, 0xbc,
	0x62, 0xad, 0x2e, 0x6d, 0x2c, 0xc5, 0xca, 0x08, 0x75, 0x0c, 0x4b, 0x6c, 0x34, 0xbb, 0x1f, 0x34,
	0xfc, 0x21, 0x97, 0xf6, 0xf9, 0x15, 0x6b, 0xb5, 0xe8, 0xc4, 0x53, 0xf2, 0x10, 0x9a, 0x6f, 0xf8,
	0x5c, 0xc2, 0x48, 0xea, 0x8c, 0xd8, 0x3a, 0x74, 0x94, 0x40, 0xeb, 0x93, 0x82, 0xba, 0xfd, 0xc0,
	0x7d, 0x82, 0x7a, 0xf5, 0x8f, 0x16, 0x9a, 0xb9, 0xe9, 0xf7, 0x18, 0x27, 0x57, 0x51, 0xf1, 0x28,
	0x04, 0xa1, 0xd3, 0x9a, 0x8d, 0x4d, 0xa3, 0x2a, 0x41, 0x07, 0x1e, 0xe5, 0x20, 0x75, 0x7e, 0x27,
	0x12, 0x14, 0xe1, 0x4a, 0xd1, 0x84, 0x13, 0xd6, 0x81, 0x33, 0x79, 0x36, 0x38, 0x59, 0x41, 0xf3,
	0x3b, 0x7e, 0x28, 0x37, 0x5d, 0x57, 0x40, 0x18, 0xea, 0x4c, 0x97, 0x9d, 0x2c, 0x44, 0x08, 0x2a,
	0xb6, 0x68, 0x2f, 0xd4, 0xf9, 0x2d, 0x3b, 0x7a, 0x4c, 0x3e, 0x8c, 0x50, 0xa3, 0x0f, 0x9d, 0x3b,
	0x81, 0xcf, 0xb8, 0xb4, 0x17, 0xf4, 0xda, 0x17, 0xf4, 0xda, 0x7a, 0xdf, 0x29, 0xe7, 0x64, 0x74,
	0xd5, 0x47, 0xd0, 0x92, 0xa1, 0xa9, 0xe7, 0x01, 0xef, 0x81, 0x5a, 0x7b, 0x87, 0x86, 0x7d, 0x1d,
	0xdf, 0x82, 0xa3, 0xc7, 0xd5, 0xa7, 0xd1, 0xa2, 0x56, 0x39, 0x10, 0x06, 0x3e, 0x0f, 0x81, 0x54,
	0xd1, 0x82, 0x22, 0xe2, 0xb9, 0x11, 0x4f, 0x60, 0xd5, 0x9f, 0x58, 0xe8, 0xdc, 0x7d, 0xae, 0xc9,
	0x55, 0x54, 0x6e, 0xf9, 0x77, 0x80, 0xb7, 0xc6, 0x41, 0x64, 0x54, 0x76, 0x52, 0x40, 0x05, 0xbe,
	0xd9, 0xe9, 0x40, 0x18, 0x6a, 0x48, 0x67, 0xb0, 0xec, 0x64, 0x21, 0xe5, 0xd7, 0x81, 0xae, 0x80,
	0xb0, 0x1f, 0x49, 0x0a, 0x5a, 0x32, 0x81, 0x91, 0x4b, 0xa8, 0xb4, 0x3d, 0x0a, 0x98, 0x18, 0xdb,
	0xc5, 0x15, 0x6b, 0xb5, 0xe0, 0x98, 0x99, 0xc2, 0xd5, 0x11, 0xed, 0x36, 0xed, 0x79, 0x6d, 0x65,
	0x66, 0x04, 0xa3, 0xc2, 0x91, 0xb3, 0xab, 0x33, 0x56, 0x76, 0xd4, 0xb0, 0xfa, 0x77, 0x0b, 0xa1,
	0xb4, 0x10, 0xc9, 0x15, 0x34, 0xe7, 0xc0, 0x09, 0x0b, 0x99, 0xcf, 0xf5, 0x9e, 0x0b, 0x4e, 0x32,
	0x27, 0x2b, 0xa8, 0xb8, 0xe7, 0xbb, 0xa0, 0xf7, 0xba, 0xb4, 0xb1, 0x10, 0x57, 0xa6, 0xc2, 0x1c,
	0xcd, 0x90, 0x1a, 0x2a, 0x45, 0x11, 0xe8, 0xcd, 0xce, 0x6f, 0x10, 0xad, 0x89, 0x20, 0x55, 0x60,
	0xc2, 0xf7, 0x1c, 0xa3, 0x50, 0xb5, 0xb1, 0xcb, 0x4f, 0xfc, 0x3b, 0xa0, 0xb7, 0x3e, 0x51, 0x1b,
	0x11, 0x4e, 0x56, 0x51, 0xe9, 0x10, 0x3c, 0xe8, 0x48, 0xbb, 0xa4, 0x15, 0x38, 0xb9, 0x0b, 0x1a,
	0xf5, 0x85, 0x63, 0x78, 0xf2, 0x38, 0x9a, 0xd9, 0x0e, 0xfc, 0x4e, 0xdf, 0x5c, 0xaf, 0x65, 0x2d,
	0x6c, 0xf4, 0x29, 0xe7, 0xe0, 0x69, 0xc2, 0x89, 0xf8, 0xea, 0xf3, 0x68, 0x3e, 0x63, 0xaf, 0xaf,
	0x38, 0xef, 0xa8, 0x2b, 0x7e, 0xa6, 0x82, 0x23, 0x5c, 0xdd, 0x47, 0x87, 0xf2, 0x1e, 0xa8, 0x88,
	0x0a, 0xab, 0xf3, 0xe6, 0x3e, 0xaa, 0xda, 0xd4, 0xb0, 0x63, 0xd8, 0xea, 0xbd, 0x02, 0x2a, 0x27,
	0xa8, 0x4a, 0xff, 0xf3, 0xc0, 0x7a, 0x7d, 0xa9, 0x73, 0x38, 0xed, 0x98, 0x19, 0xb9, 0x82, 0xca,
	0x6a, 0x57, 0xed, 0x9b, 0x7e, 0x7b, 0x5d, 0x87, 0x5d, 0x72, 0x66, 0x15, 0x70, 0xd3, 0x5f, 0x4f,
	0xb8, 0x1d, 0xd6, 0x5e, 0xd7, 0xd7, 0xc5, 0x70, 0x3b, 0x6c, 0x3d, 0x6b, 0x57, 0xd7, 0xc9, 0x48,
	0xec, 0xea, 0x59, 0xbb, 0xba, 0x3d, 0x9b, 0xb5, 0xd3, 0xdc, 0xa6, 0x94, 0x22, 0xf2, 0x87, 0x22,
	0x4e, 0x01, 0xc6, 0x9f, 0xe6, 0xb4, 0xbf, 0xf9, 0x94, 0x33, 0xfe, 0x62, 0xbb, 0xba, 0x2e, 0x96,
	0xc4, 0xae, 0x9e, 0xb5, 0xab, 0xdb, 0x8b, 0x59, 0x3b, 0xcd, 0xed, 0x4a, 0x18, 0x44, 0xfe, 0x96,
	0x22, 0x4e, 0x01, 0xc6, 0x9f, 0xe6, 0xb4, 0xbf, 0x73, 0x29, 0x67, 0xfc, 0xc5, 0x76, 0x75, 0x7d,
	0x86, 0x89, 0x5d, 0x3d, 0x6b, 0x57, 0xd7, 0x4d, 0x31, 0xb1, 0xd3, 0xdc, 0xb6, 0xcb, 0x64, 0xe4,
	0xef, 0x42, 0xc4, 0x29, 0xc0, 0xf8, 0xd3, 0x9c, 0xf6, 0x77, 0x31, 0xe5, 0x8c, 0xbf, 0xd8, 0xae,
	0x6e, 0x5f, 0xca, 0xda, 0xd5, 0xb3, 0x76, 0x75, 0xfb, 0x72, 0xd6, 0xae, 0x5e, 0xfd, 0x18, 0x5a,
	0x9c, 0x28, 0x66, 0xf2, 0xff, 0x68, 0xbe, 0x21, 0xc0, 0x05, 0x2e, 0x19, 0xf5, 0x42, 0x53, 0x45,
	0xe5, 0xb8, 0x8a, 0x42, 0x27, 0xcb, 0x56, 0x5f, 0xb3, 0xd0, 0x42, 0xb6, 0x28, 0x49, 0x15, 0xcd,
	0x9a, 0xf9, 0x99, 0x0e, 0x1b, 0x13, 0x64, 0x0d, 0x2d, 0x1e, 0x50, 0x01, 0x5c, 0xc6, 0xca, 0xfb,
	0x2b, 0x75, 0x92, 0x56, 0xa5, 0xa7, 0xfa, 0xcb, 0x6e, 0x53, 0x5f, 0xc1, 0x92, 0x63, 0x66, 0xea,
	0xc1, 0x68, 0xf8, 0x83, 0x81, 0x7a, 0xf3, 0x90, 0xbe, 0xfd, 0xf1, 0xb4, 0xfa, 0x17, 0x0b, 0x15,
	0x5a, 0xb4, 0x47, 0x96, 0x51, 0x51, 0xbf, 0x18, 0x91, 0x5d, 0x41, 0x3d, 0x15, 0x11, 0x54, 0x37,
	0xa5, 0x5a, 0x50, 0xaf, 0xe7, 0x02, 0xb2, 0x1c, 0x7d, 0x44, 0x05, 0xc7, 0x72, 0xd4, 0x6c, 0x57,
	0x1f, 0x4a, 0xc1, 0xb1, 0x76, 0xd5, 0xec, 0x39, 0x9b, 0x44, 0xb3, 0xe7, 0xc8, 0x35, 0x54, 0x7c,
	0x56, 0x30, 0x57, 0x9f, 0xcb, 0x92, 0x49, 0x8a, 0x02, 0x1c, 0x0d, 0x93, 0x15, 0x34, 0x73, 0xc4,
	0x99, 0x0c, 0xf5, 0xd9, 0x2c, 0x6d, 0x20, 0xcd, 0x6b, 0xc4, 0x89, 0x08, 0xd5, 0x22, 0xf5, 0xab,
	0xc4, 0xa5, 0x6e, 0xa1, 0x76, 0xd4, 0x22, 0x33, 0x50, 0xdc, 0xce, 0xae, 0x24, 0xed, 0x4c, 0xbf,
	0x16, 0x30, 0x92, 0xf6, 0x55, 0xf3, 0x5a, 0xc0, 0x48, 0x56, 0xfd, 0xe8, 0x05, 0x51, 0xaf, 0x99,
	0xfa, 0x60, 0x38, 0xfb, 0x9a, 0x29, 0x54, 0x1d, 0xc6, 0xe1, 0xf0, 0x58, 0x3f, 0x35, 0x45, 0x7d,
	0xd5, 0x33, 0x87, 0x61, 0x08, 0xf2, 0x28, 0x9a, 0x6b, 0xf4, 0x99, 0xe7, 0x0a, 0xe0, 0x76, 0x49,
	0x8b, 0x32, 0x67, 0x9d, 0x50, 0xd5, 0x17, 0x50, 0x61, 0x5b, 0xa8, 0xee, 0x52, 0x6c, 0xa8, 0x7e,
	0x69, 0x65, 0xfa, 0xe5, 0xb6, 0x10, 0x0d, 0xdd, 0x2f, 0xd5, 0xff, 0xc9, 0xc3, 0x68, 0xe6, 0x26,
	0x9c, 0x98, 0x43, 0x5d, 0xda, 0x58, 0x8c, 0x9f, 0x30, 0x0d, 0x3a, 0x11, 0xa7, 0x82, 0xdc, 0x0b,
	0x7b, 0xfa, 0x0c, 0xca, 0x8e, 0x1a, 0xd6, 0xde, 0xb4, 0xd0, 0x4c, 0xc3, 0xe7, 0xa1, 0x24, 0x4b,
	0x08, 0xe9, 0x41, 0xbb, 0x09, 0xdd, 0x10, 0x4f, 0x91, 0xcb, 0xe8, 0x7c, 0x34, 0x57, 0x21, 0x99,
	0x92, 0xd8, 0x6d, 0xe2, 0x8f, 0x90, 0x6b, 0xc8, 0x4e, 0x84, 0x74, 0xe8, 0xc9, 0x43, 0x10, 0xea,
	0xfd, 0x3d, 0xf0, 0x85, 0xc4, 0x6f, 0xad, 0x92, 0x07, 0xd0, 0xc5, 0x88, 0x6e, 0x8d, 0x0e, 0x04,
	0xd0, 0xc1, 0xb1, 0x07, 0xed, 0x43, 0xf6, 0x12, 0x60, 0x4c, 0xae, 0xc6, 0x96, 0x19, 0xea, 0x36,
	0x08, 0xf5, 0x22, 0xe0, 0xa7, 0x49, 0x05, 0x5d, 0x3e, 0xc3, 0xee, 0x51, 0x71, 0x07, 0x04, 0x7e,
	0xef, 0xcf, 0xaf, 0x14, 0xc8, 0x45, 0x84, 0x23, 0x5e, 0xf5, 0xf4, 0x0e, 0x95, 0xca, 0xea, 0x8d,
	0x6b, 0xb5, 0x5d, 0xf5, 0xf5, 0xa6, 0xbe, 0x58, 0x5c, 0x20, 0xe7, 0xd1, 0xb9, 0x78, 0xdc, 0xde,
	0x03, 0x49, 0xf7, 0x03, 0x3c, 0x35, 0x01, 0x1e, 0x05, 0x21, 0x08, 0x89, 0xa7, 0x27, 0xc0, 0x26,
	0x78, 0x20, 0x01, 0x17, 0x6b, 0xff, 0xb2, 0xd0, 0x6c, 0x6b, 0x74, 0x9d, 0x81, 0xe7, 0x92, 0x73,
	0x68, 0xde, 0x0c, 0xdb, 0xb7, 0x98, 0x87, 0xa7, 0xc8, 0x05, 0x84, 0x63, 0x40, 0x65, 0x43, 0xd5,
	0x37, 0x9e, 0xce, 0x41, 0xeb, 0xb8, 0x90, 0x45, 0x55, 0x3f, 0xd3, 0xda, 0x62, 0x0e, 0x5a, 0xc7,
	0x33, 0x59, 0x54, 0xf5, 0x22, 0xad, 0x9d, 0xcd, 0x41, 0xeb, 0x78, 0x2e, 0x8b, 0xaa, 0x3e, 0xa2,
	0xb5, 0x28, 0x07, 0xad, 0xe3, 0x79, 0x72, 0x11, 0x2d, 0x27, 0x01, 0x0c, 0x07, 0x7a, 0x10, 0xe2,
	0x85, 0x2c, 0xbc, 0x47, 0x47, 0x06, 0xb6, 0x6b, 0x5f, 0xb1, 0x50, 0x39, 0xf9, 0x34, 0x24, 0x97,
	0x10, 0x49, 0x26, 0xed, 0x5d, 0x4e, 0x3b, 0x92, 0x9d, 0x00, 0x9e, 0x52, 0xc6, 0x29, 0x7e, 0x28,
	0xa9, 0x90, 0xe0, 0xe2, 0xe9, 0x49, 0x79, 0x6b, 0xa4, 0xba, 0x01, 0x93, 0xb8, 0x74, 0x9f, 0x7c,
	0xcc, 0x3b, 0x8c, 0xf7, 0xa2, 0x28, 0x26, 0x61, 0x70, 0x71, 0x79, 0x72, 0x91, 0x86, 0x3f, 0x08,
	0xf4, 0xa1, 0xe0, 0x1a, 0x47, 0x8b, 0x0d, 0x7a, 0xcc, 0x38, 0x48, 0x73, 0xc8, 0x17, 0xd1, 0xf2,
	0x04, 0x60, 0xce, 0xe7, 0x0c, 0xfc, 0x2c, 0x48, 0x6c, 0x9d, 0x85, 0x0f, 0x86, 0xea, 0xfc, 0x6d,
	0x74, 0x61, 0x12, 0x36, 0x45, 0x50, 0xa8, 0xed, 0xa1, 0x59, 0xf3, 0x25, 0x42, 0x08, 0x5a, 0x32,
	0xc3, 0xb6, 0x89, 0x69, 0xca, 0x6c, 0x5e, 0x63, 0x87, 0x9c, 0x06, 0x61, 0xdf, 0x57, 0x5e, 0x6c,
	0x74, 0x21, 0x46, 0xf7, 0x28, 0xe3, 0x92, 0x32, 0xae, 0x02, 0xc3, 0xd3, 0xb5, 0x17, 0x50, 0x69,
	0x9b, 0xd3, 0x63, 0x0f, 0x94, 0x65, 0x34, 0x6a, 0xdf, 0xa4, 0xaa, 0xed, 0xec, 0x77, 0xbb, 0x51,
	0x75, 0x4e, 0xa2, 0x1c, 0x5b, 0x19, 0x70, 0x53, 0xa7, 0x7e, 0x9f, 0x47, 0xa5, 0x36, 0x09, 0x76,
	0xbb, 0xb8, 0x50, 0xfb, 0xaa, 0x85, 0xca, 0x47, 0x82, 0x1d, 0x76, 0xfa, 0x30, 0x00, 0xb2, 0x8c,
	0x16, 0x93, 0x89, 0xc9, 0xcb, 0x25, 0x44, 0x52, 0xc8, 0x81, 0x10, 0xc4, 0x09, 0xb8, 0xd8, 0x52,
	0xc1, 0xa5, 0xf8, 0x01, 0x95, 0x7d, 0x3c, 0x3d, 0x89, 0xed, 0x48, 0x19, 0xe0, 0xe2, 0x24, 0xd6,
	0xa4, 0x92, 0xe2, 0x99, 0x49, 0xec, 0x3a, 0xf3, 0x00, 0x97, 0x26, 0x5d, 0x6f, 0x0e, 0x02, 0x8c,
	0x6b, 0xaf, 0x58, 0x51, 0xdf, 0x56, 0xbd, 0x45, 0xfd, 0xdb, 0xde, 0x17, 0xb2, 0xef, 0xe3, 0x29,
	0xa5, 0xd5, 0xf3, 0xc6, 0xd8, 0x63, 0xdc, 0x05, 0x81, 0x67, 0xd4, 0x7d, 0xd3, 0xd0, 0x61, 0xd0,
	0x07, 0xa1, 0xd6, 0x5b, 0x44, 0x65, 0x0d, 0xb4, 0xd4, 0xf2, 0xb3, 0xaa, 0x77, 0xe8, 0xe9, 0xf6,
	0x8b, 0x43, 0xe6, 0x51, 0x09, 0x82, 0x7a, 0x4e, 0xdf, 0x1f, 0x1c, 0xfb, 0xcc, 0x8d, 0x3a, 0x4b,
	0x24, 0x16, 0x34, 0x80, 0x97, 0xfc, 0xa6, 0xef, 0x42, 0x87, 0xf6, 0xc1, 0x15, 0x3e, 0xc7, 0xcb,
	0xb5, 0x3e, 0x9a, 0x6b, 0xd1, 0x9e, 0x6a, 0xf3, 0x21, 0xc1, 0x68, 0x21, 0x1e, 0x9b, 0x04, 0x2d,
	0xa3, 0xc5, 0x04, 0x51, 0x77, 0x18, 0x5b, 0x13, 0x90, 0xba, 0xaa, 0x78, 0x7a, 0x02, 0x52, 0x37,
	0x12, 0x17, 0x27, 0x20, 0x75, 0xf1, 0xf0, 0x5c, 0xed, 0x0d, 0xcb, 0x3c, 0x45, 0xaa, 0xee, 0xf4,
	0xa0, 0x7d, 0xc4, 0xc3, 0x00, 0x3a, 0xac, 0xcb, 0xc0, 0x8d, 0xca, 0x27, 0x82, 0xf7, 0x03, 0x10,
	0xba, 0x87, 0x85, 0xd8, 0x52, 0xc1, 0x47, 0xe8, 0xd6, 0x58, 0x42, 0x88, 0xa7, 0xd5, 0x2e, 0x23,
	0xe0, 0x80, 0x8d, 0xc0, 0x0b, 0x71, 0x21, 0x95, 0xa8, 0xdf, 0x43, 0x77, 0xa2, 0xbe, 0x11, 0x01,
	0xb7, 0x28, 0xf7, 0x07, 0x20, 0x41, 0x84, 0x78, 0x36, 0x75, 0xbb, 0xc7, 0x3c, 0x8f, 0x19, 0x18,
	0xa5, 0xeb, 0xed, 0x45, 0xc8, 0x7c, 0x6a, 0x7e, 0x53, 0x7d, 0x4e, 0x7e, 0x1c, 0xa8, 0x08, 0x31,
	0xae, 0x7d, 0xd9, 0x52, 0x5f, 0x21, 0xe3, 0x40, 0xfa, 0x37, 0x54, 0x23, 0x51, 0x21, 0x26, 0x53,
	0x93, 0x2e, 0xd5, 0xc4, 0x13, 0xe8, 0x10, 0x3a, 0x02, 0xe4, 0x96, 0x3f, 0x6a, 0xdf, 0xa2, 0x0d,
	0x0f, 0xbb, 0xe4, 0x0a, 0xba, 0x94, 0xb2, 0x9b, 0xe1, 0x78, 0xb0, 0x17, 0xf6, 0x22, 0x0e, 0x26,
	0x39, 0xf5, 0x93, 0x96, 0x71, 0xc3, 0x75, 0x49, 0x05, 0x3d, 0x70, 0x96, 0xdb, 0x6e, 0x6e, 0x3c,
	0xf3, 0x4c, 0xfd, 0xa3, 0xf8, 0xf7, 0x56, 0xed, 0xf5, 0x05, 0x34, 0x6b, 0x1e, 0x3c, 0x95, 0x0a,
	0x33, 0x4c, 0xb6, 0x74, 0x2e, 0x06, 0x8e, 0x38, 0xa7, 0x03, 0x70, 0xf1, 0x0f, 0xff, 0xf0, 0xfe,
	0x07, 0xfa, 0x3f, 0x8b, 0xfc, 0x1f, 0xba, 0x10, 0xb3, 0x9b, 0xa1, 0x6a, 0xff, 0xd7, 0x29, 0xf3,
	0xc0, 0xc5, 0x3f, 0x48, 0x25, 0x55, 0x74, 0x31, 0x5d, 0x20, 0x1c, 0x06, 0x81, 0xaf, 0x3a, 0xdb,
	0x7e, 0x80, 0xbf, 0xff, 0x3f, 0x34, 0x4c, 0xb5, 0x27, 0xf5, 0xc9, 0x03, 0x2e, 0x7e, 0x3d, 0xd5,
	0x64, 0x36, 0xd2, 0x62, 0x03, 0xf0, 0x87, 0x12, 0x7f, 0x2f, 0x77, 0x23, 0x87, 0xfd, 0xa1, 0x94,
	0x8c, 0xf7, 0x9a, 0xfe, 0x27, 0x39, 0xfe, 0x6e, 0xae, 0xe4, 0x96, 0x2f, 0x1b, 0x3e, 0xe7, 0xd0,
	0x51, 0x3e, 0xbe, 0x93, 0x4a, 0x1e, 0x42, 0x24, 0x09, 0x67, 0x28, 0xfb, 0x26, 0x98, 0x6f, 0xa7,
	0x82, 0x15, 0x74, 0x3e, 0x16, 0xe8, 0xdf, 0x91, 0x46, 0xf1, 0xad, 0xdc, 0x6d, 0xea, 0x1f, 0x79,
	0xe0, 0xe2, 0x6f, 0xa6, 0xec, 0x35, 0x84, 0x33, 0x7b, 0x70, 0x80, 0xba, 0x63, 0xfc, 0x8d, 0x94,
	0xae, 0xa0, 0xe5, 0x98, 0x6e, 0x50, 0xde, 0x01, 0x4f, 0x2d, 0xfe, 0xf5, 0xdc, 0x10, 0xd4, 0x3d,
	0xb9, 0xe5, 0xcb, 0xeb, 0xfe, 0x90, 0xbb, 0xf8, 0x6b, 0xa9, 0xe4, 0x11, 0x74, 0x39, 0x59, 0x22,
	0xfa, 0x5b, 0x41, 0xe2, 0xe8, 0xb5, 0xdc, 0x84, 0x9b, 0x9f, 0x94, 0x0d, 0xcf, 0x0f, 0xc1, 0xc5,
	0x5f, 0xca, 0x4d, 0xc6, 0x16, 0x75, 0x8d, 0x0c, 0x7f, 0x31, 0x15, 0x3c, 0x88, 0x96, 0x32, 0x82,
	0x16, 0xed, 0xe1, 0x2f, 0xe4, 0x46, 0xba, 0x45, 0xdd, 0xdb, 0xd4, 0x1b, 0x02, 0x7e, 0x35, 0x77,
	0x03, 0x9b, 0x9e, 0x50, 0xdb, 0xdb, 0x1e, 0xb1, 0x50, 0x86, 0xf8, 0xf3, 0xf9, 0xc5, 0x25, 0xa5,
	0x48, 0xa2, 0xfd, 0x5c, 0x6e, 0xb4, 0xb7, 0x7c, 0xd9, 0x67, 0xbc, 0xd7, 0xf2, 0xcd, 0x73, 0xf2,
	0xd9, 0xdc, 0x85, 0x22, 0xd2, 0x1c, 0xdb, 0x67, 0x52, 0xc9, 0xc3, 0xe8, 0x52, 0x52, 0x3f, 0xd2,
	0x17, 0xb4, 0x07, 0x4a, 0x33, 0x14, 0x80, 0x3f, 0x9d, 0x7b, 0xfa, 0x7b, 0xd4, 0xeb, 0xfa, 0x62,
	0x00, 0x6e, 0x6b, 0x84, 0x3f, 0x95, 0x7b, 0x80, 0x5b, 0xd4, 0xd5, 0x0d, 0x9b, 0xe2, 0x97, 0x73,
	0x57, 0x50, 0xed, 0x3e, 0xf6, 0xf1, 0xc1, 0xdd, 0xbc, 0x15, 0xb6, 0x47, 0xea, 0xae, 0x6c, 0x0b,
	0x81, 0xdf, 0xcf, 0xe5, 0x0f, 0x92, 0xfa, 0xfb, 0xcf, 0xdd, 0x3c, 0x0f, 0x07, 0xc2, 0x3f, 0x61,
	0x2e, 0x08, 0xb5, 0xc2, 0xbf, 0x53, 0xc5, 0xe3, 0xe8, 0x4a, 0xac, 0xb8, 0xcd, 0x7c, 0xd5, 0xef,
	0xc3, 0xcd, 0x20, 0x00, 0xee, 0xee, 0x73, 0x6f, 0x8c, 0xff, 0x99, 0x0a, 0x3f, 0x84, 0x1e, 0x4a,
	0xaa, 0x8d, 0x87, 0xc3, 0x6e, 0x97, 0x75, 0x18, 0x70, 0x79, 0x00, 0x62, 0xc0, 0xc2, 0x50, 0xb7,
	0xd7, 0x7f, 0xa4, 0xea, 0xa7, 0x50, 0x35, 0x49, 0x72, 0xdc, 0x6d, 0xcc, 0xd1, 0x3a, 0xd0, 0x63,
	0xa1, 0x04, 0x75, 0x17, 0x7e, 0x97, 0x1a, 0xd4, 0xd0, 0xb5, 0xf4, 0xd2, 0x0b, 0xe8, 0xf8, 0x3d,
	0xce, 0x5e, 0x02, 0x37, 0x31, 0xc6, 0xbf, 0xbd, 0x9b, 0x57, 0x2e, 0x4d, 0xe8, 0x28, 0x85, 0x89,
	0xfc, 0x37, 0xb9, 0xeb, 0xdd, 0x06, 0xc1, 0xba, 0xe3, 0xe4, 0x2f, 0x7b, 0x46, 0xfb, 0xeb, 0xbb,
	0x79, 0x15, 0xb1, 0x45, 0xdd, 0x1b, 0x30, 0xbe, 0xee, 0x8b, 0x01, 0x95, 0xf8, 0x57, 0xa9, 0x64,
	0x15, 0x3d, 0x18, 0x4b, 0x6e, 0xc0, 0xf8, 0x59, 0xe0, 0xe6, 0x4d, 0x31, 0x8b, 0xbd, 0x79, 0x37,
	0xaf, 0x08, 0x6f, 0xc0, 0x58, 0x30, 0xde, 0x4b, 0x4a, 0xf5, 0x97, 0xa9, 0xea, 0x51, 0x64, 0x67,
	0x54, 0xdb, 0x5c, 0x8a, 0x71, 0x22, 0x7b, 0x23, 0x77, 0xb1, 0x1d, 0x1a, 0xf6, 0x6f, 0x30, 0x99,
	0xa8, 0x7e, 0x91, 0xbb, 0xb9, 0x33, 0xb9, 0xdb, 0x0f, 0xf0, 0xcf, 0x73, 0x33, 0xb7, 0x47, 0x45,
	0xd8, 0xa7, 0x9e, 0x09, 0xe0, 0x67, 0xb9, 0x3e, 0x8f, 0xf8, 0x60, 0x42, 0xf5, 0xd3, 0x44, 0x55,
	0x6b, 0xa2, 0xb9, 0xf8, 0x37, 0x8f, 0xfa, 0x48, 0x89, 0xc7, 0xed, 0x6d, 0x21, 0x7c, 0x11, 0xbd,
	0xf5, 0x09, 0xf6, 0x3c, 0x15, 0x3c, 0x7a, 0xd8, 0x13, 0x68, 0x97, 0x77, 0x7d, 0x5c, 0xdc, 0x92,
	0x6f, 0xbf, 0x5b, 0x99, 0x7a, 0xe7, 0xdd, 0xca, 0xd4, 0x7b, 0xef, 0x56, 0xac, 0x97, 0x4f, 0x2b,
	0xd6, 0x8f, 0x4e, 0x2b, 0xd6, 0x5b, 0xa7, 0x15, 0xeb, 0xed, 0xd3, 0x8a, 0xf5, 0xd7, 0xd3, 0x8a,
	0xf5, 0xb7, 0xd3, 0xca, 0xd4, 0x7b, 0xa7, 0x15, 0xeb, 0xd5, 0x7b, 0x95, 0xa9, 0xb7, 0xef, 0x55,
	0xa6, 0xde, 0xb9, 0x57, 0x99, 0xfa, 0xc4, 0x13, 0x3d, 0x26, 0xfb, 0xc3, 0xe3, 0xb5, 0x8e, 0x3f,
	0x78, 0x8a, 0x0a, 0xf9, 0xe4, 0x00, 0x5c, 0x46, 0x9f, 0x0c, 0x3c, 0x2a, 0xd5, 0x2d, 0x7c, 0x4a,
	0xfd, 0x1e, 0x3b, 0x6c, 0xde, 0x50, 0xff, 0xfe, 0x78, 0x9a, 0x50, 0x21, 0xd7, 0xb4, 0x60, 0x2d,
	0x16, 0x1c, 0x97, 0xf4, 0xdf, 0xa4, 0x9f, 0xfe, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfa, 0x62,
	0xff, 0x28, 0xa5, 0x16, 0x00, 0x00,
}

func (x Const) String() string {
	s, ok := Const_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TxOpCode) String() string {
	s, ok := TxOpCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TxField) String() string {
	s, ok := TxField_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PinStatus) String() string {
	s, ok := PinStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CabinetOpCode) String() string {
	s, ok := CabinetOpCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PinMode) String() string {
	s, ok := PinMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Enable) String() string {
	s, ok := Enable_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x UriScheme) String() string {
	s, ok := UriScheme_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Grid) String() string {
	s, ok := Grid_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TagTypes) String() string {
	s, ok := TagTypes_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Units) String() string {
	s, ok := Units_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CryptoKitID) String() string {
	s, ok := CryptoKitID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ErrCode) String() string {
	s, ok := ErrCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LogLevel) String() string {
	s, ok := LogLevel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TxHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TxHeader)
	if !ok {
		that2, ok := that.(TxHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TxID_0 != that1.TxID_0 {
		return false
	}
	if this.TxID_1 != that1.TxID_1 {
		return false
	}
	if !this.Recipient.Equal(that1.Recipient) {
		return false
	}
	if !this.Author.Equal(that1.Author) {
		return false
	}
	if !this.Signature.Equal(that1.Signature) {
		return false
	}
	if !this.Request.Equal(that1.Request) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.OpCount != that1.OpCount {
		return false
	}
	if this.ContextID_0 != that1.ContextID_0 {
		return false
	}
	if this.ContextID_1 != that1.ContextID_1 {
		return false
	}
	return true
}
func (this *Login) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Login)
	if !ok {
		that2, ok := that.(Login)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.User.Equal(that1.User) {
		return false
	}
	if !this.Planet.Equal(that1.Planet) {
		return false
	}
	if !this.Device.Equal(that1.Device) {
		return false
	}
	if this.HostAddress != that1.HostAddress {
		return false
	}
	if this.Tags != that1.Tags {
		return false
	}
	if !this.Checkpoint.Equal(that1.Checkpoint) {
		return false
	}
	return true
}
func (this *LoginChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginChallenge)
	if !ok {
		that2, ok := that.(LoginChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Hash, that1.Hash) {
		return false
	}
	return true
}
func (this *LoginResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginResponse)
	if !ok {
		that2, ok := that.(LoginResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.HashResponse, that1.HashResponse) {
		return false
	}
	return true
}
func (this *LoginCheckpoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginCheckpoint)
	if !ok {
		that2, ok := that.(LoginCheckpoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TokenType != that1.TokenType {
		return false
	}
	if this.AccessToken != that1.AccessToken {
		return false
	}
	if this.RefreshToken != that1.RefreshToken {
		return false
	}
	if this.Expiry != that1.Expiry {
		return false
	}
	if this.UserID != that1.UserID {
		return false
	}
	if this.URI != that1.URI {
		return false
	}
	return true
}
func (this *PinRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PinRequest)
	if !ok {
		that2, ok := that.(PinRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Revision != that1.Revision {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if !this.Access.Equal(that1.Access) {
		return false
	}
	if !this.Invoke.Equal(that1.Invoke) {
		return false
	}
	if !this.Select.Equal(that1.Select) {
		return false
	}
	if !this.Epoch.Equal(that1.Epoch) {
		return false
	}
	return true
}
func (this *PinSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PinSelector)
	if !ok {
		that2, ok := that.(PinSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Anchor.Equal(that1.Anchor) {
		return false
	}
	if len(this.Ranges) != len(that1.Ranges) {
		return false
	}
	for i := range this.Ranges {
		if !this.Ranges[i].Equal(that1.Ranges[i]) {
			return false
		}
	}
	return true
}
func (this *AddrRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddrRange)
	if !ok {
		that2, ok := that.(AddrRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Weight != that1.Weight {
		return false
	}
	if this.Chan_Lo_0 != that1.Chan_Lo_0 {
		return false
	}
	if this.Chan_Hi_0 != that1.Chan_Hi_0 {
		return false
	}
	if this.Chan_Lo_1 != that1.Chan_Lo_1 {
		return false
	}
	if this.Chan_Hi_1 != that1.Chan_Hi_1 {
		return false
	}
	if this.Attr_Lo_0 != that1.Attr_Lo_0 {
		return false
	}
	if this.Attr_Hi_0 != that1.Attr_Hi_0 {
		return false
	}
	if this.Attr_Lo_1 != that1.Attr_Lo_1 {
		return false
	}
	if this.Attr_Hi_1 != that1.Attr_Hi_1 {
		return false
	}
	if this.Item_Lo_0 != that1.Item_Lo_0 {
		return false
	}
	if this.Item_Hi_0 != that1.Item_Hi_0 {
		return false
	}
	if this.Item_Lo_1 != that1.Item_Lo_1 {
		return false
	}
	if this.Item_Hi_1 != that1.Item_Hi_1 {
		return false
	}
	if this.Edit_Lo_0 != that1.Edit_Lo_0 {
		return false
	}
	if this.Edit_Hi_0 != that1.Edit_Hi_0 {
		return false
	}
	if this.Edit_Lo_1 != that1.Edit_Lo_1 {
		return false
	}
	if this.Edit_Hi_1 != that1.Edit_Hi_1 {
		return false
	}
	return true
}
func (this *AccessControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccessControl)
	if !ok {
		that2, ok := that.(AccessControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Credentials.Equal(that1.Credentials) {
		return false
	}
	return true
}
func (this *ChannelEpoch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChannelEpoch)
	if !ok {
		that2, ok := that.(ChannelEpoch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Channel.Equal(that1.Channel) {
		return false
	}
	if !this.ParentChannel.Equal(that1.ParentChannel) {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *Tag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tag)
	if !ok {
		that2, ok := that.(Tag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID_0 != that1.ID_0 {
		return false
	}
	if this.ID_1 != that1.ID_1 {
		return false
	}
	if this.R != that1.R {
		return false
	}
	if this.I != that1.I {
		return false
	}
	if this.J != that1.J {
		return false
	}
	if this.Grid != that1.Grid {
		return false
	}
	if this.Units != that1.Units {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if this.URI != that1.URI {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	return true
}
func (this *Tags) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tags)
	if !ok {
		that2, ok := that.(Tags)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Head.Equal(that1.Head) {
		return false
	}
	if len(this.SubTags) != len(that1.SubTags) {
		return false
	}
	for i := range this.SubTags {
		if !this.SubTags[i].Equal(that1.SubTags[i]) {
			return false
		}
	}
	if len(this.Children) != len(that1.Children) {
		return false
	}
	for i := range this.Children {
		if !this.Children[i].Equal(that1.Children[i]) {
			return false
		}
	}
	return true
}
func (this *Err) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Err)
	if !ok {
		that2, ok := that.(Err)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	return true
}
func (this *TxHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&amp.TxHeader{")
	s = append(s, "TxID_0: "+fmt.Sprintf("%#v", this.TxID_0)+",\n")
	s = append(s, "TxID_1: "+fmt.Sprintf("%#v", this.TxID_1)+",\n")
	if this.Recipient != nil {
		s = append(s, "Recipient: "+fmt.Sprintf("%#v", this.Recipient)+",\n")
	}
	if this.Author != nil {
		s = append(s, "Author: "+fmt.Sprintf("%#v", this.Author)+",\n")
	}
	if this.Signature != nil {
		s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	}
	if this.Request != nil {
		s = append(s, "Request: "+fmt.Sprintf("%#v", this.Request)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "OpCount: "+fmt.Sprintf("%#v", this.OpCount)+",\n")
	s = append(s, "ContextID_0: "+fmt.Sprintf("%#v", this.ContextID_0)+",\n")
	s = append(s, "ContextID_1: "+fmt.Sprintf("%#v", this.ContextID_1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Login) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&amp.Login{")
	if this.User != nil {
		s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	}
	if this.Planet != nil {
		s = append(s, "Planet: "+fmt.Sprintf("%#v", this.Planet)+",\n")
	}
	if this.Device != nil {
		s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	}
	s = append(s, "HostAddress: "+fmt.Sprintf("%#v", this.HostAddress)+",\n")
	s = append(s, "Tags: "+fmt.Sprintf("%#v", this.Tags)+",\n")
	if this.Checkpoint != nil {
		s = append(s, "Checkpoint: "+fmt.Sprintf("%#v", this.Checkpoint)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&amp.LoginChallenge{")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&amp.LoginResponse{")
	s = append(s, "HashResponse: "+fmt.Sprintf("%#v", this.HashResponse)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginCheckpoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&amp.LoginCheckpoint{")
	s = append(s, "TokenType: "+fmt.Sprintf("%#v", this.TokenType)+",\n")
	s = append(s, "AccessToken: "+fmt.Sprintf("%#v", this.AccessToken)+",\n")
	s = append(s, "RefreshToken: "+fmt.Sprintf("%#v", this.RefreshToken)+",\n")
	s = append(s, "Expiry: "+fmt.Sprintf("%#v", this.Expiry)+",\n")
	s = append(s, "UserID: "+fmt.Sprintf("%#v", this.UserID)+",\n")
	s = append(s, "URI: "+fmt.Sprintf("%#v", this.URI)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PinRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&amp.PinRequest{")
	s = append(s, "Revision: "+fmt.Sprintf("%#v", this.Revision)+",\n")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	if this.Access != nil {
		s = append(s, "Access: "+fmt.Sprintf("%#v", this.Access)+",\n")
	}
	if this.Invoke != nil {
		s = append(s, "Invoke: "+fmt.Sprintf("%#v", this.Invoke)+",\n")
	}
	if this.Select != nil {
		s = append(s, "Select: "+fmt.Sprintf("%#v", this.Select)+",\n")
	}
	if this.Epoch != nil {
		s = append(s, "Epoch: "+fmt.Sprintf("%#v", this.Epoch)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PinSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&amp.PinSelector{")
	if this.Anchor != nil {
		s = append(s, "Anchor: "+fmt.Sprintf("%#v", this.Anchor)+",\n")
	}
	if this.Ranges != nil {
		s = append(s, "Ranges: "+fmt.Sprintf("%#v", this.Ranges)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AddrRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&amp.AddrRange{")
	s = append(s, "Weight: "+fmt.Sprintf("%#v", this.Weight)+",\n")
	s = append(s, "Chan_Lo_0: "+fmt.Sprintf("%#v", this.Chan_Lo_0)+",\n")
	s = append(s, "Chan_Hi_0: "+fmt.Sprintf("%#v", this.Chan_Hi_0)+",\n")
	s = append(s, "Chan_Lo_1: "+fmt.Sprintf("%#v", this.Chan_Lo_1)+",\n")
	s = append(s, "Chan_Hi_1: "+fmt.Sprintf("%#v", this.Chan_Hi_1)+",\n")
	s = append(s, "Attr_Lo_0: "+fmt.Sprintf("%#v", this.Attr_Lo_0)+",\n")
	s = append(s, "Attr_Hi_0: "+fmt.Sprintf("%#v", this.Attr_Hi_0)+",\n")
	s = append(s, "Attr_Lo_1: "+fmt.Sprintf("%#v", this.Attr_Lo_1)+",\n")
	s = append(s, "Attr_Hi_1: "+fmt.Sprintf("%#v", this.Attr_Hi_1)+",\n")
	s = append(s, "Item_Lo_0: "+fmt.Sprintf("%#v", this.Item_Lo_0)+",\n")
	s = append(s, "Item_Hi_0: "+fmt.Sprintf("%#v", this.Item_Hi_0)+",\n")
	s = append(s, "Item_Lo_1: "+fmt.Sprintf("%#v", this.Item_Lo_1)+",\n")
	s = append(s, "Item_Hi_1: "+fmt.Sprintf("%#v", this.Item_Hi_1)+",\n")
	s = append(s, "Edit_Lo_0: "+fmt.Sprintf("%#v", this.Edit_Lo_0)+",\n")
	s = append(s, "Edit_Hi_0: "+fmt.Sprintf("%#v", this.Edit_Hi_0)+",\n")
	s = append(s, "Edit_Lo_1: "+fmt.Sprintf("%#v", this.Edit_Lo_1)+",\n")
	s = append(s, "Edit_Hi_1: "+fmt.Sprintf("%#v", this.Edit_Hi_1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccessControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&amp.AccessControl{")
	if this.Credentials != nil {
		s = append(s, "Credentials: "+fmt.Sprintf("%#v", this.Credentials)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChannelEpoch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&amp.ChannelEpoch{")
	if this.Channel != nil {
		s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	}
	if this.ParentChannel != nil {
		s = append(s, "ParentChannel: "+fmt.Sprintf("%#v", this.ParentChannel)+",\n")
	}
	s = append(s, "TypeID: "+fmt.Sprintf("%#v", this.TypeID)+",\n")
	s = append(s, "Comment: "+fmt.Sprintf("%#v", this.Comment)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Tag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&amp.Tag{")
	s = append(s, "ID_0: "+fmt.Sprintf("%#v", this.ID_0)+",\n")
	s = append(s, "ID_1: "+fmt.Sprintf("%#v", this.ID_1)+",\n")
	s = append(s, "R: "+fmt.Sprintf("%#v", this.R)+",\n")
	s = append(s, "I: "+fmt.Sprintf("%#v", this.I)+",\n")
	s = append(s, "J: "+fmt.Sprintf("%#v", this.J)+",\n")
	s = append(s, "Grid: "+fmt.Sprintf("%#v", this.Grid)+",\n")
	s = append(s, "Units: "+fmt.Sprintf("%#v", this.Units)+",\n")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "URI: "+fmt.Sprintf("%#v", this.URI)+",\n")
	s = append(s, "Text: "+fmt.Sprintf("%#v", this.Text)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Tags) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&amp.Tags{")
	if this.Head != nil {
		s = append(s, "Head: "+fmt.Sprintf("%#v", this.Head)+",\n")
	}
	if this.SubTags != nil {
		s = append(s, "SubTags: "+fmt.Sprintf("%#v", this.SubTags)+",\n")
	}
	if this.Children != nil {
		s = append(s, "Children: "+fmt.Sprintf("%#v", this.Children)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Err) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&amp.Err{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAmpCore(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TxHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContextID_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ContextID_1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc9
	}
	if m.ContextID_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ContextID_0))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc1
	}
	if m.OpCount != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.OpCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Status != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Author != nil {
		{
			size, err := m.Author.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Recipient != nil {
		{
			size, err := m.Recipient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TxID_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.TxID_1))
		i--
		dAtA[i] = 0x11
	}
	if m.TxID_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.TxID_0))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Login) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Login) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Login) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Checkpoint != nil {
		{
			size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.HostAddress) > 0 {
		i -= len(m.HostAddress)
		copy(dAtA[i:], m.HostAddress)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.HostAddress)))
		i--
		dAtA[i] = 0x42
	}
	if m.Device != nil {
		{
			size, err := m.Device.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Planet != nil {
		{
			size, err := m.Planet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HashResponse) > 0 {
		i -= len(m.HashResponse)
		copy(dAtA[i:], m.HashResponse)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.HashResponse)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginCheckpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginCheckpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginCheckpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.UserID) > 0 {
		i -= len(m.UserID)
		copy(dAtA[i:], m.UserID)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.UserID)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Expiry != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AccessToken) > 0 {
		i -= len(m.AccessToken)
		copy(dAtA[i:], m.AccessToken)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.AccessToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TokenType) > 0 {
		i -= len(m.TokenType)
		copy(dAtA[i:], m.TokenType)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.TokenType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PinRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PinRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PinRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Epoch != nil {
		{
			size, err := m.Epoch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Select != nil {
		{
			size, err := m.Select.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Invoke != nil {
		{
			size, err := m.Invoke.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Access != nil {
		{
			size, err := m.Access.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Mode != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x10
	}
	if m.Revision != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PinSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PinSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PinSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for iNdEx := len(m.Ranges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ranges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAmpCore(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *AddrRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddrRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddrRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Edit_Hi_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Edit_Hi_1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb9
	}
	if m.Edit_Lo_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Edit_Lo_1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb1
	}
	if m.Edit_Hi_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Edit_Hi_0))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa9
	}
	if m.Edit_Lo_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Edit_Lo_0))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa1
	}
	if m.Item_Hi_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Item_Hi_1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.Item_Lo_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Item_Lo_1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.Item_Hi_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Item_Hi_0))
		i--
		dAtA[i] = 0x79
	}
	if m.Item_Lo_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Item_Lo_0))
		i--
		dAtA[i] = 0x71
	}
	if m.Attr_Hi_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Attr_Hi_1))
		i--
		dAtA[i] = 0x69
	}
	if m.Attr_Lo_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Attr_Lo_1))
		i--
		dAtA[i] = 0x61
	}
	if m.Attr_Hi_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Attr_Hi_0))
		i--
		dAtA[i] = 0x59
	}
	if m.Attr_Lo_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Attr_Lo_0))
		i--
		dAtA[i] = 0x51
	}
	if m.Chan_Hi_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Chan_Hi_1))
		i--
		dAtA[i] = 0x39
	}
	if m.Chan_Lo_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Chan_Lo_1))
		i--
		dAtA[i] = 0x31
	}
	if m.Chan_Hi_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Chan_Hi_0))
		i--
		dAtA[i] = 0x29
	}
	if m.Chan_Lo_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Chan_Lo_0))
		i--
		dAtA[i] = 0x21
	}
	if m.Weight != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Weight))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *AccessControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Credentials != nil {
		{
			size, err := m.Credentials.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ChannelEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChannelEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x52
	}
	if m.TypeID != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.TypeID))
		i--
		dAtA[i] = 0x19
	}
	if m.ParentChannel != nil {
		{
			size, err := m.ParentChannel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Channel != nil {
		{
			size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Units != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.Units))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Grid != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.Grid))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.J != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.J))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.I != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.I))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.R != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.R))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ID_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ID_1))
		i--
		dAtA[i] = 0x21
	}
	if m.ID_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ID_0))
		i--
		dAtA[i] = 0x19
	}
	return len(dAtA) - i, nil
}

func (m *Tags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tags) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tags) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAmpCore(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SubTags) > 0 {
		for iNdEx := len(m.SubTags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubTags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAmpCore(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Head != nil {
		{
			size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAmpCore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Err) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Err) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Err) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintAmpCore(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x22
	}
	if m.Level != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if m.Code != 0 {
		i = encodeVarintAmpCore(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAmpCore(dAtA []byte, offset int, v uint64) int {
	offset -= sovAmpCore(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TxHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxID_0 != 0 {
		n += 9
	}
	if m.TxID_1 != 0 {
		n += 9
	}
	if m.Recipient != nil {
		l = m.Recipient.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.Author != nil {
		l = m.Author.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 2 + l + sovAmpCore(uint64(l))
	}
	if m.Status != 0 {
		n += 2 + sovAmpCore(uint64(m.Status))
	}
	if m.OpCount != 0 {
		n += 2 + sovAmpCore(uint64(m.OpCount))
	}
	if m.ContextID_0 != 0 {
		n += 10
	}
	if m.ContextID_1 != 0 {
		n += 10
	}
	return n
}

func (m *Login) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.Planet != nil {
		l = m.Planet.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.Device != nil {
		l = m.Device.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	l = len(m.HostAddress)
	if l > 0 {
		n += 1 + l + sovAmpCore(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.Checkpoint != nil {
		l = m.Checkpoint.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	return n
}

func (m *LoginChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovAmpCore(uint64(l))
	}
	return n
}

func (m *LoginResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HashResponse)
	if l > 0 {
		n += 1 + l + sovAmpCore(uint64(l))
	}
	return n
}

func (m *LoginCheckpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenType)
	if l > 0 {
		n += 1 + l + sovAmpCore(uint64(l))
	}
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovAmpCore(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovAmpCore(uint64(m.Expiry))
	}
	l = len(m.UserID)
	if l > 0 {
		n += 1 + l + sovAmpCore(uint64(l))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovAmpCore(uint64(l))
	}
	return n
}

func (m *PinRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Revision != 0 {
		n += 1 + sovAmpCore(uint64(m.Revision))
	}
	if m.Mode != 0 {
		n += 1 + sovAmpCore(uint64(m.Mode))
	}
	if m.Access != nil {
		l = m.Access.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.Invoke != nil {
		l = m.Invoke.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.Select != nil {
		l = m.Select.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.Epoch != nil {
		l = m.Epoch.Size()
		n += 2 + l + sovAmpCore(uint64(l))
	}
	return n
}

func (m *PinSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovAmpCore(uint64(l))
		}
	}
	return n
}

func (m *AddrRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Weight != 0 {
		n += 5
	}
	if m.Chan_Lo_0 != 0 {
		n += 9
	}
	if m.Chan_Hi_0 != 0 {
		n += 9
	}
	if m.Chan_Lo_1 != 0 {
		n += 9
	}
	if m.Chan_Hi_1 != 0 {
		n += 9
	}
	if m.Attr_Lo_0 != 0 {
		n += 9
	}
	if m.Attr_Hi_0 != 0 {
		n += 9
	}
	if m.Attr_Lo_1 != 0 {
		n += 9
	}
	if m.Attr_Hi_1 != 0 {
		n += 9
	}
	if m.Item_Lo_0 != 0 {
		n += 9
	}
	if m.Item_Hi_0 != 0 {
		n += 9
	}
	if m.Item_Lo_1 != 0 {
		n += 10
	}
	if m.Item_Hi_1 != 0 {
		n += 10
	}
	if m.Edit_Lo_0 != 0 {
		n += 10
	}
	if m.Edit_Hi_0 != 0 {
		n += 10
	}
	if m.Edit_Lo_1 != 0 {
		n += 10
	}
	if m.Edit_Hi_1 != 0 {
		n += 10
	}
	return n
}

func (m *AccessControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	return n
}

func (m *ChannelEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.ParentChannel != nil {
		l = m.ParentChannel.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if m.TypeID != 0 {
		n += 9
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovAmpCore(uint64(l))
	}
	return n
}

func (m *Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID_0 != 0 {
		n += 9
	}
	if m.ID_1 != 0 {
		n += 9
	}
	if m.R != 0 {
		n += 2 + sovAmpCore(uint64(m.R))
	}
	if m.I != 0 {
		n += 2 + sovAmpCore(uint64(m.I))
	}
	if m.J != 0 {
		n += 2 + sovAmpCore(uint64(m.J))
	}
	if m.Grid != 0 {
		n += 2 + sovAmpCore(uint64(m.Grid))
	}
	if m.Units != 0 {
		n += 2 + sovAmpCore(uint64(m.Units))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 2 + l + sovAmpCore(uint64(l))
	}
	l = len(m.URI)
	if l > 0 {
		n += 2 + l + sovAmpCore(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 2 + l + sovAmpCore(uint64(l))
	}
	return n
}

func (m *Tags) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovAmpCore(uint64(l))
	}
	if len(m.SubTags) > 0 {
		for _, e := range m.SubTags {
			l = e.Size()
			n += 1 + l + sovAmpCore(uint64(l))
		}
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovAmpCore(uint64(l))
		}
	}
	return n
}

func (m *Err) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAmpCore(uint64(m.Code))
	}
	if m.Level != 0 {
		n += 1 + sovAmpCore(uint64(m.Level))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovAmpCore(uint64(l))
	}
	return n
}

func sovAmpCore(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAmpCore(x uint64) (n int) {
	return sovAmpCore(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TxHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TxHeader{`,
		`TxID_0:` + fmt.Sprintf("%v", this.TxID_0) + `,`,
		`TxID_1:` + fmt.Sprintf("%v", this.TxID_1) + `,`,
		`Recipient:` + strings.Replace(this.Recipient.String(), "Tag", "Tag", 1) + `,`,
		`Author:` + strings.Replace(this.Author.String(), "Tag", "Tag", 1) + `,`,
		`Signature:` + strings.Replace(this.Signature.String(), "Tag", "Tag", 1) + `,`,
		`Request:` + strings.Replace(this.Request.String(), "PinRequest", "PinRequest", 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`OpCount:` + fmt.Sprintf("%v", this.OpCount) + `,`,
		`ContextID_0:` + fmt.Sprintf("%v", this.ContextID_0) + `,`,
		`ContextID_1:` + fmt.Sprintf("%v", this.ContextID_1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Login) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Login{`,
		`User:` + strings.Replace(this.User.String(), "Tag", "Tag", 1) + `,`,
		`Planet:` + strings.Replace(this.Planet.String(), "Tag", "Tag", 1) + `,`,
		`Device:` + strings.Replace(this.Device.String(), "Tag", "Tag", 1) + `,`,
		`HostAddress:` + fmt.Sprintf("%v", this.HostAddress) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`Checkpoint:` + strings.Replace(this.Checkpoint.String(), "LoginCheckpoint", "LoginCheckpoint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginChallenge{`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginResponse{`,
		`HashResponse:` + fmt.Sprintf("%v", this.HashResponse) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginCheckpoint) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginCheckpoint{`,
		`TokenType:` + fmt.Sprintf("%v", this.TokenType) + `,`,
		`AccessToken:` + fmt.Sprintf("%v", this.AccessToken) + `,`,
		`RefreshToken:` + fmt.Sprintf("%v", this.RefreshToken) + `,`,
		`Expiry:` + fmt.Sprintf("%v", this.Expiry) + `,`,
		`UserID:` + fmt.Sprintf("%v", this.UserID) + `,`,
		`URI:` + fmt.Sprintf("%v", this.URI) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PinRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PinRequest{`,
		`Revision:` + fmt.Sprintf("%v", this.Revision) + `,`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`Access:` + strings.Replace(this.Access.String(), "AccessControl", "AccessControl", 1) + `,`,
		`Invoke:` + strings.Replace(this.Invoke.String(), "Tag", "Tag", 1) + `,`,
		`Select:` + strings.Replace(this.Select.String(), "PinSelector", "PinSelector", 1) + `,`,
		`Epoch:` + strings.Replace(this.Epoch.String(), "ChannelEpoch", "ChannelEpoch", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PinSelector) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRanges := "[]*AddrRange{"
	for _, f := range this.Ranges {
		repeatedStringForRanges += strings.Replace(f.String(), "AddrRange", "AddrRange", 1) + ","
	}
	repeatedStringForRanges += "}"
	s := strings.Join([]string{`&PinSelector{`,
		`Anchor:` + strings.Replace(this.Anchor.String(), "Tag", "Tag", 1) + `,`,
		`Ranges:` + repeatedStringForRanges + `,`,
		`}`,
	}, "")
	return s
}
func (this *AddrRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AddrRange{`,
		`Weight:` + fmt.Sprintf("%v", this.Weight) + `,`,
		`Chan_Lo_0:` + fmt.Sprintf("%v", this.Chan_Lo_0) + `,`,
		`Chan_Hi_0:` + fmt.Sprintf("%v", this.Chan_Hi_0) + `,`,
		`Chan_Lo_1:` + fmt.Sprintf("%v", this.Chan_Lo_1) + `,`,
		`Chan_Hi_1:` + fmt.Sprintf("%v", this.Chan_Hi_1) + `,`,
		`Attr_Lo_0:` + fmt.Sprintf("%v", this.Attr_Lo_0) + `,`,
		`Attr_Hi_0:` + fmt.Sprintf("%v", this.Attr_Hi_0) + `,`,
		`Attr_Lo_1:` + fmt.Sprintf("%v", this.Attr_Lo_1) + `,`,
		`Attr_Hi_1:` + fmt.Sprintf("%v", this.Attr_Hi_1) + `,`,
		`Item_Lo_0:` + fmt.Sprintf("%v", this.Item_Lo_0) + `,`,
		`Item_Hi_0:` + fmt.Sprintf("%v", this.Item_Hi_0) + `,`,
		`Item_Lo_1:` + fmt.Sprintf("%v", this.Item_Lo_1) + `,`,
		`Item_Hi_1:` + fmt.Sprintf("%v", this.Item_Hi_1) + `,`,
		`Edit_Lo_0:` + fmt.Sprintf("%v", this.Edit_Lo_0) + `,`,
		`Edit_Hi_0:` + fmt.Sprintf("%v", this.Edit_Hi_0) + `,`,
		`Edit_Lo_1:` + fmt.Sprintf("%v", this.Edit_Lo_1) + `,`,
		`Edit_Hi_1:` + fmt.Sprintf("%v", this.Edit_Hi_1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccessControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AccessControl{`,
		`Credentials:` + strings.Replace(this.Credentials.String(), "Tags", "Tags", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChannelEpoch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChannelEpoch{`,
		`Channel:` + strings.Replace(this.Channel.String(), "Tag", "Tag", 1) + `,`,
		`ParentChannel:` + strings.Replace(this.ParentChannel.String(), "Tag", "Tag", 1) + `,`,
		`TypeID:` + fmt.Sprintf("%v", this.TypeID) + `,`,
		`Comment:` + fmt.Sprintf("%v", this.Comment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Tag) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Tag{`,
		`ID_0:` + fmt.Sprintf("%v", this.ID_0) + `,`,
		`ID_1:` + fmt.Sprintf("%v", this.ID_1) + `,`,
		`R:` + fmt.Sprintf("%v", this.R) + `,`,
		`I:` + fmt.Sprintf("%v", this.I) + `,`,
		`J:` + fmt.Sprintf("%v", this.J) + `,`,
		`Grid:` + fmt.Sprintf("%v", this.Grid) + `,`,
		`Units:` + fmt.Sprintf("%v", this.Units) + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`URI:` + fmt.Sprintf("%v", this.URI) + `,`,
		`Text:` + fmt.Sprintf("%v", this.Text) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Tags) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubTags := "[]*Tag{"
	for _, f := range this.SubTags {
		repeatedStringForSubTags += strings.Replace(f.String(), "Tag", "Tag", 1) + ","
	}
	repeatedStringForSubTags += "}"
	repeatedStringForChildren := "[]*Tags{"
	for _, f := range this.Children {
		repeatedStringForChildren += strings.Replace(f.String(), "Tags", "Tags", 1) + ","
	}
	repeatedStringForChildren += "}"
	s := strings.Join([]string{`&Tags{`,
		`Head:` + strings.Replace(this.Head.String(), "Tag", "Tag", 1) + `,`,
		`SubTags:` + repeatedStringForSubTags + `,`,
		`Children:` + repeatedStringForChildren + `,`,
		`}`,
	}, "")
	return s
}
func (this *Err) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Err{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAmpCore(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TxHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID_0", wireType)
			}
			m.TxID_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID_1", wireType)
			}
			m.TxID_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Recipient == nil {
				m.Recipient = &Tag{}
			}
			if err := m.Recipient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Author == nil {
				m.Author = &Tag{}
			}
			if err := m.Author.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &Tag{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &PinRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PinStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCount", wireType)
			}
			m.OpCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextID_0", wireType)
			}
			m.ContextID_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ContextID_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextID_1", wireType)
			}
			m.ContextID_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ContextID_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Login) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Login: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Login: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &Tag{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Planet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Planet == nil {
				m.Planet = &Tag{}
			}
			if err := m.Planet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &Tag{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checkpoint == nil {
				m.Checkpoint = &LoginCheckpoint{}
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashResponse", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashResponse = append(m.HashResponse[:0], dAtA[iNdEx:postIndex]...)
			if m.HashResponse == nil {
				m.HashResponse = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginCheckpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginCheckpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginCheckpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PinRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PinRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PinRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= PinMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Access == nil {
				m.Access = &AccessControl{}
			}
			if err := m.Access.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invoke", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invoke == nil {
				m.Invoke = &Tag{}
			}
			if err := m.Invoke.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Select", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Select == nil {
				m.Select = &PinSelector{}
			}
			if err := m.Select.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Epoch == nil {
				m.Epoch = &ChannelEpoch{}
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PinSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PinSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PinSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &Tag{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &AddrRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddrRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddrRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddrRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Weight = float32(math.Float32frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chan_Lo_0", wireType)
			}
			m.Chan_Lo_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Chan_Lo_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chan_Hi_0", wireType)
			}
			m.Chan_Hi_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Chan_Hi_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chan_Lo_1", wireType)
			}
			m.Chan_Lo_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Chan_Lo_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chan_Hi_1", wireType)
			}
			m.Chan_Hi_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Chan_Hi_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr_Lo_0", wireType)
			}
			m.Attr_Lo_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr_Lo_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr_Hi_0", wireType)
			}
			m.Attr_Hi_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr_Hi_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr_Lo_1", wireType)
			}
			m.Attr_Lo_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr_Lo_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr_Hi_1", wireType)
			}
			m.Attr_Hi_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr_Hi_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item_Lo_0", wireType)
			}
			m.Item_Lo_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Item_Lo_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item_Hi_0", wireType)
			}
			m.Item_Hi_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Item_Hi_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item_Lo_1", wireType)
			}
			m.Item_Lo_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Item_Lo_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item_Hi_1", wireType)
			}
			m.Item_Hi_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Item_Hi_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edit_Lo_0", wireType)
			}
			m.Edit_Lo_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Edit_Lo_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edit_Hi_0", wireType)
			}
			m.Edit_Hi_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Edit_Hi_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edit_Lo_1", wireType)
			}
			m.Edit_Lo_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Edit_Lo_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edit_Hi_1", wireType)
			}
			m.Edit_Hi_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Edit_Hi_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &Tags{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &Tag{}
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentChannel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentChannel == nil {
				m.ParentChannel = &Tag{}
			}
			if err := m.ParentChannel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeID = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID_0", wireType)
			}
			m.ID_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ID_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID_1", wireType)
			}
			m.ID_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ID_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			m.R = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.R |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I", wireType)
			}
			m.I = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.I |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field J", wireType)
			}
			m.J = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.J |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grid", wireType)
			}
			m.Grid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Grid |= Grid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			m.Units = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Units |= Units(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &Tag{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubTags = append(m.SubTags, &Tag{})
			if err := m.SubTags[len(m.SubTags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Tags{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Err) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Err: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Err: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= LogLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAmpCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAmpCore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAmpCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAmpCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAmpCore(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAmpCore
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAmpCore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAmpCore
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAmpCore
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAmpCore
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAmpCore        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAmpCore          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAmpCore = fmt.Errorf("proto: unexpected end of group")
)
